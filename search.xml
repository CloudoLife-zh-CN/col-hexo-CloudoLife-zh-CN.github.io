<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[Kreado AI] AI赋能数字人内容,Kreado AI开创虚实融合的互动新纪元</title>
    <url>/2023/07/11/Artificial-Intelligence-AI/ai-empowers-digital-humans-kreado-ai-ushers-in-a-new-era-of-virtual-reality-convergence-and-interaction/</url>
    <content><![CDATA[<h1>AI赋能数字人内容,Kreado AI开创虚实融合的互动新纪元</h1>
<p>当下数字经济时代,企业内容营销面临巨大变革——AI技术的发展为数字人内容的创作提供了强大动力,虚拟数字人不断走进广告、直播等商业应用场景。作为内容变现新机遇,数字人经济方兴未艾。易点天下旗下的KreadoAI 最近推出数字人视频和直播解决方案,进一步拓展了这一应用范围,值得业内关注。</p>
<p><a href="https://kreadoai.com/">https://kreadoai.com/</a></p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c96baf44-0fb1-40a9-b77a-91dc8d440af1/Untitled.png" alt="Untitled"></p>
<p>KreadoAI平台提供100多种参数可调的数字人形象,覆盖不同年龄、肤色、角色。输入文本后可自动生成语音及口型动画,可指定语言及发音风格,实现个性化创作。此外,还支持上传音频进行语音克隆,以数字人形象替换真人音频,实现跨语种应用。这些功能大幅降低视频制作门槛,用户可快速生成逼真的数字人内容。</p>
<p>该平台还涵盖AI虚拟模特、换脸、抠图、文案生成等能力。结合积累的海量营销数据,可以输出高转化文案。这为客户的营销创意、产品展示等提供了强有力支撑。据统计,利用AI生成内容,客户广告转化率提升35%,CPC降低45%。</p>
<p>在直播领域,数字人主播也成为新兴模式。其24小时不间断、可个性化定制的优势,满足弹幕互动、长时间陪伴等用户需求。语音互动系统打通线上线下,实现虚拟主播与真人主播混搭联动,带来更丰富的互动可能。未来,AI数字人形象可能进一步实现“数字克隆”,达到与真人逼真对话的效果。</p>
<p>可以预见,数字人经济正在蓬勃发展,各行各业都将应用数字人方案实现内容变现。但技术伦理规范也需关注,确保健康有序发展。总体而言,AI赋能数字人内容正开启虚拟世界与现实世界融合的新局面,继续推进具备独特价值的虚实共生新时代。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://kreadoai.com/">KreadoAI_AI video creation platform/AI视频创作平台/kreadoai.com - https://kreadoai.com/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Kreado AI</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Kreado AI</tag>
      </tags>
  </entry>
  <entry>
    <title>[Artificial Intelligence (AI)] AI模型“九式归一”,哪家强统领未来</title>
    <url>/2023/07/18/Artificial-Intelligence-AI/ai-models-the-quest-to-find-one-model-to-rule-them-all/</url>
    <content><![CDATA[<h1>AI模型“九式归一”,哪家强统领未来</h1>
<p>当今AI发展日新月异,各大科技公司纷纷推出自己的AI产品,使选择合适的AI模型变得令人困惑。针对不同任务,究竟应该使用哪种AI模型呢?这里做一个简要梳理,让大家在各种场景中能够顺利找到“主心骨”。</p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2045a98d-6756-4102-8398-a652f10ce6da/Untitled.png" alt="Untitled"></p>
<h2 id="OpenAI-GPT-4">OpenAI GPT-4</h2>
<p>若需要生成较长文本,尤其是涉及创意写作,OpenAI的GPT-4更占优势。它拥有卓越的语言理解与创作能力,是撰写任务的不二之选。</p>
<p>涉及复杂推理和判断的难题,GPT-4仍是首选。它拥有更强的逻辑思维能力。</p>
<p><a href="https://chat.openai.com/">https://chat.openai.com/</a></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/323fb5c5-2bff-4c7c-a703-af220a56d639/OpenAI-GPT-4.jpg" alt="OpenAI-GPT-4.jpg"></p>
<h2 id="OpenAI-ChatGPT-Code-Interpreter">OpenAI ChatGPT Code Interpreter</h2>
<p>进行数据分析任务时 OpenAI 开放的 *Code Interpreter 将是理想的选择，*让我们仅仅通过对话就能分析庞大而复杂的数据</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc631c80-fab0-466a-9611-ea99ce928d43/Code-Interpreter.jpg" alt="Code-Interpreter.jpg"></p>
<h2 id="Google-Bard">Google Bard</h2>
<p>对于日常网络搜索等互联网任务,Google新推出的对话AI Bard将是首选。它结合大规模知识库与语言模型优势,能提供实时的网络信息查询。</p>
<p>进行图像内容分析时,同样首推Bard。图像 Caption等视觉理解也是其强项。</p>
<p><a href="https://bard.google.com/">https://bard.google.com/</a></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a1b9cef3-ae45-4519-af18-4be8288a7507/Google-Bard.jpeg" alt="Google-Bard.jpeg"></p>
<h2 id="Anthropic-Claude">Anthropic Claude</h2>
<p>对较长PDF文档的分析综述,要属Anthropic的Claude 2。它更适合处理长段落文本,理解文档主旨。</p>
<p><a href="https://console.anthropic.com/">https://console.anthropic.com/</a></p>
<p>类似需要理解长篇语境的任务,Claude 2也将大有作为。它在多轮语境任务上表现强劲。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/98b5af4d-d7cb-491a-bf3c-e5392c44f235/Claude.webp" alt="Claude.webp"></p>
<h2 id="Microsoft-Bing">Microsoft Bing</h2>
<p>对于融合互联网搜索的学术任务,可以考虑Microsoft Bing 必应搜索引擎提供的聊天机器人。知识图谱支持,使其在学术问题解答上也有一定优势。</p>
<p><a href="https://cn.bing.com/">https://cn.bing.com/</a></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9869264e-9002-461b-b027-2545ba956b25/New-Bing.jpg" alt="New-Bing.jpg"></p>
<h2 id="GitHub-Copilot">GitHub Copilot</h2>
<p>而针对编程等代码生成任务,GitHub的Copilot模型则会是首要选择。Copilot经过大量技术文档训练,更擅长编写程序代码。</p>
<p><a href="https://github.com/features/copilot">https://github.com/features/copilot</a></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/87c30fe9-19c6-4fa8-9c07-3809940a8ecb/GitHub-Copilot.webp" alt="GitHub-Copilot.webp"></p>
<p>综上,不同AI模型各有专长,没有绝对的全能型产品。按照“把人的问题,交给对的人”的原则,根据具体使用场景选择匹配的AI,将是最佳实践。随着模型继续进化,单一模型能力还将不断增强,届时实现“九式归一”也指日可待。但目前多AI并存仍是大势所趋。望各位使用者找到最匹配的AI搭档,共创美好未来!</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>OpenAI GPT-4</tag>
        <tag>OpenAI ChatGPT Code Interpreter</tag>
        <tag>Google Bard</tag>
        <tag>Anthropic Claude</tag>
        <tag>Microsoft Bing</tag>
        <tag>GitHub Copilot</tag>
      </tags>
  </entry>
  <entry>
    <title>[HeyGen] AI虚拟形象助力视频制作,HeyGen让生成视频变得简单</title>
    <url>/2023/07/12/Artificial-Intelligence-AI/ai-virtual-avatars-facilitate-video-production-heygen-makes-generative-video-simple/</url>
    <content><![CDATA[<h1>AI虚拟形象助力视频制作,HeyGen让生成视频变得简单</h1>
<p>视频内容已成为企业宣传的重要组成部分,但对许多企业来说,视频制作不仅费时费力,也需要专业技术。这一难题或将迎来突破——最近,一家名为HeyGen的创业公司推出了AI驱动的视频制作平台,只需文字稿件,即可自动生成具备口型同步的虚拟形象视频。这为企业级视频内容制作带来了革命性的便利。</p>
<p><a href="https://www.heygen.com/">https://www.heygen.com/</a></p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6f0e1909-c8cf-4423-92ad-d56ac535abe8/Untitled.png" alt="Untitled"></p>
<p>HeyGen提供100多个可自定义的虚拟形象,并支持40多种语言的语音合成,用户只需输入文字稿件,选择虚拟形象和语音,即可在几分钟内生成动态视频。无需拍摄现场、后期剪辑等复杂工作。这极大地降低了视频制作门槛,使任何组织都可以轻松地产出高质量、富有表现力的视频内容。</p>
<p>该平台可广泛应用于企业的市场营销、内部培训、产品演示等业务场景。个性化的虚拟形象和流畅的口型同步,为传递的信息增加了亲和力。与冰冷的文本相比,视频更能吸引用户注意力并提升内容记忆。</p>
<p>在视频大行其道的数字化时代,使用AI辅助技术实现快速内容变现,已成为企业的重要核心竞争力。HeyGen等先锋平台正引领这一趋势。值得注意的是,这类AI生成内容也面临合法性审查的挑战。但若平台制定明确内容审核机制,也会打开高效、个性化视频内容产出的新机遇。毫无疑问,富有表现力的视频必将推动企业的数字化转型与商业成功。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://www.heygen.com/">HeyGen - AI Video Generator - https://www.heygen.com/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>HeyGen</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>HeyGen</tag>
      </tags>
  </entry>
  <entry>
    <title>[LetMeSpeak] LetMeSpeak 以玩赚英语,Web3赋能英语学习</title>
    <url>/2023/07/14/Artificial-Intelligence-AI/letmespeak-learn-and-earn-english-with-gameplay-empowered-by-web3/</url>
    <content><![CDATA[<h1>LetMeSpeak 以玩赚英语,Web3赋能英语学习</h1>
<p>随着区块链和元宇宙技术的兴起,“玩赚经济”模式也正在影响教育领域。一款名为<strong><strong>LetMeSpeak</strong></strong>的英语学习App推出,这是全球首个应用了“玩赚”模式的英语学习平台。用户通过App学习英语的同时,还能赚取数字通证作为奖励。这种玩游戏化的英语学习形式,不仅提高了用户的学习动力,还实现了知识价值的数字化,值得业内关注。</p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e84d6f49-f333-4292-9910-6ddd951c414b/Untitled.png" alt="Untitled"></p>
<p>Learn&amp;Earn的学习体系十分科学系统。它将英语单词记忆、语法学习、口语对话训练等环节融入到游戏任务中,用户完成每一个“任务”就能获得相应的LSTAR通证奖励。这些通证还可以兑换成数字货币,用于平台商店或实体消费。这样的金融激励机制,大大提升了用户的学习主动性。数据显示,与普通英语学习App相比,Learn&amp;Earn的用户词汇学习量提升4倍,持续学习用户比例提升5倍。金融的激励确实能增强学习的成效。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/da8eae2a-5a12-436e-9b9b-6c43b00ecce7/Untitled.png" alt="Untitled"></p>
<p>除了金融激励,Learn&amp;Earn的学习体验也进行了技术创新——它采用了系统语言学和认知科学最新成果,让英语学习变得更科学。例如,采用间隔重复算法帮助单词记忆更牢固,利用情景对话训练口语,以游戏化形式讲解语法知识等。简单来说,是用科技手段营造沉浸式的英语环境,让学习更高效。用户可实时获取学习反馈,技术与教学深度融合。</p>
<p>总体来看,Learn&amp;Earn开创了英语学习的新模式,正如其标语所言“学习英语,玩赚奖励”。它可能代表未来数字时代教育产业的新方向——不再是简单制作内容,而是构建一个学习生态闭环。在这个闭环中,学习行为被赋予经济价值,与生活场景深度融合。</p>
<p>当然,这种玩赚教育模式也存在一定挑战。如何持续优化学习内容,提供个性化建议;如何设计合理的经济激励机制,避免用户过度沉迷;如何评估学习成效,实现知识价值与经济价值的平衡等。但这些挑战也包含着机遇——通过科技手段营造极致用户体验,实现知识传播的规模化。</p>
<p>相信在不久的将来,这种玩赚式学习会成为主流,教育也将迎来产业革命式的变革。技术正在赋能新的教育模式,让学习过程变得更轻松有趣,同时与经济增长相结合。Learn&amp;Earn或许正展示了数字经济与学习未来的一个可能样貌。各类教育企业和机构也应积极拥抱科技变革,以创新应对挑战,抓住机遇,塑造数字化学习的新生态。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://letmespeak.org/">LetMeSpeak – Learn English and Earn - https://letmespeak.org/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>LetMeSpeak</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>English Speaking</tag>
        <tag>LetMeSpeak</tag>
      </tags>
  </entry>
  <entry>
    <title>[COVID] 2022 年平安夜发烧</title>
    <url>/2022/12/31/Thinking/COVID-2022-Christmas-Eve-Fever/</url>
    <content><![CDATA[<p>2022 年平安夜，我突然发烧了。平时出门都很小心地带口罩防护，没想到很快还是遇上了。发烧期间没敢出门做核酸，只是在家自测抗原阳性。</p>
<span id="more"></span>
<h2 id="过程和感受">过程和感受</h2>
<ul>
<li>第 0 天
<ul>
<li>下午
<ul>
<li>周边陆续有人发烧。氛围开始有点微妙和紧张。吃了点零食，晚上感觉喉咙得有点不舒服</li>
</ul>
</li>
</ul>
</li>
<li>第 1 天
<ul>
<li>上午
<ul>
<li>起床感觉有点不舒服，喉咙疼，有点流鼻涕，头有点晕，但还是去公园溜了 1 圈</li>
</ul>
</li>
<li>中午
<ul>
<li>吃完饭后感觉有点累，在沙发上休息。耳温枪显示 38.7 度，低烧</li>
</ul>
</li>
<li>下午
<ul>
<li>感觉头开始疼，脚没力气，开始大量喝水，喝柠檬水，待在独立房间里先晒一会太阳。后来觉得全身都开始疼起来，不再硬扛，直接上床睡觉</li>
</ul>
</li>
<li>下午
<ul>
<li>16 点睡醒后，耳温枪显示 39.3 度，高烧。 马上吃了 2 片布洛芬药片，30 分钟后开始退烧，身体也不疼了。</li>
</ul>
</li>
<li>晚上
<ul>
<li>18 点吃晚饭，胃口还可以，尽量把饭、菜和汤都干掉了，为的是抓紧机会补充蛋白质和水分。</li>
<li>20 点，布洛芬药片 4 小时药效过了，又开始头疼，直接去床上睡觉，觉得全身都在疼，疼得一边哼哼，一边睡觉</li>
</ul>
</li>
</ul>
</li>
<li>第 2 天
<ul>
<li>凌晨
<ul>
<li>3 点醒来，耳温枪显示 39.3 度，直接吃 1 片布洛芬药片，继续躺下睡觉</li>
<li>5 点醒来，感觉身体有点出汗，衣服有湿，脱掉衣服继续睡觉</li>
</ul>
</li>
<li>上午
<ul>
<li>9 点起床，耳温枪显示 38 度左右，咳嗽开始有痰，痰有点血丝，嗓子疼。吃完早餐，开始晒太阳。自测抗原二条杠，阳性</li>
</ul>
</li>
<li>中午
<ul>
<li>12 点吃中饭，耳温枪显示 37 度左右，感觉有点退烧，心里开始有点得意</li>
</ul>
</li>
<li>下午
<ul>
<li>16 点醒来，耳温枪显示 38 度左右，低烧。感觉有点失落，心情变得不太愉快</li>
</ul>
</li>
<li>晚上
<ul>
<li>18 点吃晚饭，胃口不太好，感觉骨头汤有点恶心，但还是强迫自己尽量喝下去</li>
</ul>
</li>
</ul>
</li>
<li>第 3 天
<ul>
<li>上午
<ul>
<li>柠檬水实在是喝太多了，舌头都破了，但还坚持大量喝水</li>
</ul>
</li>
<li>晚上
<ul>
<li>19 点，耳温枪显示 36.5 度，感觉退烧了，但还是觉得头疼。自测抗原一条杠，阴性。</li>
</ul>
</li>
</ul>
</li>
<li>第 4 天
<ul>
<li>头疼
<ul>
<li>感觉整个头很疼，没太多力气，稍做下家务，就开始气喘吁吁</li>
</ul>
</li>
<li>咳嗽
<ul>
<li>开始咳嗽，几乎是忍不住的咳嗽。感觉喉咙有痰，但是很难咳出来。</li>
</ul>
</li>
<li>怕冷
<ul>
<li>身体怕冷，在室内也多穿一层衣服，戴帽子，尽量避风吹</li>
</ul>
</li>
</ul>
</li>
<li>第 5 天
<ul>
<li>流鼻涕
<ul>
<li>流鼻涕，几乎是滴滴答答流个不停，还经常打喷嚏</li>
</ul>
</li>
<li>活动
<ul>
<li>终于出门去溜了一圈，穿厚衣服，戴帽子，捂得暖暖得才敢出去</li>
</ul>
</li>
</ul>
</li>
<li>第 6 天
<ul>
<li>头疼
<ul>
<li>太阳穴到后脑勺一阵阵的疼</li>
</ul>
</li>
</ul>
</li>
<li>第 7 天
<ul>
<li>咳嗽
<ul>
<li>偶尔</li>
</ul>
</li>
<li>流鼻涕
<ul>
<li>偶尔</li>
</ul>
</li>
<li>头疼
<ul>
<li>偶尔</li>
</ul>
</li>
<li>怕冷
<ul>
<li>偶尔</li>
</ul>
</li>
<li>中午稍暖时终于洗了一个热水澡。感觉算是康复了，逃过一劫。不过还是尽量保持体力，不敢做太剧烈的运动。</li>
</ul>
</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>症状
<ul>
<li>发烧，反复两次高烧 39 度以上，如果没有进一步恶化，建议靠自身免疫力硬扛，尽量少吃药</li>
<li>保暖，尽量多穿衣服、睡觉多盖被子，戴帽子，防风吹，尽量不洗头洗澡。</li>
<li>全身疼痛、嗓子疼、咳嗽和头疼，必要时可以按症状吃药</li>
<li>建议尽量躺平卧床休息，缓解症状给身体带来的不适</li>
<li>症状因人而异，从周边情况来看，不打疫苗、3 岁以上的小朋友症状最轻，过程也最短。</li>
</ul>
</li>
<li>口罩
<ul>
<li>戴口罩只能拖延发烧症状出现的时间，再怎么小心戴口罩防护也无法避免发烧，建议放松心情，应烧尽烧</li>
</ul>
</li>
<li>疫苗
<ul>
<li>疫苗也无法避免发烧。</li>
</ul>
</li>
<li>药品
<ul>
<li>布洛芬退烧和缓解疼痛效果真好，30 分钟后开始起效，4 个小时后开始失效</li>
</ul>
</li>
<li>水果
<ul>
<li>苹果、梨、橙子、橘子等含水和维生素 C 丰富的水果</li>
</ul>
</li>
<li>餐饮
<ul>
<li>尽量吃含蛋白质丰富的肉类和牛奶，补充身体自身免疫力</li>
</ul>
</li>
<li>饮水
<ul>
<li>建议大量喝水，有助于缓解发烧和咳嗽症状</li>
</ul>
</li>
<li>物品
<ul>
<li>耳温枪或体温计，及时测量体温，采取正确的应对措施</li>
<li>iPhone, iPad 看看消息、视频有助于缓解心情焦虑</li>
</ul>
</li>
<li>照料
<ul>
<li>家人的细心照料和相互扶持是度过困难时期的关键</li>
</ul>
</li>
</ul>
<p>最后祝愿大家都能顺利度过这个寒冷的冬天，开始体验 2023 新一年的美好生活。</p>
]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>Christmas Eve</tag>
        <tag>Ibuprofen</tag>
        <tag>Vaccine</tag>
        <tag>Mask</tag>
        <tag>Fever</tag>
        <tag>COVID</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Apple Developer Program] 注册加入 Apple Developer Program 的经历</title>
    <url>/2022/11/05/Apple/Apple%20Developer/Enrolling-in-the-Apple-Developer-Program/</url>
    <content><![CDATA[<p>如果想在 iPhone、iPad、Mac、Apple Watch、Apple TV 和 iMessage 的 App Store 中分发 App 应用，首先必须注册加入 Apple Developer Program 成为 Apple 开发者。</p>
<span id="more"></span>
<h2 id="申请流程">- 申请流程</h2>
<h3 id="1-Apple-ID">1. Apple ID</h3>
<p>首先需要注册一个 Apple ID，该 Apple ID 至少需要满足以下条件：</p>
<ul>
<li>
<p>启用双重认证，操作详见<a href="https://developer.apple.com/cn/support/authentication/">双重认证 - 帐户管理 - 支持 - Apple Developer - https://developer.apple.com/cn/support/authentication/</a></p>
</li>
<li>
<p>没有成为过 Apple 开发者</p>
</li>
<li>
<p>已经配置正确的支付方式</p>
</li>
</ul>
<h3 id="2-申请加入-Apple-开发者计划">2. 申请加入 Apple 开发者计划</h3>
<p>使用 iPhone 或 iPad 下载安装 Apple Developer 应用。使用 Apple ID 和密码登录 Apple Developer 应用</p>
<ul>
<li>
<p>填写个人基本信息（姓名、地址等）</p>
</li>
<li>
<p>填写个人认证信息，注意：</p>
<ul>
<li>
<p>填写的个人认证信息必须是未经过 Apple 开发者认证的，Apple 开发者不支持多个 Apple ID 使用相同的个人认证信息</p>
</li>
<li>
<p>拍照上传个人照片</p>
</li>
</ul>
</li>
<li>
<p>选择开发者类型</p>
</li>
<li>
<p>支付会员资格费用</p>
</li>
</ul>
<h3 id="3-上传身份证照片">3. 上传身份证照片</h3>
<p>成功支付会员资格费用之后，（一个工作日左右）会收到一封来自 Apple 的邮件。需要根据邮件中提供的页面链接上传身份证照片（注意提交身份证正面和反面照片）</p>
<h3 id="4-等待-Apple-审核通过">4. 等待 Apple 审核通过</h3>
<p>Apple 审核通过之后，就成为 Apple 开发者。</p>
<p>顺利的话，最快可以在 2 ~ 3 个工作日之内申请成为 Apple 开发者。</p>
<h2 id="我们的经历">我们的经历</h2>
<p>我们申请 Apple 开发者的过程可谓一波三折，比预想的要多费周折。</p>
<h3 id="出师不利">出师不利</h3>
<p>一开始使用已经通过 Apple 开发者计划认证的个人信息去认证。提交个人信息和头像拍照上传后，出现提示<code>您的账户遇到问题，请联系工作人员</code>。</p>
<p>经过搜索网上信息，以及联系 Apple 开发者技术支持电话沟通，确认已经通过 Apple 开发者计划认证的个人信息是无法进行重复认证。需要更换为未通过 Apple 开发者计划认证的其他人信息。</p>
<p>换其他人信息参加 Apple 开发者计划，顺利通过个人信息和头像拍照认证，但该 Apple ID 恰好是 Family Sharing 的一个成员账户，对应组织者的当时并没有正确设置好支付方式，导致支付失败。</p>
<p>电话联系 Apple 开发者技术支持，他们认为是 iTunes 购买支付问题。建议去联系 iTunes 技术支持。</p>
<p>紧接着去联系 iTunes 技术支持。一开始告诉他们是使用 Family Sharing 支付 Apple 开发者会员资格费用遇到问题，按他们建议换了其他几种支付方式，均支付不成功。iTunes 技术支持给出的建议是 1). 退出 Family Sharing 后再次支付；2). 重新注册一个 Apple ID 重新申请成为 Apple Developer。</p>
<h3 id="误入歧途">误入歧途</h3>
<p>我们担心将 Apple ID 账户退出 Family Sharing，可能会因 iCloud 容量调整导致数据丢失。于是选择重新注册新的 Apple ID，并提交个人身份信息。结果又遇到使用已经通过 Apple 开发者计划认证的个人信息去认证的问题。</p>
<p>再次电话联系 Apple 开发者技术支持，介绍目前遇到的困境，包括第一个 Apple ID 支付失败、Family Sharing 支付失败，第二个 Apple ID 无法认证，以及多次联系 Apple 技术支持等情况。</p>
<p>Apple 开发者技术支持建议，考虑到第一个 Apple ID 已经通过个人认证，遇到的是iTunes 购买支付问题，建议去联系 iTunes 技术支持寻求帮助。尽量不要提及是支付 Apple 开发者会员资格费用，就当作支付普通的服务费用。</p>
<h3 id="峰回路转">峰回路转</h3>
<p>回顾了遇到的错误反馈，结合 Apple 技术支持的解释，我们决定暂时将通过个人认证的 Apple ID 退出 Family Sharing。然后尝试支付会员资格费用，但支付仍然失败。</p>
<p>最后再次联系 iTunes 技术支持，只反馈该 Apple ID 遇到 支付失败。不再提及 Apple 开发者等其他内容。iTunes 技术支持指导我们重新配置支付方式和尝试支付，但仍然支付失败。iTunes 技术反馈他们收到系统提示，建议我们等 24 小时后再重新支付。</p>
<p>经过 24 小时的等待，重新登录 Developers 应用，这次终于支付成功。之后 Apple Developer 提示 <code>Your purchase may take up to 48 hours to process.</code>。这说明我们的申请在等待 Apple 的审核。</p>
<p>如果此时访问 Apple Developer 的证书、标识符和描述文件，<a href="https://developer.apple.com/account/resources/">Certificates, Identifiers &amp; Profiles - https://developer.apple.com/account/resources/</a>。会出现一个错误提示 <code>Unable to find a team with the given Team ID 'XXXXXXXX' to which you belong. Please contact Apple Developer Program Support. https://developer.apple.com/support</code></p>
<h3 id="又遇波折">又遇波折</h3>
<p>过了 1 个工作日后，收到 Apple 邮件反馈，说需要上传身份证照片。我们按邮件提供的页面地址上传身份证照片</p>
<p>结果过了 1 个工作日后，又收到 Apple 邮件反馈，说缺少身份证背面照片，审核不通过，需要重新提交身份证照片，重新按邮件提供的页面地址上传身份证照片（包括身份证正面和反面照片）</p>
<h3 id="完成">完成</h3>
<p>几个小时后，重新登录 Apple Developer 时，发现已经通过 Apple 审核，成为了 Apple 开发者。<br>
登录 Apple Developer 网页，<a href="https://developer.apple.com/account/">Account - Apple Developer - https://developer.apple.com/account/</a></p>
<h2 id="经验教训">经验教训</h2>
<p>最后总结注册加入 Apple Developer Program 的一些经验教训。</p>
<h3 id="认证问题">认证问题</h3>
<p>使用已经通过 Apple 开发者计划认证的个人信息去认证</p>
<p>Apple 开发者技术支持说，签约 Apple Developer 的条款中有约定，同一个人的个人身份信息不能重复去认证多个 Apple ID 开发者。</p>
<h3 id="支付问题">支付问题</h3>
<p>在第一次支付 Apple 开发者计划会员费用时，没有提前配置好支付方式，而且尝试多次支付失败导致 Apple ID 被错误标注。<br>
支付会员资格费用之前，请务必配置好支付方式。如果支付失败，建议直接联系 iTunes 技术支持人员寻求帮助。以免尝试多次支付失败后 Apple ID 被错误标注。</p>
<h3 id="Family-Sharing">Family Sharing</h3>
<p>如果 Apple ID 属于某个 Family Sharing 组织，如果使用共享的支付方式，请检查 Family Sharing 组织者是否已经设置正确的支付方式。</p>
<h3 id="及时联系-Apple-技术支持">及时联系 Apple 技术支持</h3>
<p>尽量在工作时间内联系 Apple 技术支持，工作时间可以直接约电话联系，否则只能通过效率更慢的邮件联系</p>
<p>如果用其他人 Apple ID 或身份信息，为方便 Apple 技术支持核实账户信息，请务必请他/她在场或者使用三方通话（一般要提前联系运营商客服手工开通）一起参加讨论</p>
<h3 id="关注邮箱接收-Apple-邮件通知">关注邮箱接收 Apple 邮件通知</h3>
<p>支付 Apple 开发者计划会员资格费用后，Apple 会向注册 Apple ID 的邮箱发送一封要求上传身份证件照片的邮件。注意查收邮件并及时在规定的链接页面上传身份证件照片（正反两面）。</p>
<h2 id="后续补充">后续补充</h2>
<p>Apple ID 退出 Family Sharing 后，会收到 iCloud 提示存储空间不足（因为退出 Family Sharing 的 iCloud+ 储存空间）。待 Apple ID 完成支付 Apple Developer 会员资格费用后，由 Family Sharing 组织者重新发起邀请，点击确认重新加入即可继续享受 Family Sharing 的 iCloud+ 储存空间。</p>
<p>万幸的是，整个过程没有出现 iCloud 数据丢失的问题。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://developer.apple.com/cn/support/app-account/">使用 Apple Developer App 注册和管理您的帐户 - 支持 - Apple Developer - https://developer.apple.com/cn/support/app-account/</a></p>
<p>[2] <a href="https://developer.apple.com/cn/support/authentication/">双重认证 - 帐户管理 - 支持 - Apple Developer - https://developer.apple.com/cn/support/authentication/</a></p>
<p>[3] <a href="https://apps.apple.com/cn/app/apple-developer/id640199958">App Store 上的“Apple Developer” - https://apps.apple.com/cn/app/apple-developer/id640199958</a></p>
<p>[4] <a href="https://developer.apple.com/account/">Account - Apple Developer - https://developer.apple.com/account/</a></p>
<p>[5] <a href="https://developer.apple.com/account/resources/">Certificates, Identifiers &amp; Profiles - https://developer.apple.com/account/resources/</a></p>
]]></content>
      <categories>
        <category>Apple Developer Program</category>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>Apple ID</tag>
        <tag>iTunes</tag>
        <tag>iCloud</tag>
        <tag>Family Sharing</tag>
        <tag>Apple Developer Program</tag>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>[macOS] 在 macOS 上使用 Docker 运行 Microsoft SQL Server</title>
    <url>/2022/03/26/Apple/macOS/Running-SQL-Server-with-Docker-on-macOS/</url>
    <content><![CDATA[<p>Microsoft SQL Server 之前是不能直接安装和运行在 macOS 上的，但是从 <a href="https://www.microsoft.com/en-us/sql-server/sql-server-2017">SQL Server 2017</a> 开始，支持了 Linux，因此可以通过 Docker 使其在 macOS 上运行。</p>
<p>本文介绍使用 Docker 在 macOS 上运行 Microsoft SQL Server。</p>
<span id="more"></span>
<h2 id="安装">安装</h2>
<h3 id="安装-Docker">安装 Docker</h3>
<p>在 macOS 上如何安装Docker请看官方文档 <a href="https://docs.docker.com/docker-for-mac/install/">Install Docker Desktop on Mac - https://docs.docker.com/docker-for-mac/install/</a>。</p>
<p>也可以通过 <code>brew</code> 包管理器来安装 Docker。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install --cask docker</span><br></pre></td></tr></table></figure>
<p>关于 <code>brew</code> 的更多信息，请查阅 <a href="https://brew.sh/">The Missing Package Manager for macOS (or Linux) — Homebrew - https://brew.sh/</a>。</p>
<h3 id="拉取-SQL-Server-镜像">拉取 SQL Server 镜像</h3>
<p>执行如下命令拉取 SQL Server 镜像:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull mcr.microsoft.com/mssql/server:2017-latest</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或拉取最新 2022-latest 版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$ docker pull mcr.microsoft.com/mssql/server:2022-latest</span></span><br></pre></td></tr></table></figure>
<p>关于更多版本，请参考 <a href="https://mcr.microsoft.com/en-us/product/mssql/server/about">Microsoft SQL Server - Ubuntu based images | Microsoft Artifact Registry - https://mcr.microsoft.com/en-us/product/mssql/server/about</a></p>
<h3 id="使用-SQL-Server-镜像创建并运行容器">使用 SQL Server 镜像创建并运行容器</h3>
<p>执行如下命令使用 <code>mcr.microsoft.com/mssql/server:2017-latest</code> 镜像，创建一个名称为 sqlserver 的容器，该容器的端口为1433。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;SA_PASSWORD=Passw0rd&quot; \</span><br><span class="line">		-p 1433:1433 --rm --name sqlserver \</span><br><span class="line">		-d mcr.microsoft.com/mssql/server:2017-latest</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>
<p><code>-e &quot;ACCEPT_EULA=Y&quot;</code> 将 ACCEPT_EULA 变量设置为任意值，以确认接受最终用户许可协议。</p>
</li>
<li>
<p><code>-e &quot;SA_PASSWORD=Passw0rd&quot;</code> 指定至少包含 8 个字符且符合 SQL Server 密码要求的强密码。</p>
</li>
<li>
<p><code>-p 1433:1433</code> 将主机环境中的 TCP 端口（第一个值）映射到容器中的 TCP 端口（第二个值）。</p>
</li>
<li>
<p><code>--rm</code> 退出容器以后，这个容器就被删除了，方便在临时测试使用。</p>
</li>
<li>
<p><code>--name sqlserver</code> 为容器指定一个自定义名称，而不是使用随机生成的名称。</p>
</li>
</ul>
<p>关于 SQL Server 镜像的更多信息，请查阅 <a href="https://mcr.microsoft.com/en-us/product/mssql/server/about">Microsoft SQL Server - Ubuntu based images | Microsoft Artifact Registry - https://mcr.microsoft.com/en-us/product/mssql/server/about</a></p>
<h3 id="查看容器运行状况">查看容器运行状况</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -e | grep sqlserver</span><br></pre></td></tr></table></figure>
<p>可以通过执行 <code>docker logs</code> 命令检查 SQL Server 运行日志。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs sqlserver</span><br></pre></td></tr></table></figure>
<h2 id="使用">使用</h2>
<h3 id="在容器内连接-SQL-Server">在容器内连接 SQL Server</h3>
<ul>
<li>
<p>使用 <code>docker exec -it</code> 命令在运行的容器内部启动交互式 `Bash Shell:</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it sqlserver bash</span><br></pre></td></tr></table></figure>
<p>sqlserver 是在创建容器时由 <code>-–name</code> 参数指定的名称。</p>
</li>
<li>
<p>在容器内部使用 <code>sqlcmd</code> 进行本地连接。 默认情况下，<code>sqlcmd</code> 不在路径之中，因此需要指定完整路径。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P &quot;Passw0rd&quot;</span><br><span class="line"><span class="meta prompt_">1&gt; </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果成功，应会显示 sqlcmd 命令提示符 <code>1&gt;</code>。</p>
</li>
</ul>
<h3 id="利用-DBeaver-等可视化工具连接-SQL-Server">利用 DBeaver 等可视化工具连接 SQL Server</h3>
<p>在 macOS 上如何安装 DBeaver 请看官方文档 <a href="https://dbeaver.io/download/">Download | DBeaver Community - https://dbeaver.io/download/</a>。</p>
<p>也可以通过 <code>brew</code> 包管理器来安装 DBeaver。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install --cask dbeaver-community</span><br></pre></td></tr></table></figure>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://docs.docker.com/desktop/install/mac-install/">Install on Mac | Docker Documentation - https://docs.docker.com/desktop/install/mac-install/</a></p>
<p>[2] <a href="https://mcr.microsoft.com/en-us/product/mssql/server/about">Microsoft SQL Server - Ubuntu based images | Microsoft Artifact Registry - https://mcr.microsoft.com/en-us/product/mssql/server/about</a></p>
<p>[3] <a href="https://www.microsoft.com/en-us/sql-server/sql-server-2017">SQL Server 2017 on Windows and Linux | Microsoft - https://www.microsoft.com/en-us/sql-server/sql-server-2017</a></p>
<p>[4] <a href="https://www.microsoft.com/en-us/sql-server/">Microsoft Data Platform | Microsoft - https://www.microsoft.com/en-us/sql-server/</a></p>
<p>[5] <a href="https://formulae.brew.sh/cask/docker">docker — Homebrew Formulae - https://formulae.brew.sh/cask/docker</a></p>
<p>[6] <a href="https://formulae.brew.sh/cask/dbeaver-community">dbeaver-community — Homebrew Formulae - https://formulae.brew.sh/cask/dbeaver-community</a></p>
<p>[7] <a href="https://dbeaver.io/download/">Download | DBeaver Community - https://dbeaver.io/download/</a></p>
<p>[8] <a href="https://dbeaver.io/">DBeaver Community | Free Universal Database Tool - https://dbeaver.io/</a></p>
<p>[9] <a href="https://brew.sh/">The Missing Package Manager for macOS (or Linux) — Homebrew - https://brew.sh/</a></p>
<p>[10] <a href="https://ganzhixiong.com/p/9d314fb4/">如何在macOS上安装SQL Server ? - 干志雄的博客 - https://ganzhixiong.com/p/9d314fb4/</a></p>
]]></content>
      <categories>
        <category>SQL Server</category>
        <category>macOS</category>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>Apple</tag>
        <tag>brew</tag>
        <tag>Homebrew</tag>
        <tag>Homebrew (brew)</tag>
        <tag>DBeaver</tag>
        <tag>Docker</tag>
        <tag>Linux</tag>
        <tag>Database</tag>
        <tag>Microsoft</tag>
        <tag>SQL Server</tag>
        <tag>Microsoft SQL Server</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>[ChatBot] ChatHub: 在一个应用程序中使用不同的 AI 聊天机器人</title>
    <url>/2023/03/23/Artificial-Intelligence-AI/ChatBot/chathub-all-in-one-chatbot-client/</url>
    <content><![CDATA[<h1>ChatHub: 在一个应用程序中使用不同的 AI 聊天机器人</h1>
<p>随着人工智能技术的不断发展，聊天机器人成为我们与机器交互的重要方式。ChatGPT是OpenAI开发的一个大型语言模型，目前正在许多聊天机器人中得到广泛应用。ChatHub是一个全能聊天机器人客户端，为您的聊天机器人提供更好的用户界面和更多的功能。支持同时与多个聊天机器人聊天，这使得您可以轻松比较它们的答案，以便找到最佳的答案。</p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ac5e9a88-334e-4039-90d2-beee101b2fef/ChatHub.png" alt="ChatHub.png"></p>
<h2 id="ChatHub的特点">ChatHub的特点:</h2>
<p>1.在一个应用程序中使用不同的聊天机器人，目前支持ChatGPT、新的Bing Chat、Google Bard，未来将支持更多。<br>
2.同时与多个聊天机器人聊天，易于比较它们的答案。<br>
3.支持ChatGPT API模式，比ChatGPT Plus更快、更具成本效益。<br>
4.支持GPT-4模型<br>
5.使用ChatGPT API模式时可以查看令牌使用统计信息。<br>
6.提示库<br>
7.在浏览器的任何位置快速激活应用程序的快捷方式。<br>
8.支持Markdown和代码高亮。</p>
<p>ChatHub的ChatGPT API模式比ChatGPT Plus更快、更具成本效益，同时在使用ChatGPT API模式时可以查看令牌使用统计信息，以便更好地控制使用。</p>
<p>ChatHub还支持GPT-4模型，这是OpenAI目前正在研究的下一代语言模型。这使得您可以在ChatHub上尝试使用更先进的模型。</p>
<p>提示库是ChatHub的另一个有用功能。这个库包含一系列常见的问题和回答，您可以直接使用这些回答，而无需手动输入每个问题的答案。</p>
<p>ChatHub还具有快捷键，可以在浏览器的任何位置快速激活应用程序，而且ChatHub还支持Markdown和代码高亮，这使得您可以更好地组织聊天内容和代码片段。</p>
<p>ChatHub在本地保存对话历史记录，这意味着您可以随时回顾以前的聊天记录，以便更好地了解过去的聊天历史。</p>
<p>ChatHub的安装非常简单，您可以从Chrome Web Store安装 [ChatHub - All-in-one chatbot client - Chrome 应用商店 - <a href="https://chrome.google.com/webstore/detail/chathub-all-in-one-chatbo/iaakpnchhognanibcahlpcplchdfmgma?hl=zh-CN">https://chrome.google.com/webstore/detail/chathub-all-in-one-chatbo/iaakpnchhognanibcahlpcplchdfmgma?hl=zh-CN</a>](<a href="https://chrome.google.com/webstore/detail/chathub-all-in-one-chatbo/iaakpnchhognanibcahlpcplchdfmgma?hl=zh-CN">https://chrome.google.com/webstore/detail/chathub-all-in-one-chatbo/iaakpnchhognanibcahlpcplchdfmgma?hl=zh-CN</a>)，或手动下载源代码，然后在Chrome或Edge浏览器中安装。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f941c14b-7847-4a66-b69c-eeaea07d40e6/extension.png" alt="extension.png"></p>
<p>如果您选择手动安装，只需下载chathub.zip文件并解压缩，然后在Chrome或Edge浏览器中打开扩展程序页面，启用开发者模式，将解压缩后的文件夹拖放到该页面的任何位置以导入它。之后，您就可以开始使用ChatHub了。</p>
<p>ChatHub的开发者还在不断改进这个应用程序，并计划添加更多的功能。他们的路线图包括保存对话历史记录、将对话导出为PDF或图像、暗黑模式等。如果您想了解更多关于ChatHub的最新信息，可以查看他们的GitHub页面或关注他们的社交媒体账号。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [ChatHub - All-in-one chatbot client - Chrome 应用商店 - <a href="https://chrome.google.com/webstore/detail/chathub-all-in-one-chatbo/iaakpnchhognanibcahlpcplchdfmgma?hl=zh-CN">https://chrome.google.com/webstore/detail/chathub-all-in-one-chatbo/iaakpnchhognanibcahlpcplchdfmgma?hl=zh-CN</a>](<a href="https://chrome.google.com/webstore/detail/chathub-all-in-one-chatbo/iaakpnchhognanibcahlpcplchdfmgma?hl=zh-CN">https://chrome.google.com/webstore/detail/chathub-all-in-one-chatbo/iaakpnchhognanibcahlpcplchdfmgma?hl=zh-CN</a>)</p>
<p>[2] [chathub-dev/chathub: All-in-one chatbot client - **<a href="https://github.com/chathub-dev/chathub">https://github.com/chathub-dev/chathub</a>](<a href="https://github.com/chathub-dev/chathub">https://github.com/chathub-dev/chathub</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>ChatBot</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>ChatHub</tag>
        <tag>Bing</tag>
        <tag>Bard</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>ChatBot</tag>
      </tags>
  </entry>
  <entry>
    <title>[ChatGPT] 使用RTF三要素法则构建强大的ChatGPT提示(Prompt)</title>
    <url>/2023/07/24/Artificial-Intelligence-AI/ChatGPT/building-powerful-chatgpt-prompts-using-the-rtf-three-element-rule/</url>
    <content><![CDATA[<h1>使用RTF三要素法则构建强大的ChatGPT提示(Prompt)</h1>
<p>在探索ChatGPT的广阔世界时，你可能会发现，有效地与这款人工智能工具交流并不总是那么直观。但不用担心，我在这里要分享一个我经过大量时间的试验和研究后发现的技巧——RTF框架。这个框架将帮助你更好地利用ChatGPT，让它为你做更多的事情。</p>
<p>RTF代表的是三个关键词：角色（Role）、任务（Task）和格式（Format）。这是一个三部曲，你可以将其看作是与AI沟通的“魔法咒语”。</p>
<span id="more"></span>
<p>首先，我们来看看“角色”。想象一下，你可以将ChatGPT变成任何你需要的专家，无论是厨师、科学家还是作家。你只需要明确告诉它你希望它扮演的角色，它就会从这个角色的视角来理解和回答你的问题。</p>
<p>接下来是“任务”。这是你希望AI为你完成的事情。可能是研究一项新技术，也可能是编写一篇短篇故事，或者是帮你规划一天的行程。只需要告诉AI你需要什么，它就会努力去完成。</p>
<p>最后，我们来看看“格式”。这是你希望AI以何种方式呈现它的回答。你可能希望得到一个详细的列表，或者是一个精美的表格，甚至是一个生动的故事。只要你明确告诉AI你的需求，它就会按照你的要求来呈现结果。但是，如果你想要PDF、图片或代码格式的回答，你需要使用ChatGPT插件。</p>
<p>现在，让我们把这三个部分组合起来。比如你可以告诉AI：“我需要你作为一名厨师，为我制作一份食谱，并以列表的形式呈现。”这样，AI就会以厨师的身份，为你提供一份详细的烹饪步骤列表。</p>
<p>这只是一个例子，实际上，你可以根据需要，随意组合各种角色、任务和格式。这是打开AI无限可能的钥匙，让你能够充分利用ChatGPT的强大功能。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://chat.openai.com/">ChatGPT - https://chat.openai.com/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>ChatGPT</category>
        <category>Prompt Engineering</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Large Language Model (LLM)</tag>
        <tag>OpenAI</tag>
        <tag>ChatGPT</tag>
        <tag>Prompt Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>[ChatGPT] ChatGPT推出网络浏览和插件功能的公测版</title>
    <url>/2023/05/15/Artificial-Intelligence-AI/ChatGPT/chatgpt-rollout-web-browsing-and-plugins-in-beta/</url>
    <content><![CDATA[<h1>ChatGPT推出网络浏览和插件功能的公测版</h1>
<p>近日,AI模型系统ChatGPT推出网络浏览和插件功能的公测版,为付费用户提供早期体验机会。此举意在不断提高ChatGPT的应用价值,为用户带来更多便利。ChatGPT Plus用户在本周内将陆续通过设置中的新版“beta面板”启用这两大新功能。</p>
<span id="more"></span>
<p>首先是网络浏览功能,它让ChatGPT能更好地理解最近的热点话题和实时事件,从而更准确地回答用户的相关提问。</p>
<p>其次是插件功能,ChatGPT将能够调用用户启用的第三方插件,实现更丰富的交互体验。要使用第三方插件,</p>
<p>用户需要: 登录 chat.openai.com网站→在模型切换器中选择“插件”→在“插件”下拉菜单中点击“插件商店”安装和启用新的插件。</p>
<p>要启用公测版功能,用户需要:点击“个人资料和设置”→选择“Beta功能”→切换想要体验的功能。</p>
<p>ChatGPT一直致力于不断提高用户体验,本次网络浏览和插件功能的推出正是该方针的产物。网络浏览功能让ChatGPT拥有更强的时效性和实用性,能更准确地回答热点话题相关的提问。插件功能的引入则大大拓宽了ChatGPT的应用场景,用户可以选择并安装更个性化的第三方插件,实现定制化的人机交互。相信随着这两大新功能的不断完善,ChatGPT将为用户带来更流畅和全面地交互体验。</p>
<p><img src="https://downloads.intercomcdn.com/i/o/740734818/c7d818c221f5f023ab1a0c27/BetaPanel.png" alt="https://downloads.intercomcdn.com/i/o/740734818/c7d818c221f5f023ab1a0c27/BetaPanel.png"></p>
<p>OpenAI也表示会持续关注新功能的使用情况,不断改进和更新,为用户提供更稳定高效的服务。总的来说,网络浏览和插件功能的推出,将ChatGPT的应用潜力进一步激发,这无疑是人工智能领域一个令人振奋的进步。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [Web browsing and Plugins are now rolling out in beta (May 12) - <a href="https://help.openai.com/en/articles/6825453-chatgpt-release-notes">https://help.openai.com/en/articles/6825453-chatgpt-release-notes</a>](<a href="https://help.openai.com/en/articles/6825453-chatgpt-release-notes">https://help.openai.com/en/articles/6825453-chatgpt-release-notes</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>ChatGPT</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>OpenAI</tag>
        <tag>ChatGPT</tag>
        <tag>ChatGPT Plus</tag>
      </tags>
  </entry>
  <entry>
    <title>[3D] AI科技行业的新秀：堆友3D资源平台</title>
    <url>/2023/06/16/Artificial-Intelligence-AI/D-Design/a-rising-star-in-ai-technology-industry-duoyou-3d-resource-platform/</url>
    <content><![CDATA[<h1>AI科技行业的新秀：堆友3D资源平台</h1>
<p>平时在文章中插入各种图像来美化布局和增强文章的视觉效果。但是自己制作3D素材又十分耗时,而在网络上搜索3D素材常常会遇到版权问题,这使得创作过程变得困难重重。</p>
<p>最近,阿里巴巴的设计团队推出了一款名为“堆友”的3D资源平台,提供海量免费商用的3D素材,解决了这些创作者在寻找3D素材时常遇到的难题。</p>
<p><a href="https://d.design/">https://d.design/</a></p>
<span id="more"></span>
<p>堆友3D资源平台由阿里巴巴官方设计团队开发,平台上所有的3D素材全部由阿里巴巴的设计师原创,用户可以免费用于商业用途,无需担心版权问题。堆友3D资源平台首期提供3D头像、3D场景和3D元素等素材,拥有近百个场景和上千个3D元素,可供用户在不同的应用场景中选择使用。</p>
<h2 id="3D-头像">3D 头像</h2>
<p>在堆友3D资源平台的“堆头像”板块中,用户可以选择不同的表情、发型、眉毛、眼睛、衣服和配饰等来创建自己的3D头像,平台提供12种头像肤色供选择。所有的编辑操作都可以在线完成,用户无需担心光照等问题,操作简单方便。仅现有的元素就可以组合出超过4千万种不同的头像,即便用户不会使用3D设计软件,也能轻松创建属于自己的3D头像。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b159e350-e9a5-4bc9-9ae6-afae615f99ac/Untitled.png" alt="Untitled"></p>
<h2 id="3D-场景">3D 场景</h2>
<p>在“堆场景”板块中,用户可以选择近百个现成的3D场景模板,并从3D元素中选择需要的素材添加到场景中,所有添加的素材同样支持在线编辑。场景板块提供节日营销、休闲娱乐、物流交通和办公家具等近百种不同的3D场景供用户选择。用户可以调整场景中每一个元素的位置、大小、旋转角度,甚至可以单独调整人物模型。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2f3eb2db-8616-4375-988a-f359ed24e912/Untitled.png" alt="Untitled"></p>
<p>总的来说,堆友3D资源平台为创作者提供了海量高质量的3D素材,其操作简单方便,支持在线实时编辑和渲染,解决了创作者在寻找3D素材时常遇到的困难,是AI科技行业的一大新秀,值得创作者们关注。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://d.design/">堆友—3D在线编辑器，0门槛堆出无限创意，免费下载，免费使用 - https://d.design/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>3D</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title>[Dify] Dify: AI新时代的开发和运营平台</title>
    <url>/2023/05/15/Artificial-Intelligence-AI/Dify/dify-an-ai-development-and-operations-platform-for-the-new-era/</url>
    <content><![CDATA[<h1>Dify: AI新时代的开发和运营平台</h1>
<p>Dify是一个免费的LLMOps平台,它允许任何人,包括没有编程基础的用户,快速开发和运营自己的AI chatbot应用。Dify的核心不在于应用数量,而是在于0基础上手,完全无代码,上传自己数据集,数据可视化,并可对外提供API。</p>
<span id="more"></span>
<p>Dify - 易用的 LLMOps 平台，定义你的 AI 原生应用 <a href="https://dify.ai/zh">https://dify.ai/zh</a></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e087759e-0d74-4726-85f2-2db011f09c72/Untitled.png" alt="Untitled"></p>
<p>Dify的体验非常简单和无障碍。它内置各种模型和数据,您可以通过可视化界面无代码交互即刻创建应用。无论您的团队打算内部使用还是面向外部发布,Dify都能在5分钟内完成部署。它支持的应用类型包括:对话系统、文本生成器和代码转换器等。</p>
<p>例如,您可以创建一个像&quot;Storyteller Bot&quot;的对话应用,它可以基于公司文档和网页内容回答特定问题。或者,您可以创建一个像&quot;SQL Generator&quot; 的应用,它能够将自然语言查询转换为SQL语句。Dify提供开源Web应用程序模板,支持GPT家族和Claude等多种语言模型。</p>
<p>Dify的强大之处在于,它为AI模型提供了强大的上下文嵌入功能。无论您的数据来源是文档、网页还是Notion等内容,Dify都能自动完成数据预处理、向量化和分段,您无需再学习嵌入技术,这可以为您节省数周的开发时间。</p>
<p>除此之外,Dify与ChatGPT插件标准完全兼容,这意味着您可以轻松为AI应用添加各种功能,如搜索、连接数据库、敏感词过滤等,或者调用任何API。Dify让开发人员能够真正地开箱即用,专注于应用本身,而不是底层技术。</p>
<p>总之,Dify是一个简单易用且功能强大的平台,它让任何人都能开发和运营自己的AI原生应用。我强烈推荐每个人,特别是没有代码基础的用户尝试Dify来搭建属于自己的chatbot。让我们一起迎接AI的新时代!</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [Dify - 易用的 LLMOps 平台，定义你的 AI 原生应用 - <a href="https://dify.ai/zh">https://dify.ai/zh</a>](<a href="https://dify.ai/zh">https://dify.ai/zh</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Dify</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Dify</tag>
      </tags>
  </entry>
  <entry>
    <title>[Framer] Framer:快速构建您的梦想网站</title>
    <url>/2023/06/15/Artificial-Intelligence-AI/Framer/framer-quickly-build-your-dream-website/</url>
    <content><![CDATA[<h1>Framer:快速构建您的梦想网站</h1>
<p>Framer 是一款网站设计工具,致力于简化网站设计和发布流程。它将网站设计、开发和托管综合在一个平台,使用最先进的AI技术为用户生成网站初始版本。用户只需在此基础上进行定制,就可以发布高质量的响应式网站,无需编写一行代码。</p>
<p><a href="https://www.framer.com/">https://www.framer.com/</a></p>
<span id="more"></span>
<p>Framer 的诸多功能使其成为设计师和开发人员的不二之选:</p>
<h2 id="AI生成">AI生成</h2>
<p>Framer 使用人工智能为用户快速生成网站初版,包含结构、内容等。用户只需输入网站主题或示例,AI就可以生成符合要求的网站框架。这极大简化了网站设计的流程,让用户专注于网站定制和个性化。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dcfb62da-1d4c-4778-b82a-6fd07bd67114/Untitled.png" alt="Untitled"></p>
<h2 id="直观操作">直观操作</h2>
<p>Framer 为用户提供拖拽式操作界面,所有元素均可通过鼠标进行移动、调整大小等操作。这种所见即所得的方式简化了网站设计学习曲线,适合各类人群。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5dec1ad3-560f-41a9-b18e-ff7432698006/Untitled.png" alt="Untitled"></p>
<h2 id="实时预览">实时预览</h2>
<p>在 Framer 中进行的所有操作均可实时反映在网页中,使得设计师能在观看实际网页视图的同时进行调整。这种交互式的设计体验极大提高了工作效率。</p>
<h2 id="高度定制">高度定制</h2>
<p>Framer 为用户提供多种工具进行网站高度定制,包括添加动画、将设计导入自Figma、选择网站导航方式等。这使得每个网站看起来独一无二。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c7283ba9-0512-403b-a085-4d9e6cbb1d37/Untitled.png" alt="Untitled"></p>
<h2 id="直接发布">直接发布</h2>
<p>完成网站设计后,用户只需一键发布,即可将网站推送到 Framer 的托管服务上,供全球访问。整个过程无需任何代码,是多数网站建设工具目前难以达到的。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d9412b57-c4af-41b0-9b8d-8a25c5b7d4dc/Untitled.png" alt="Untitled"></p>
<h2 id="社区支持">社区支持</h2>
<p>Framer 拥有庞大的社区用户群以及详尽的在线教程和文档,可以为用户遇到的各类疑难提供帮助。</p>
<p>Framer 致力于让网站设计和发布尽可能简单,其独特的产品定位和强大的功能受到广大用户的青睐。相信随着AI技术的持续进步,Framer 会不断增强自身能力,为更多网站建设者提供卓越体验。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://www.framer.com/">Framer — Start your dream site with AI. Zero code, maximum speed. - https://www.framer.com/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Dify</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Framer</tag>
      </tags>
  </entry>
  <entry>
    <title>[GPT-4] GPT-4 如期而至</title>
    <url>/2023/03/15/Artificial-Intelligence-AI/GPT-4/gpt-4-arrives-as-scheduled/</url>
    <content><![CDATA[<h1>GPT-4 如期而至</h1>
<p>3 月 15 日最大的新闻是 GPT-4 发布。有人戏称 GPT-4 发布的的消息，朋友圈里比 OpenAI 的广告来的更早。导致今年 3 月 15 日消费者的新闻报道在朋友圈里几乎没什么动静。</p>
<p>GPT-4 是一个多模态的大语言模型(MLLM)，可以接受文字和图片输入，并且输出文字。现在只开放了文字输入的功能，图片输入功能还在加紧开发中。</p>
<span id="more"></span>
<h2 id="评论">评论</h2>
<p>我们感觉 GPT-4 比预期的要弱。我们原本期望的这个图</p>
<p><img src="GPT-4%20%E5%A6%82%E6%9C%9F%E8%80%8C%E8%87%B3%209b5c16f3b88049228ea9aa9c5a1b111a/GPT-4_expected.jpeg" alt="GPT-4 expected.jpeg"></p>
<p>结果发布会后热传的是这个图</p>
<p><img src="GPT-4%20%E5%A6%82%E6%9C%9F%E8%80%8C%E8%87%B3%209b5c16f3b88049228ea9aa9c5a1b111a/GPT-4.jpeg" alt="GPT-4.jpeg"></p>
<p>不过 GPT-4 **支持图像理解，对复杂任务更好的理解，更长的上下文，更加安全可控等等的改进的确不错。**虽然在某些情况下它不如人类，但在各种专业和学术考试中表现出了与人类水平相当的性能。</p>
<p>另外<strong>我们觉得有</strong>一些值得关注的点：</p>
<ol>
<li>MLLM：继续改变和降低使用门槛，增强学习、理解和推理能力，同时扩大更多应用场景。（偏进攻性）</li>
<li>标准：开放 LLM 的测试 OpenAI Evals 和可扩展性验证标准，任何人都可以提交他们模型的缺陷以帮助改进。一流企业通过制定标准，确立技术壁垒，给后续市场竞争者设立进入门槛（偏防御性）</li>
<li>封闭：没有马上对公众开放使用，允许 ChatGPT Plus 用户受限访问（4 小时内 50 次提问），提供 Waitlist 排队申请机制，选择性挑选关键的合作伙伴，开始构建越发封闭的生态系统。（偏防御性）</li>
</ol>
<h2 id="使用">使用</h2>
<p>如何使用GPT-4？有以下几种推荐方式：</p>
<ol>
<li>购买个 ChatGPT Plus 会员，一个月 $20 ，可以有限度的使用，4个小时内不超过50条信息</li>
<li>点击加入 Waitlist，这个是用来获取API的访问权 GPT-4 API [<a href="https://openai.com/waitlist/gpt-4-api">https://openai.com/waitlist/gpt-4-api</a>](<a href="https://openai.com/waitlist/gpt-4-api">https://openai.com/waitlist/gpt-4-api</a></li>
<li>参与 OpenAI Evals 项目，如提供高质量贡献的，审核通过后会给予 GPT-4 的访问权。[<a href="https://github.com/openai/evals">https://github.com/openai/evals</a>](<a href="https://github.com/openai/evals">https://github.com/openai/evals</a>)</li>
</ol>
<h2 id="影响">影响</h2>
<p>ChatGPT 和 GPT-4 的出现，颠覆了我们以往对 AI 替代的人类职位的顺序。我们原本以为 AI 首先会替代简单重复体力劳动者，最后才是替代知识类或创意类的劳动者。现在越来越多的人意识到 AI 已经可以替代知识类或创意类的劳动者的部分甚至大部分的工作。这也说明我们对自己大脑运用知识和提出创意原理不甚了解，以及对 AI 特别是神经网络深度学习的本质规律了解不够深入。</p>
<p>长期依赖，知识类或创意类的劳动者需要经过长期的教育和学习，才能掌握相关的技能，运用知识和经验解决问题。</p>
<p>现在 ChatGPT 和 GPT-4 在一般常识和普遍学科上已经达到大学生的知识水平，在翻译、创作等领域已经达到甚至超越专家的水平。没有经验得新手通过使用 ChatGPT 和 GPT-4，很有可能一下子具备了以前需要花很多年才能学会的知识和经验，对技能和效率的提升，是一个巨大的颠覆和降维打击。</p>
<p>如果我们能够熟练运用 AI 工具提出问题，分析问题和解决问题，可以快速提高或改善我们能力下限，更重要的是，很有可能突破我们的能力上限。</p>
<p>现在已经不再是纠结 AI 要取代哪些岗位的时候，我们需要重新认真考虑 AI 和人类关系，以及如何在 AI 时代如何寻找就业机会和职业发展。</p>
<p>我们应该尽快学会如何与 AI 共处</p>
<ol>
<li>首先要熟悉使用各类 AI 工具，将它们集成和融合到我们日常工作和生活中；</li>
<li>然后学会如何与 AI 进行交流，提出好问题，如何做出正确的决策；</li>
<li>学会如何与 AI 跟好相处，相互学习，甚至相互进化；</li>
</ol>
<p>面对时代和技术的巨大变化，我们不能因为害怕，就坐以待毙或者拒之门外，我们应该要以更积极乐观心态的去学习和运用，顺应时代发展潮流。</p>
<p>即使 ChatGPT, GPT-4 没有取代我们，但是会有掌握 AI 的其他人会取代我们。作为知识劳动者，唯有不停的学习，才能与时共进。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://openai.com/research/gpt-4">GPT-4 - https://openai.com/research/gpt-4</a></p>
<p>[2] <a href="https://openai.com/waitlist/gpt-4-api">GPT-4 API waitlist - https://openai.com/waitlist/gpt-4-api</a></p>
<p>[3] <a href="https://github.com/openai/evals">openai/evals: Evals is a framework for evaluating OpenAI models and an open-source registry of benchmarks. - https://github.com/openai/evals</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>GPT-4</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>Large Language Model (LLM)</tag>
        <tag>OpenAI</tag>
        <tag>Multi-Modal Language Model (MLLM)</tag>
        <tag>GPT-4</tag>
      </tags>
  </entry>
  <entry>
    <title>[Google Bard] 谷歌Bard AI聊天机器人强势升级,支持中文等40种语言助力全球用户创作</title>
    <url>/2023/07/13/Artificial-Intelligence-AI/Google-Bard/google&#39;s-latest-ai-chatbot-bard-receives-major-upgrades,-supports-40-languages-including-chinese-to-empower-global-users&#39;-creativity/</url>
    <content><![CDATA[<h1>谷歌Bard AI聊天机器人强势升级,支持中文等40种语言助力全球用户创作</h1>
<p>谷歌最新推出的AI聊天机器人Bard，今天进行了重大升级,大幅扩充了其语言支持范围,新增特性也让Bard在辅助创作等方面成为更强大的助手。这表明谷歌正在加速拓展Bard的全球化布局,与用户建立更友好的交互,以提升Bard助力人类创造力的能力。</p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/245e6f95-0a3f-4c99-9ca8-b67afac8134a/Untitled.png" alt="Untitled"></p>
<p>此次升级中,Bard新加入了40多种语言支持,包括简体中文、繁体中文在内的阿拉伯语、德语、西班牙语等,覆盖全球主流语言。这不仅使更多非英语国家的用户得以无障碍使用Bard,也有助于Bard针对不同语言环境优化对话流畅度和语义理解能力。初步体验发现,尽管相较竞品,中文环境下Bard的交互仍有进步空间,但已经能够进行基本的问答对话。</p>
<p>除扩充语言外,新版Bard还新增了多项辅助创作的功能。例如支持上传图片进行视觉理解,用户可以获得更丰富的回复;实现了语音合成,用户可以选择聆听Bard的回答,获得多模态的交互体验;支持固定和整理之前的对话、与他人分享对话等,都可以帮助用户更顺畅地组织创作思路。这些新特性为Bard提供了更人性化、更智能的交互方式。</p>
<p>凭借对多语言环境的支持,以及不断强化的创作载体,可见谷歌正致力于将Bard打造成一个涵盖全球、帮助普罗大众激发创造力的AI助手。我们有理由相信,在持续进化中,Bard必将成为推动人类社会进步的重要工具之一。当然,保障对话安全和可控也是关键所在,我们期待Bard在发挥潜力的同时,也能对社会产生积极正面的影响。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://bard.google.com/">Bard - https://bard.google.com/</a></p>
<p>[2] <a href="https://bard.google.com/updates">‎What’s new with Bard - https://bard.google.com/updates</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Google</category>
        <category>Google Bard</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Google Bard</tag>
        <tag>Chinese</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>[StyleDrop] AI艺术家StyleDrop,图像生成的新规则</title>
    <url>/2023/06/05/Artificial-Intelligence-AI/Google-Research/ai-artist-styledrop-new-rules-of-image-generation/</url>
    <content><![CDATA[<h1>AI艺术家StyleDrop,图像生成的新规则</h1>
<p>StyleDrop是谷歌研究团队最新设计的一款图像生成AI系统,它可以通过学习一张参考图像的视觉样式,自动生成大量在风格上高度贴近参考图像的新作品。这种根据参考图像“定制”全新图像的能力,让StyleDrop成为图像生成领域的一项“现象级”成果。</p>
<span id="more"></span>
<p>StyleDrop: Text-to-Image Generation in Any Style - <a href="https://styledrop.github.io/">https://styledrop.github.io/</a></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7edb95b6-636c-4748-86e4-7500bbbae9cf/Untitled.png" alt="StyleDrop"></p>
<p>StyleDrop的工作原理类似于画图软件中的“Eyedropper”工具,可以从一小块参考图像中提取复杂的视觉特征和风格,并将这种风格迁移到全新的图像创作中。通过这种方式,StyleDrop不仅可以让人更加便利地创作定制化的图像,它甚至可以完成那些过去艰难实现的任务,例如设计logo等需要高度精细控制的作品。</p>
<p>举例来说,如果StyleDrop获得梵高的《星空》作为参考图像,它可以生成大量类似梵高风格的画作;如果获得一张卡通风格的图像作为输入,StyleDrop同样可以创作出大量萌萌哒的卡通风格图片。这种根据单一参考图像进行复杂视觉样式“定制”的能力,令StyleDrop的表现令人兴奋。无论输入图像的艺术风格多么复杂,StyleDrop都可以轻易解构它并在全新的创作中准确复刻这种风格。</p>
<p>由谷歌研究团队开发的StyleDrop无疑将图像生成的能力提升到一个全新的高度。StyleDrop不仅可以更容易地创作定制化和个性化的图像,它甚至可以完成以往难以实现的精细设计工作,这使它成为一种颠覆型的创意工具。StyleDrop的出现,让人们在思考图像创作的未来时,不得不考虑人工智能技术所带来的深远影响。AI系统不再只是执行重复性工作,而是在创意领域发挥着日益重要的作用,这可能会对创意产业带来革命性的改变。</p>
<p>总之,StyleDrop是一个令人惊叹的图像生成AI系统,它彻底改变了我们对机器创意的看法,让人们不禁思考,人工智能是否真的会取代创意工作者,并在创意产业颠覆游戏规则。StyleDrop代表了AI在艺术创作领域的最新进展,它可能成为推动未来创意变革的一股重要力量。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://styledrop.github.io/">StyleDrop: Text-to-Image Generation in Any Style - https://styledrop.github.io/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Google Research</category>
        <category>StyleDrop</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Google Research</tag>
        <tag>StyleDrop</tag>
      </tags>
  </entry>
  <entry>
    <title>[HeadshotPro] HeadshotPro人工智能头像生成引发热议:技术创新还是伦理困境</title>
    <url>/2023/07/23/Artificial-Intelligence-AI/HeadshotPro/headshotpros-ai-generated-headshots-cause-debate-technological-innovation-or-ethical-dilemma/</url>
    <content><![CDATA[<h1>HeadshotPro人工智能头像生成引发热议:技术创新还是伦理困境</h1>
<p>近日,一家名为Acme Corp的初创公司推出了HeadshotPro人工智能头像生成服务,用户只需上传几张自拍照,就可以获得逼真的商业头像。这一创新技术立即在互联网上引发了广泛讨论。</p>
<p><a href="https://www.headshotpro.com/">https://www.headshotpro.com/</a></p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2a98336e-3251-4a2f-b01b-5a83f24f917f/Untitled.png" alt="Untitled"></p>
<p>该公司声称通过算法分析人脸特征,可生成数百种不同风格的高清头像。用户可根据个人喜好选择背景和服饰,还可一键生成符合企业品牌要求的统一团队头像。仅须2小时,即可完成整个头像生成,十分方便快捷。</p>
<p>但也有观点认为,该技术或将导致严重的伦理风险。一些专家指出,AI生成的“假人像”很容易在网上传播散布,被他人滥用。一旦生成技术被用来制作深度假新闻、政治宣传等,将严重损害公众利益。</p>
<p>业内人士指出,虽然当前AI生成图像已达到极高的逼真程度,但仍可通过细微缺陷识别。未来识别技术的进一步提升,或可大幅降低深度假图像的危害。此外,完善数据隐私保护法规,也是应对新技术带来风险的重要手段。</p>
<p>不过,也有观点认为这一技术本身并无伦理问题,关键在于如何正当使用。事实上,它为许多中小企业提供了低成本建立品牌形象的途径。对于远程工作者来说,也无需进行实际拍摄,就可以获得专业头像。如果用好用对,反而可带来积极影响。</p>
<p>无论如何,这一人工智能应用的出现无疑标志着图像生成技术已经步入成熟阶段。其所带来的影响也值得社会各界进一步关注和讨论。只有科技创新与伦理规范并重,人工智能头像生成才能真正造福社会。业内专家呼吁,开发者要充分考虑技术的社会影响,与监管部门和公众保持沟通;监管机构也应及时出台数据使用规范,保障公共利益。</p>
<p>展望未来,人工智能将以我们无法预见的速度改变世界,技术创新与伦理规范的关系也将成为持续探讨的难题。但只要社会各界共同努力,就一定能在技术创新中找到伦理平衡点,让AI造福而非危害人类社会。</p>
<h2 id="参考链接">## 参考链接</h2>
<p>[1] <a href="https://www.headshotpro.com/">HeadshotPro: Professional Headshots with AI - https://www.headshotpro.com/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>HeadshotPro</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>HeadshotPro</tag>
      </tags>
  </entry>
  <entry>
    <title>[Hugging Face] HuggingChat 探索Hugging Face的人工智能崛起与展望</title>
    <url>/2023/05/05/Artificial-Intelligence-AI/Hugging-Face/the-power-of-open-source-ai-rising-star-exploring-the-rise-and-future-of-hugging-face/</url>
    <content><![CDATA[<h1>HuggingChat 探索Hugging Face的人工智能崛起与展望</h1>
<p>Hugging Face的兴起源于其开发的聊天机器人,但真正让其名声大噪的还是其开源的机器学习平台。</p>
<span id="more"></span>
<p>2016年,Hugging Face创立时的主打产品是一款面向青少年的聊天机器人App,利用AI技术生成表情和笑话来娱乐用户。但是,该App并不成功,Hugging Face陷入了困境。为转局,Hugging Face的创始人决定开源他们开发聊天机器人的自然语言处理能力与机器学习模型,构建一个开源平台让开发者共享模型和数据集。</p>
<p>意外地,这个举措获得了广泛关注,Hugging Face迅速蹿红。如今,聊天机器人App已下架,但Hugging Face却已成为GitHub上增长最快的机器学习开源库,其Transformer库已有96,302个star和20,000多个fork。Hugging Face平台上当前共有166,894个机器学习模型和26,900个数据集可供开发者使用。</p>
<p>看Hugging Face的发展历程,这次推出HuggingChat可以说是“重操旧业”。HuggingChat使用Amazon AWS云服务,让人们与开源聊天机器人“Open Assistant”互动,这两个模型的语言系统都是基于拥有300亿参数的LLaMA模型。和Alpaca或Vicuna一样,这些模型进行了微调,不同于ChatGPT使用人类反馈的强化学习进行改进。</p>
<p>接下来,我们来实际体验一下HuggingChat。</p>
<p>[<a href="https://huggingface.co/chat/">https://huggingface.co/chat/</a>](<a href="https://huggingface.co/chat/">https://huggingface.co/chat/</a>)</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/99077ac2-0e4c-4879-99db-cabac779fd40/Untitled.png" alt="Untitled"></p>
<p>乍看之下,HuggingChat的界面与ChatGPT十分相似。左边是一个显示最新聊天记录的栏,浏览器窗口主要被当前聊天记录占据。目前,用户无需注册即可使用,但无法保存聊天记录。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/38bb2a5e-3983-457d-a335-e9f9bb210d9f/Untitled.png" alt="Untitled"></p>
<p>与ChatGPT一样,HuggingChat可以根据请求生成自然语言文本或特定格式的文本,甚至代码。而且,HuggingChat的响应速度很快。</p>
<p>但是,HuggingChat的中文水平不高,处理英文的能力要好于中文。  总体来说,HuggingChat与ChatGPT十分类似,都具有生成文本、代码的能力,并具有较快的响应速度。但是,HuggingChat的中文支持还需提高。而相比ChatGPT,HuggingChat的最大优势在于其开源的特性。任何人都可以利用Hugging Face提供的平台与资源进行模型微调和数据集构建,这为HuggingChat提供了更丰富的知识来源。未来,随着开源社区对HuggingChat的不断完善,其生成能力必将超过ChatGPT。  继Transformer库之后,Hugging Face再次以开源的形式推出聊天机器人HuggingChat,这充分体现了其“为开源而战”的发展方向与定位。依托开源社区的力量,Hugging Face正在构建人工智能领域的基础设施,其影响力必将随之不断扩大。与此同时,Hugging Face也在初步探索商业化道路,5000家企业客户更证明了Hugging Face的产品具有较高商业价值。  展望未来,Hugging Face或将在人工智能开源基础设施与产业应用间继续发挥职能,推动人工智能从实验室走向生产力。在开源动力的激励下,Hugging Face无疑将扮演重要角色,其发展前景值得期待。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [HuggingChat - <a href="https://huggingface.co/chat/">https://huggingface.co/chat/</a>](<a href="https://huggingface.co/chat/">https://huggingface.co/chat/</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Hugging Face</category>
        <category>HuggingChat</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Hugging Face</tag>
        <tag>HuggingChat</tag>
      </tags>
  </entry>
  <entry>
    <title>[Pi] Inflection AI推出Pi：您的私人AI伙伴</title>
    <url>/2023/05/04/Artificial-Intelligence-AI/Inflection-AI/inflection-ai-introduces-pi-your-personal-ai-companion/</url>
    <content><![CDATA[<h1>Inflection AI推出Pi：您的私人AI伙伴</h1>
<p>让我们认识一下Pi，您的私人AI。<strong><a href="https://heypi.com/">https://heypi.com/</a></strong> 作为一种全新类型的AI，Pi旨在成为一位善解人意、全力支持的伴侣，以自然流畅的方式提供对话、友好建议和简洁信息。与其他AI侧重于提高生产力、搜索或回答问题不同，Pi的体验旨在优先与人进行对话。Pi可以成为您的教练、知己、创意伙伴或倾听者。</p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/60d29c71-82ad-45f9-9730-58004dac31cf/Untitled.png" alt="Untitled"></p>
<p>Inflection AI今天宣布首次发布其个人AI产品Pi（<a href="http://heypi.com">heypi.com</a>）。作为一种全新类型的AI，Pi旨在成为一位善解人意、全力支持的伴侣，以自然流畅的方式提供对话、友好建议和简洁信息。</p>
<p>“我们希望通过Pi创建一款既灵活又强大的个人AI，让数百万人能够使用它，使他们的生活更加有意义、更加高效、更加有趣。”<br>
Pi的创建旨在为人们提供一种全新的自我表达方式，分享他们的好奇心，探索新想法，并体验值得信赖的个人AI。Pi基于公司内部开发的世界一流的专有AI技术构建。与其他AI侧重于提高生产力、搜索或回答问题不同，Pi的体验旨在优先与人进行对话。Pi可以成为您的教练、知己、创意伙伴或倾听者。</p>
<p>Inflection公司首席执行官兼联合创始人Mustafa Suleyman表示：“Pi是一种全新类型的AI，它不仅聪明，而且具有很高的情商。我们将Pi视为一位随时待命的数字伴侣，无论您想学习新知识、需要一个倾听者来应对一天中棘手的时刻，还是只是想与一个好奇而善良的对等者消磨时光。”</p>
<p>“我们还有很多东西需要学习，还有很长的路要走，但我们很高兴能够将Pi的第一个版本带给世界各地的人们。”</p>
<h2 id="Pi，您的“个人AI”的最佳特点">Pi，您的“个人AI”的最佳特点</h2>
<p>Pi代表“个人智能”，因为它可以根据个人的独特兴趣和需求提供无限知识。Pi可以成为您的老师、教练、知己、创意伙伴和倾听者。Pi的特点包括：</p>
<ul>
<li>善解人意且支持力强：Pi倾听并赋权，帮助您处理思考和情感，逐步解决棘手的决策，成为您的谈话伙伴；</li>
<li>好奇且谦逊：Pi渴望学习和适应，并以简单、自然的语言提供反馈，随着时间的推移为每个人提供改进；</li>
<li>富有创意且有趣：Pi富有趣味和幽默，容易发笑，并能迅速建立出奇不意的创意联系；</li>
<li>知识丰富但简洁：Pi将浏览转化为简单的对话；</li>
<li>完全属于您：Pi站在您这一边，支持您，并努力保护您；</li>
<li>处于开发阶段：Pi仍处于初期阶段，有时信息可能会出错。</li>
</ul>
<p>Suleyman继续说：“我们真的处于一个拐点。AI将成为我们一生中最具变革性的工具。我从事Pi的工作的动力在于，我们很快就能为全球数百万人提供智能且有帮助的个人AI。”</p>
<h2 id="Pi随时随地">Pi随时随地</h2>
<p>Pi目前可跨平台使用，并可随时随地与人们进行对话。Pi在发布时免费使用，可在以下平台上使用：</p>
<ul>
<li>Instagram：关注@heypi.ai并点击此处向Pi发送DM。</li>
<li>Facebook Messenger：点击此处与Pi取得联系。</li>
<li>WhatsApp和SMS：将+1 (314) 333-1111添加到您的联系人中以向Pi发送消息。</li>
<li>在线：在**<a href="https://heypi.xn--compi-wi1h68ai283a./">https://heypi.com与Pi交谈。</a>**</li>
<li>移动设备：下载Pi，您的个人AI适用于iPhone或iPad。Pi即将在Android上推出。</li>
</ul>
<h2 id="Pi的一切以安全为核心">Pi的一切以安全为核心</h2>
<p>Pi的开发中，安全是最重要的部分。人们有理由期望他们引入生活的技术应具有明确的边界，并且安全、可靠、可信赖。我们在Safety center中提供了更多关于我们政策的详细信息。</p>
<ul>
<li>我们利用最先进的技术方法、人类反馈和红队测试来确保Pi不从事有害或冒犯性行为。</li>
<li>我们正在创建一种新型的“边界训练”，将重新定义AI的学习和训练方式。</li>
<li>我们让用户轻松告诉我们Pi是否符合他们的期望——用户可以直接在我们的iPhone或iPad应用程序中标记不当信息。</li>
<li>我们采取严格的内部安全和隐私实践，以保护用户数据免受未经授权的访问和泄露。</li>
<li>我们努力减少幻觉现象。如今，Pi刚刚起步，它更加谨慎，宁愿说不知道也不愿意说错。</li>
</ul>
<p>Inflection AI的首席科学家兼联合创始人Karén Simonyan表示：“我们花费了过去一年的时间开发了世界上最先进、最复杂的大型语言模型之一，以实现Pi与人们进行简单自然互动的全新水平。凭借我们世界一流的科学家、开发人员和安全专家团队，我们将继续改进和扩展Pi的功能，以对人们的生活产生积极影响。”</p>
<p>Inflection的联合创始人Reid Hoffman表示：“通过Pi，我们希望建立一款既灵活又强大的个人AI，以便数百万人可以使用它，使他们的生活更加有意义、更加高效、更加有趣。”</p>
<h2 id="关于Inflection-AI">关于Inflection AI</h2>
<p>Inflection AI是一家位于加利福尼亚州帕洛阿尔托的“AI工作室”，专注于创建个人AI。它于2022年初由Mustafa Suleyman、Karén Simonyan和Reid Hoffman共同创立。</p>
<p>Inflection AI的使命是让每个人都能使用个人AI。该公司是一家公益公司，Inflection AI团队包括一些曾在DeepMind、Google、OpenAI和Meta工作的行业顶级AI专家。</p>
<p>有关Pi或Inflection的更多信息，请访问**<a href="https://heypi.xn--comhttps-1c2n//inflection.ai%E3%80%82%E5%9C%A8Instagram%E4%B8%8A%E5%85%B3%E6%B3%A8%E6%88%91%E4%BB%AC@heypi.ai%EF%BC%8C%E5%9C%A8Twitter%E4%B8%8A%E5%85%B3%E6%B3%A8%E6%88%91%E4%BB%AC@heypi_ai%E3%80%82">https://heypi.com和https://inflection.ai。在Instagram上关注我们@heypi.ai，在Twitter上关注我们@heypi_ai。</a>**</p>
<h2 id="总结">总结</h2>
<p>Inflection AI公司推出了一款名为Pi的个人AI产品，这款AI以自然流畅的方式提供对话、友好建议和简洁信息，旨在成为用户的教练、知己、创意伙伴和倾听者。与其他AI不同，Pi的核心体验是与人进行对话，而不仅仅是提高生产力或回答问题。Pi具有善解人意、好奇谦逊、富有创意、知识丰富等特点，并且强调安全性和用户隐私保护。Pi目前可在多个平台上免费使用，包括Instagram、Facebook Messenger、WhatsApp、SMS和在线网站。Inflection AI的使命是让每个人都能使用个人AI，并计划不断改进和扩展Pi的功能。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [Pi, your personal AI - <a href="https://heypi.com/talk">https://heypi.com/talk</a>](<a href="https://heypi.com/talk">https://heypi.com/talk</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Inflection AI</category>
        <category>Pi</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Inflection AI</tag>
        <tag>Pi</tag>
      </tags>
  </entry>
  <entry>
    <title>[Meta] Animated Drawings: 为绘画角色制作动画视频</title>
    <url>/2023/04/18/Artificial-Intelligence-AI/Meta/animated-drawings-creating-animated-videos-for-illustration-characters/</url>
    <content><![CDATA[<h1>Animated Drawings: 为绘画角色制作动画视频</h1>
<p>[Animated Drawings - <a href="https://sketch.metademolab.com/">https://sketch.metademolab.com/</a>](<a href="https://sketch.metademolab.com/">https://sketch.metademolab.com/</a>)是由 <strong><strong>META（前称Facebook） AI 研究 提供</strong></strong>一种有用的创意工具网站，使您能够灵活地创建以您自己绘制的角色为主角的动画。适合将儿童的绘画角色动画化，使角色可以四处移动。这个想法是将绘画角色栩栩如生，让孩子们更加投入其中。这可以是与孩子们一起进行的有趣活动，为他们提供了一个机会，让他们看到自己的艺术作品活起来。</p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ac418ed-9306-4090-b2eb-fcd2bc6c394e/WechatIMG133.png" alt="WechatIMG133.png"></p>
<h2 id="第一步：上传一张图纸">第一步：上传一张图纸</h2>
<p>可以无需上传图片，请随意尝试演示，点击以下示例图像之一。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1793f415-7f8e-4267-854f-9bb481975426/WechatIMG138.png" alt="WechatIMG138.png"></p>
<p>或者上传一个角色的绘画，其中手臂和腿不重叠身体（参见下面的示例）。</p>
<p>请确保将字符绘制在没有线条、褶皱或撕裂的白纸上。</p>
<p>确保图纸光线充足。为了最小化阴影，将相机远离图纸并对其进行缩放。</p>
<p>不要包含任何可识别的信息、冒犯性内容（请参阅我们的社区准则）或侵犯他人版权的图画。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/69800842-6b0f-4c12-b51f-2e5eed828b21/WechatIMG135.png" alt="WechatIMG135.png"></p>
<p>如果上传图片，需要通过点击“Upload Photo 上传”和“Next 下一步”，并将您的绘画上传到演示中，您同意 Agree（1）您至少年满18岁（或在您访问演示的司法管辖区内达到法定年龄），并（2）受《动画绘画补充服务条款》的约束。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b1bb64b-04c5-4dcb-93f5-e10e27c0a70b/WechatIMG148.png" alt="WechatIMG148.png"></p>
<p>点击 “Agree 同意“。</p>
<h2 id="第二步：找到角色">第二步：找到角色</h2>
<p>幸运的话，网站已经识别出了这个角色，并在它周围画了一个框。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c3670aec-1753-46ea-90c7-96d1c6c15140/WechatIMG139.png" alt="WechatIMG139.png"></p>
<p>如果网站没有正确识别出这个角色，可以调整框的大小以确保它紧密地适合一个角色。</p>
<p>点击 “Next 下一步“。</p>
<h2 id="第三步：-分离角色">第三步： 分离角色</h2>
<p>幸运的话，网站已经将角色与背景分离，并突出显示它。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/84a83c9e-5f5a-4236-a966-abec9b26e031/WechatIMG142.png" alt="WechatIMG142.png"></p>
<p>如果您的角色身体部位没有被突出显示，请使用笔和橡皮擦工具进行修复。</p>
<p>如果手臂或腿被粘在一起，使用橡皮擦工具将它们分开。</p>
<p>修复之后，点击 “Next 下一步”</p>
<h2 id="第四步：找到关节">第四步：找到关节</h2>
<p>这是你角色的关节！这是一个示例，它应该是这个样子：</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a6bd9777-1e3a-473c-bdf0-4cfd169e75c3/WechatIMG143.png" alt="WechatIMG143.png"></p>
<p>如果你的角色没有手臂，将肘部和手腕关节远离角色，仍然可以进行动画制作。</p>
<p>在下一步中，网站将使用分割掩模和这些关节位置来使用动作捕捉数据为您的角色添加动画。</p>
<h2 id="第五步：添加动画">第五步：添加动画</h2>
<p>选择以下动作之一，以查看您的角色执行它！</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/570b8924-7d4b-4835-86b6-bb55754a4964/WechatIMG149.png" alt="WechatIMG149.png"></p>
<p>点击 “Share 分享“可以下载 mp4 动画视频或者分享链接至 Facebook, Twitter 等社交网络。</p>
<p>以上操作将会生成动画视频。可点击链接访问[<a href="https://sketch.metademolab.com/share/2324211a766240a1b1f59ef0691720df/wave_hello_3">https://sketch.metademolab.com/share/2324211a766240a1b1f59ef0691720df/wave_hello_3</a>](<a href="https://sketch.metademolab.com/share/2324211a766240a1b1f59ef0691720df/wave_hello_3">https://sketch.metademolab.com/share/2324211a766240a1b1f59ef0691720df/wave_hello_3</a>)</p>
<h2 id="补充">补充</h2>
<p>Animated Drawings 是基于一种算法的实现，该算法在论文“一种用于动画化儿童人体图画的方法”中进行了描述（将出现在《计算机图形学交易》上，并将在2023年SIGGRAPH上展示）。</p>
<p>下图是结合人体特征动画文件格式 BVH，将角色跟随者人体动作进行绘画角色动画化的效果。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b34b5d61-7f93-43f1-8123-86a12d920c16/219223438-2c93f9cb-d4b5-45e9-a433-149ed76affa6.gif" alt="219223438-2c93f9cb-d4b5-45e9-a433-149ed76affa6.gif"></p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [Animated Drawings - <a href="https://sketch.metademolab.com/">https://sketch.metademolab.com/</a>](<a href="https://sketch.metademolab.com/">https://sketch.metademolab.com/</a>)</p>
<p>[2] [facebookresearch/AnimatedDrawings: Code to accompany &quot;A Method for Animating Children’s Drawings of the Human Figure” - <a href="https://github.com/facebookresearch/AnimatedDrawings">https://github.com/facebookresearch/AnimatedDrawings</a>](<a href="https://github.com/facebookresearch/AnimatedDrawings">https://github.com/facebookresearch/AnimatedDrawings</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Meta</category>
        <category>Animated Drawings</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Meta</tag>
        <tag>Animated Drawings</tag>
      </tags>
  </entry>
  <entry>
    <title>[Pixlr] Pixlr推出AI驱动的“去背”工具,一键自动抠图</title>
    <url>/2023/04/22/Artificial-Intelligence-AI/Pixlr/%20pixlr-launches-ai-powered-background-removal-tool-for-one-click-auto-cutout/</url>
    <content><![CDATA[<h1>Pixlr推出AI驱动的“去背”工具,一键自动抠图</h1>
<p>Pixlr是一款免费的图像编辑软件,被称为“Photoshop的在线版”。Pixlr不仅提供了功能强大的图像编辑工具,还运用AI技术开发了一系列智能化功能,其中最新推出的“Pixlr Remove Bg”工具利用AI实现一键自动抠图。</p>
<span id="more"></span>
<p>[删除背景：Pixlr.com免费图像背景删除 - <a href="https://pixlr.com/cn/remove-background/">https://pixlr.com/cn/remove-background/</a>](<a href="https://pixlr.com/cn/remove-background/">https://pixlr.com/cn/remove-background/</a>)</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4fb33364-f2c0-45ed-9f78-745fda3a2f6a/Untitled.png" alt="Untitled"></p>
<p>“Pixlr Remove Bg”中文名为“删除图像背景”,是一款免费的在线抠图工具。像其它抠图工具一样,它使用AI和机器学习技术来自动判断图片的前景和背景,无需繁琐的手动操作步骤。“Pixlr Remove Bg”的最大优点是支持批量抠图,可以一次上传多张图片进行批量抠图,大大提高效率。除此之外,“Pixlr Remove Bg”还支持高达16MP(4096×4096像素)的高清图片,并提供手动微调功能。如果AI无法准确判断需要移除或保留的部分,用户可以手动选取需要保留或移除的区域,获得更完美的抠图效果。</p>
<p>由于Pixlr本身是一款图像编辑软件,使用“Pixlr Remove Bg”抠图后的图片可以进一步在Pixlr X或Pixlr E中编辑,如添加背景或特效等。</p>
<p>使用“Pixlr Remove Bg”非常简单。打开网页,点击“打开图像”上传需要抠图的图片。如果图片过大,Pixlr会询问用户是否调整图片大小以提高性能,上传后Pixlr会自动分析图片和抠图。如有需要,可以使用右侧的“微调”工具手动选取需要保留或移除的区域。最后,点击右下角的“下载”按钮保存抠图结果。“Pixlr Remove Bg”无需注册账号,是一款非常实用的工具。</p>
<p>“Pixlr Remove Bg”具有三个主要优点:</p>
<p>第一,使用AI实现自动抠图,上传图片后自动分析和抠图;</p>
<p>第二,支持批量抠图,可以一次上传多张图片高效抠图;</p>
<p>第三,提供手动微调工具,可以选取需要移除或保留的区域。</p>
<p>综上,“Pixlr Remove Bg”是一款功能强大且易于使用的AI抠图工具,对需要频繁进行抠图工作的用户具有很高的实用价值。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [删除背景：Pixlr.com免费图像背景删除 - <a href="https://pixlr.com/cn/remove-background/">https://pixlr.com/cn/remove-background/</a>](<a href="https://pixlr.com/cn/remove-background/">https://pixlr.com/cn/remove-background/</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Pixlr</category>
        <category>Remove Backgroud</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Image</tag>
        <tag>Pixlr</tag>
        <tag>Remove Backgroud</tag>
      </tags>
  </entry>
  <entry>
    <title>[PlayGround AI] PlayGround AI 零基础用户也可轻松绘画</title>
    <url>/2023/04/21/Artificial-Intelligence-AI/PlayGround-AI/playground-ai-easy-for-beginners-to-paint-effortlessly/</url>
    <content><![CDATA[<h1>PlayGround AI 零基础用户也可轻松绘画</h1>
<p>PlayGround AI 是一款非常简单易用的AI绘画工具,适合零基础的用户使用。它提供大量素材和模型,让用户可以轻易创作出高质量的创意作品,无需任何专业技能或背景知识。</p>
<span id="more"></span>
<p>[Playground AI - <a href="https://playgroundai.com/">https://playgroundai.com/</a>](<a href="https://playgroundai.com/">https://playgroundai.com/</a>)</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e504f37d-0cab-48c2-83b2-72455cbc103f/Untitled.png" alt="Untitled"></p>
<p>使用PlayGround AI,你只需要输入简单的手绘线条,它就可以快速生成高质量素材,让你立即体验到极致的绘画乐趣,无需等待。它同时支持多种语言、操作系统和绘画风格,满足不同用户的需求。</p>
<p>PlayGround AI支持在线使用SD模型和DALLE2模型,用户也可以浏览生成的图片。在其功能界面上集成了两种模型的全部功能,无需本地部署,也不需要代码操作,目前完全免费使用。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/63d08cfc-f0b1-4682-a2fa-c36f0cddb4b6/Untitled.png" alt="Untitled"></p>
<p>PlayGround AI让绘画创作变得非常简单。用户不再需要繁琐的线稿、素材准备和后期处理工作,只需几条简单的手绘线条,PlayGround AI就可以自动生成精美素材,并根据线条生成完整的创意作品。这种“线稿即作为素材”的设计理念,彻底简化了创作流程,让创作变得轻松自在。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3fa6993f-9434-446a-93b6-dd11353895ee/Untitled.png" alt="Untitled"></p>
<p>PlayGround AI支持生成各种绘画和插画风格,如概念艺术、平面设计、卡通插画等。无论您的创作兴趣是什么,都可以在PlayGround AI找到适合您的风格和素材。丰富的样式库和强大的生成能力,让创作不再受限于技能或创作方式,用户只需要专注于传达想表达的意图。</p>
<p>总之,PlayGround AI是一个极其简单而强大的AI绘画工具。它让创作变得简单随性,让更多人可以轻松涉足创意领域,让创作不再受限,让创意得以更加自由流畅的表达。这款工具的出现,必将产生深远影响,革新创意创作方式和体验。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [Playground AI - <a href="https://playgroundai.com/">https://playgroundai.com/</a>](<a href="https://playgroundai.com/">https://playgroundai.com/</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>PlayGround AI</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>PlayGround AI</tag>
      </tags>
  </entry>
  <entry>
    <title>[PlayGround AI] AI赋能语音合成,PlayHT文本转语音技术革新助力多场景应用</title>
    <url>/2023/07/10/Artificial-Intelligence-AI/PlayHT/ai-powered-speech-synthesis-playhts-text-to-speech-technology-innovation-empowers-multi-scenario-applications/</url>
    <content><![CDATA[<h1>AI赋能语音合成,PlayHT文本转语音技术革新助力多场景应用</h1>
<p>随着语音交互技术的不断发展,基于AI的文本转语音(TTS)合成技术正在引领行业革新,为各类产品和服务带来更人性化的语音体验。一家名为PlayHT的创业公司推出了自主研发的AI语音合成平台,实现了惟妙惟肖的语音输出效果,具有广阔的应用前景。</p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/02ffc0a0-7f56-40e6-9652-ebdc20a8b097/Untitled.png" alt="Untitled"></p>
<p>PlayHT平台集成了829种人工智能生成的语音,支持142种语言和口音,语音效果自然流畅,完全突破了传统TTS机械合成的音调生硬局限。用户只需输入文字,即可在线生成逼真的语音音频,并支持MP3、WAV等格式导出,可直接用于商业用途。平台还提供了语速、音调、音量调节等语音优化功能,可以按需定制专属的语音风格。</p>
<p>这种AI驱动的语音合成技术为创作者提供了强大的语音内容生成工具,可广泛应用于视频、在线课程、广播等场景,大幅提升内容制作效率。同时,语音交互的人性化也将提升用户体验。比如客户服务电话机器人、智能音箱等都可以利用AI语音提升交互温度。</p>
<p>值得一提的是,PlayHT最近还推出了语音播客解决方案,使用户只需提供文字,就可以自动生成语音播客,并发布到主流平台。这为个人创作者提供了全新的内容变现方式。</p>
<p>展望未来,AI语音合成技术的进一步迭代将支持个性化语音设定,实现“数字人”的个性化。语音交互也将日益普及,从信息获取到情感交流,语音都将发挥关键作用,直接面向听觉的交互模式也更符合人的认知习惯。</p>
<p>在语音时代,语音内容将成为核心竞争力。AI赋能的语音合成为我们提供了语音内容的源源动力,各行各业都可以根据实际需求,运用文本转语音技术提升产品和服务的语音体验。语音交互带来的便利也将使我们的生活更加智能化。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://play.ht/">AI Voice Generator &amp; Realistic Text to Speech Online | PlayHT - https://play.ht/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>PlayHT</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Text to Speech (TTS)</tag>
        <tag>PlayHT</tag>
      </tags>
  </entry>
  <entry>
    <title>[Quora] Poe：开启人工智能聊天机器人新时代</title>
    <url>/2023/04/01/Artificial-Intelligence-AI/Quora/poe-ushering-in-a-new-era-of-ai-chatbots/</url>
    <content><![CDATA[<h1>Poe：开启人工智能聊天机器人新时代</h1>
<p>随着人工智能技术的不断发展，人们对于 AI 聊天机器人的需求也越来越高。近期，Quora 推出的 Poe 成为了聊天机器人领域的新秀。 Poe 是一款聊天机器人应用，由 OpenAI 和 Anthropic 提供 AI 模型支持，并且内建四款不同特色的聊天机器人。此应用程式使用非常方便，用户可以提出问题，即时获得 AI 聊天机器人的回答。</p>
<blockquote>
<p>Poe 目前已经支持 OpenAI 最新 GPT-4 模型，用户可以在其中体验最新的 AI 技术。<br>
Peo 需要注册使用，免费用户每天询问 ChatGPT 1 次，Claude+ 3 次。也可以付费使用。订阅价格: 每月 19.99 美元或每年 199.99 美元，订阅支持 7 天免费试用，在 7 天内可以随时取消不扣费。</p>
</blockquote>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ed2096b3-e8f2-4c84-9a63-5528355f9405/Poe.png" alt="Poe.png"></p>
<p>Poe 的主要特点：</p>
<p>智能问答：Poe 拥有庞大的资料库和强大的语言理解能力，可以理解并回答各种主题和较为复杂专业的问题。</p>
<p>多款聊天机器人：Poe 内建四款聊天机器人，包含 Sage、Claude、Dragonfly 及 ChatGPT。每款机器人都有擅长处理的工作，用户可以体验不同聊天机器人回应的效果，十分有趣。</p>
<p>简单易用：Poe 注册非常简单，用户只需进入[<a href="https://poe.com/login">https://poe.com</a>/](<a href="https://poe.com/login">https://poe.com</a>/) 或 Apple  App Store 搜寻「Poe」或「Quora」即可，并且可以使用邮箱或手机号码注册登录。</p>
<p>精确回答：在多数情况下，机器人回覆的方向及内容都正确，同时回答完之后，下方还会提供你可能会有的其他疑问。</p>
<p>时事新闻：Poe 的资料库包含许多时事新闻，用户可以随时了解最新的新闻事件。</p>
<p>值得一提的是，Poe 在设计上非常人性化，不仅外观简洁美观，使用上也非常方便。用户只需要在聊天框中输入问题，AI 聊天机器人就会根据问题的内容和背景给出相应的回答，让用户可以轻松地获得所需信息。</p>
<p>在使用 Poe 的过程中，用户可以根据自己的需求选择不同的聊天机器人，每款机器人都有其独特的特点和能力。例如，Sage 擅长处理语言相关的问题，例如创作文章、翻译等；而 Claude 则擅长对话相关的工作；ChatGPT 可以理解并回答各种主题和较为复杂专业的问题；Dragonfly 则主要针对一些简单的问题进行回答。</p>
<p>值得一提的是，Poe 不仅可以回答用户提出的问题，还可以与用户进行对话，甚至可以和用户进行一些趣味性的互动。这使得使用 Poe 变得更加生动有趣，用户不仅可以在其中获得所需信息，还可以享受到一种新的交互体验。<br>
此外，值得一提的是，Poe 在设计上非常人性化，不仅外观简洁美观，使用上也非常方便。用户只需要在聊天框中输入问题，AI 聊天机器人就会根据问题的内容和背景给出相应的回答，让用户可以轻松地获得所需信息。</p>
<p>除此之外，Poe 还提供了一些方便的功能，例如可以记录用户的对话记录，以便以后查询和使用；同时还支持多种语言，包括中文、英文、日语等等，方便不同地区的用户使用。</p>
<p>值得一提的是，AI 技术目前正处于不断发展和完善的阶段，因此 Poe 的 AI 聊天机器人也会不断进行升级和优化。未来，用户可以期待更加智能和精确的回答，以及更加人性化的交互体验。</p>
<p>总之，Poe 是一款非常优秀的 AI 聊天机器人应用，其强大的资料库和语言理解能力，以及多款不同特色的聊天机器人，可以满足用户在不同场景下的需求。除此之外，Poe 还具有简单易用、精确回答、人性化设计等优点，让用户可以在其中享受到非常良好的使用体验。对于那些喜欢与 AI 聊天机器人互动的用户来说，Poe 绝对是一款值得一试的应用程式。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://poe.com/">Poe - Fast, Helpful AI Chat - https://poe.com</a></p>
<p>[2] [Poe – Fast AI Chat on the App Store - <a href="https://apps.apple.com/app/apple-store/id1640745955?pt=660924&amp;mt=8">https://apps.apple.com/app/apple-store/id1640745955?pt=660924&amp;mt=8</a>](<a href="https://apps.apple.com/app/apple-store/id1640745955?pt=660924&amp;mt=8">https://apps.apple.com/app/apple-store/id1640745955?pt=660924&amp;mt=8</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Quora</category>
        <category>Poe</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>OpenAI</tag>
        <tag>ChatGPT</tag>
        <tag>GPT-4</tag>
        <tag>AI Chat</tag>
        <tag>Sage</tag>
        <tag>Claude+</tag>
        <tag>Claude-instant</tag>
        <tag>Anthropic</tag>
        <tag>Dragonfly</tag>
        <tag>Quora</tag>
        <tag>Poe</tag>
      </tags>
  </entry>
  <entry>
    <title>[Rask.ai] AI赋能,Rask.ai让视频内容零障碍进入全球市场</title>
    <url>/2023/06/04/Artificial-Intelligence-AI/Rask-ai/empowered-by-ai-rask.ai-enables-frictionless-access-for-video-content-to-global-markets/</url>
    <content><![CDATA[<h1>AI赋能,Rask.ai让视频内容零障碍进入全球市场</h1>
<p>视频内容是品牌传播的重要载体,但由于语言和文化差异,很多视频内容难以触达全球不同地域的观众。视频本地化工具Rask.ai凭借强大的AI技术,实现自动化的视频翻译和本地化,让视频内容零障碍进入全球市场。</p>
<span id="more"></span>
<p><a href="https://zh.rask.ai/home-rask">https://zh.rask.ai/home-rask</a></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/48c1b969-d8d6-4ab0-8f32-ec71bf9c5227/Untitled.png" alt="Untitled"></p>
<p>Rask.ai是一个人工智能驱动的视频本地化平台,能为视频提供自动画外音、多语种字幕以及高质量翻译等服务。Rask.ai依托强大的NLP和机器翻译技术,能够深层理解视频内容并翻译成30多种语言,如英语、中文、西班牙语、俄语、阿拉伯语等。Rask.ai的AI不仅可以检测视频中的语音,还能区分不同人物的声音,并为每个人物翻译对应的台词,这种多人识别与翻译技术在当前视频本地化领域较为先进。</p>
<p>使用Rask.ai非常简单直观。客户只需要将需要本地化的视频上传至Rask.ai的平台,在界面上选择需要的本地化语言,Rask.ai的AI系统便会自动生成相应语言的高质量字幕、翻译以及人声翻译,并将翻译后的内容直接嵌入视频画面中。整个翻译与本地化过程都是由AI自动完成,不需要人工干预,大大提高工作效率。</p>
<p>Rask.ai生成的视频翻译与人声翻译非常流利和连贯,字幕和声音的内容与原视频高度契合,几乎达到专业翻译的水平,这在一定程度上要归功于Rask.ai的AI技术与算法。</p>
<p>Rask.ai提供个人免费试用版和企业付费订阅版,个人试用版提供每月1个视频3分钟的免费翻译额度;企业付费版价格根据本地化视频数量和语言种类的不同而异,企业客户可以在Rask.ai的官网上查看定价详情并进行订阅。Rask.ai专注于企业客户的视频内容本地化与品牌全球化,已为多家Fortune 500的跨国企业提供自动化视频翻译服务,并在业界获得较高口碑。</p>
<p>总之,Rask.ai是一个功能强大的视频本地化平台,凭借自主研发的AI技术,实现高质高效的自动化视频翻译与本地化,让视频内容得以进入全球不同语言环境的市场,对企业品牌内容的全球传播具有较高促进作用,值得广大企业用户关注和试用。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://zh.rask.ai/home-rask">视频本地化工具 - https://zh.rask.ai/home-rask</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Rask.ai</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Rask.ai</tag>
      </tags>
  </entry>
  <entry>
    <title>[RealChar] AI人物创作工具RealChar开启虚实交互新纪元</title>
    <url>/2023/07/16/Artificial-Intelligence-AI/RealChar/ai-character-creation-tool-realchar-ushers-in-a-new-era-of-virtual-real-interaction/</url>
    <content><![CDATA[<h1>AI人物创作工具RealChar开启虚实交互新纪元</h1>
<p>元宇宙时代,数字虚拟人物已成为创作和社交的新载体。日前,一款名为RealChar的AI人物创作与交互工具推出公测版,支持用户通过语音与AI人物实时对话。这一开源项目为数字人创作和虚实世界融合探索了新的可能,被业内视为元宇宙内容创作的重要进展。</p>
<p><a href="https://realchar.ai/">https://realchar.ai/</a></p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7ec6e5e7-ce4d-4935-90ad-773913ccccd6/Untitled.png" alt="Untitled"></p>
<p>RealChar由语音驱动,用户只需通过设备输入语音,即可生成AI人物的回应。支持文字输入、发送信息及建立人物连接等多种交互方式。简单的图标操作即可发起、继续或结束对话。用户还可以自定义人物外观,进行角色塑造。这种语音交互带来高度沉浸感,是当前AI虚拟人物创作的大趋势。</p>
<p>项目组表示,移动版本正在开发中,未来将覆盖更广泛用户。RealChar的开源代码托管在GitHub,开发者可以基于该项目进行二次开发。开源社区支持,也使其具备持续演进的可能。</p>
<p>事实上,元宇宙对用户生成内容的需求正在提升。用户不仅希望沉浸在虚拟世界,也期望参与内容创作。RealChar等AI人物创作工具的出现正满足这一需求。未来可能出现大量用户基于此类工具自创数字角色,进行社交互动、世界构建等。AI赋能的创作工具必将推动UGC时代的到来。</p>
<p>当然,这类创作工具也面临一定挑战。如何营造真实的语音交互体验,使对话更具个性;如何建立健康的虚拟社区生态;内容审核与监管等问题也需要考量。但RealChar代表的技术和应用方向无疑是值得期待的。可以预见,各类元宇宙平台将涌现出AI助理、数字偶像等新形式创作内容。虚实交融也将成为元宇宙的重要组成部分。未来我们与“数字人”的关系,将迎来全新改变。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://realchar.ai/">RealChar. - Realtime AI Character - https://realchar.ai/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>RealChar</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>AI Companion</tag>
        <tag>RealChar</tag>
      </tags>
  </entry>
  <entry>
    <title>[SceneXplain] SceneXplain：讲述图像每一个像素背后的故事</title>
    <url>/2023/06/15/Artificial-Intelligence-AI/SceneXplain/sceneXplain-explore-image-storytelling-beyond-pixels/</url>
    <content><![CDATA[<h1>SceneXplain：讲述图像每一个像素背后的故事</h1>
<p>SceneXplain 是一项尖端的 SaaS 服务，它使用先进的 AI 技术为上传的图像生成全面而复杂的文本描述。 SceneXplain 通过提供详细的图像解释和支持无缝 API 集成来迎合各个行业，包括内容创作者、新闻和媒体组织以及电子商务企业。</p>
<p><a href="https://scenex.jina.ai/">https://scenex.jina.ai/</a></p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e62a022f-527f-46c1-b769-1ec07cbc6982/Untitled.png" alt="Untitled"></p>
<p>SceneXplain 利用最先进的大规模语言模型来解释像素背后的复杂故事，超越了传统算法的局限性。快来探 SceneXplain 背后那引人入胜和专业的图像叙事体验！</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/277a59ee-bcb2-4f1e-bcfa-7ae088ae8e4a/Untitled.png" alt="Untitled"></p>
<p>SceneX 是市场上性能最好的图像字幕算法。其先进的架构利用大型语言模型，使其能够比其他算法更有效地处理复杂的场景理解和解释。 SceneX 在各种指标上始终优于同类产品，例如捕捉图像中复杂的视觉信息、生成相关且引人入胜的说明文字以及实现高可读性和连贯性的能力。虽然其他算法在某些指标上显示出令人鼓舞的结果，但在其他指标上却达不到要求，这证明了 SceneX 在图像字幕和场景理解方面的整体实力。</p>
<p>借助SceneXplain易于使用的 API，您可以一次性描述大量图像。根据您的订阅，您可以在 40 秒内批量描述最多 128 张图像。它非常适合希望将 SceneXplain 集成到他们的应用程序、网站或服务中的商业用户。</p>
<p>唯一可以为您的 ChatGPT 解锁多模式功能的插件。理解场景并利用这种理解来完成范围广泛的复杂任务，例如结合电商插件购买看上去相似的产品，或去景色宜人的地方旅游。</p>
<p><a href="https://jina-ai-gmbh.ghost.io/content/media/2023/04/scenex-chatgpt-plugin.mp4">https://jina-ai-gmbh.ghost.io/content/media/2023/04/scenex-chatgpt-plugin.mp4</a></p>
<h2 id="功能">功能</h2>
<h3 id="大规模语言模型">大规模语言模型</h3>
<p>SceneXplain 利用最先进的大型模型和大规模语言模型为您的图像生成全面、复杂的文本描述，超越了传统的字幕算法。</p>
<h3 id="多语言支持">多语言支持</h3>
<p>SceneXplain 强大的 AI 技术提供无缝的多语言支持，使用户能够收到准确而有意义的多语言描述。</p>
<h3 id="API集成">API集成</h3>
<p>SceneXplain 提供完善的 API 集成，使开发人员能够毫不费力地将我们的图片标注服务整合到他们的多模态应用程序中。</p>
<h3 id="快速批处理性能">快速批处理性能</h3>
<p>体验高达每秒 3 次查询 (QPS) 的性能，确保 SceneXplain 为您的图像提供及时高效的文本描述。</p>
<h3 id="ChatGPT-插件">ChatGPT 插件</h3>
<p>您可以将 SceneXplain 用作 ChatGPT 插件。与其他插件一起，您可以完成范围广泛的复杂任务，例如购买外观。</p>
<p>SceneXplain 特别擅长描述涉及多个对象、交互和上下文元素的复杂场景。使用 SceneXplain 来描述简单图像（例如单个人或单个对象）可能有点大材小用。</p>
<h2 id="价格">价格</h2>
<p>SceneXplain 为新用户提供限时免费试用以探索和评估我们的服务。要注册免费试用，只需创建一个帐户。</p>
<p>SceneXplain 提供各种定价计划以满足不同用户的需求，从个人用户到大型企业。请访问定价部分，了解有关可用计划、功能和定价的详细信息。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8151086c-f76b-4fbe-b24c-20334aefecac/Untitled.png" alt="Untitled"></p>
<p>欢迎使用 SceneXplain，一个能讲述图片背后故事的API服务。SceneXplain把最新的大模型应用到图像上的每一个细节，为每一张图片生成细致的文本描述。如果您是开发人员，可以通过SceneXplain API毫不费力地将SceneXplain的算法集成到多模态应用中。从此告别平淡无奇的图片说明！</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://scenex.jina.ai/">SceneXplain - Explore image storytelling beyond pixels - https://scenex.jina.ai/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>SceneXplain</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>SceneXplain</tag>
      </tags>
  </entry>
  <entry>
    <title>[Scouter] Scouter: 用于实践中学习语言的浏览器插件</title>
    <url>/2023/09/02/Artificial-Intelligence-AI/Scouter/scouter-browser-plugin-learn-languages-in-practice/</url>
    <content><![CDATA[<h1>Scouter: 用于实践中学习语言的浏览器插件</h1>
<h2 id="背景与介绍"><strong>背景与介绍</strong></h2>
<p>在今天的全球化社会中，语言学习已经成为一个至关重要的技能。然而，传统的语言学习方法往往侧重于翻译和词汇记忆，而忽视了实际语言运用的重要性。对于那些想要更深入地学习外语的人来说，Scouter 是一个强大的工具。</p>
<span id="more"></span>
<h2 id="什么是Scouter？"><strong>什么是Scouter？</strong></h2>
<p>Scouter 是一款面向语言学习者的浏览器插件，其核心理念是在实践中学习语言。这个插件提供了一系列功能，使学习者能够更好地融入真实语言环境中，提高他们的语言技能。以下是 Scouter 提供的主要功能：</p>
<ol>
<li>
<p><strong>解释和相关例句：</strong> Scouter 可以帮助你理解不仅仅是翻译，还包括相关例句，使你更好地掌握单词和短语的用法。</p>
</li>
<li>
<p><strong>测试巩固学习：</strong> 通过支持连续对话和测试，Scouter 让你能够巩固学到的知识，确保你真正理解和掌握了语言。</p>
</li>
<li>
<p><strong>自定义 Prompt：</strong> 你可以自定义学习提示，以满足你的学习需求，使学习过程更加个性化。</p>
</li>
<li>
<p><strong>Azure TTS：</strong> Scouter 还整合了 Azure TTS（文本到语音），提供更丰富的语言学习体验。</p>
</li>
<li>
<p><strong>导入到 Anki：</strong> 它支持与 Anki 等第三方服务集成，帮助你更好地记忆和应用所学的知识。</p>
</li>
<li>
<p><strong>多语言支持：</strong> Scouter 不仅仅支持一种语言，而是多语言的，适用于各种语言学习需求。</p>
</li>
</ol>
<h2 id="不是什么？"><strong>不是什么？</strong></h2>
<p>需要注意的是，Scouter 不是翻译工具。它的目标是帮助你学会独立运用外语，而不仅仅是提供翻译。它也不是对话工具，它专注于对 AI 提供的测试题进行一次性答题，而不是与人进行对话。</p>
<p><strong>Scouter 与其他工具的区别</strong></p>
<p>Scouter 与传统的划词翻译工具有着明显的区别，主要体现在以下方面：</p>
<ol>
<li>
<p><strong>学习「不知道自己不知道」的知识：</strong> 传统词典只能帮助你查找已知词汇的含义，但 Scouter 能够帮助你学习那些你在阅读时可能不知道自己不知道的句子，通过分析语法结构来帮助你理解更复杂的语言表达。</p>
</li>
<li>
<p><strong>与 Anki 等第三方服务集成：</strong> Scouter 不是孤立的工具，它可以与 Anki 等其他学习工具集成，提供更全面的学习体验。</p>
</li>
</ol>
<h2 id="为什么开发-Scouter？"><strong>为什么开发 Scouter？</strong></h2>
<p>Scouter 的开发者深知在实际语言环境中学习语言的重要性。他们在 ChatGPT 推出之前就积极学习英语，喜欢通过阅读文章、参与英文社区的讨论来学习。然而，他们一直感到缺少一个能够针对目标语句进行分析、解释语法的工具，直到遇到了 ChatGPT。尽管 ChatGPT 能够帮助他们分析、练习语法，但每次都需要手动复制语句并切换到 ChatGPT 窗口，这不够高效。</p>
<p>与其他 ChatGPT 客户端不同，Scouter 针对英语学习场景进行了优化，支持快捷唤起和自定义 Prompt，同时还支持与 Anki 集成，以提供更好的学习支持。</p>
<h2 id="设计理念：在实践中学习语言"><strong>设计理念：在实践中学习语言</strong></h2>
<p>Scouter 的核心理念是在实际语言应用环境中学习。这意味着学习者应该在他们最终要用到语言的情境中学习这门语言。在实践中学习语言有以下几个关键优点：</p>
<ol>
<li>
<p><strong>可理解的输入：</strong> 在实际环境中，有丰富的上下文可供参考，这有助于学习者理解语法和词汇。即使遇到不熟悉的词汇，也可以通过上下文推测其含义。</p>
</li>
<li>
<p><strong>使用正在学习的语言：</strong> 学习语言需要大量的实践，包括听、说、读、写。在实践中学习能够让你更好地应用所学的语言技能，从而更快地掌握它们。</p>
</li>
<li>
<p><strong>及时反馈：</strong> 实践中学习还提供了及时的反馈机会，帮助学习者纠正错误，激励他们继续学习。</p>
</li>
</ol>
<p>Scouter 的设计理念正是基于这些原则，旨在帮助语言学习者更好地融入实际语言环境，提高他们的语言技能。</p>
<p>总之，Scouter 是一个强大的工具，为那些渴望在实践中学习语言的人提供了有力支持。它不仅提供了丰富的功能，还体现了现代语言学习的最佳实践。对于那些想要更好地掌握外语的人来说，Scouter 可以成为一个强大的伙伴。</p>
<h2 id="结语"><strong>结语</strong></h2>
<p>在全球化和数字化时代，语言学习变得比以往任何时候都更加重要。Scouter 为语言学习者提供了一种创新的方法，鼓励他们在实际语言环境中学习，培养更深入的语言技能。这一工具的开发背后的设计理念，即在实践中学习语言，反映了现代语言学习的最佳实践原则。</p>
<p>无论是想要掌握新的外语技能，还是提高已有语言技能的人，Scouter 都可以成为他们的强大工具，帮助他们更好地融入不同的语言环境，提高语言沟通能力。通过结合实践、理论和技术，Scouter 提供了一个全面的语言学习解决方案，为语言学习者的成功铺平了道路。在这个不断变化的世界中，Scouter 提供了一个有力的工具，使人们能够更好地适应和参与全球社会。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://notes.dabing.one/post?note-id=2d4a5130-ce79-4532-89e6-f1e81d300716&amp;active-note-id=2d4a5130-ce79-4532-89e6-f1e81d300716">Scouter - https://notes.dabing.one/post?note-id=2d4a5130-ce79-4532-89e6-f1e81d300716&amp;active-note-id=2d4a5130-ce79-4532-89e6-f1e81d300716</a></p>
<p>[2] <a href="https://chrome.google.com/webstore/detail/scouter/mncfcjnabpfoagocanfjglfcpmmnkicb">Scouter - Chrome Web Store - https://chrome.google.com/webstore/detail/scouter/mncfcjnabpfoagocanfjglfcpmmnkicb</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Scouter</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>OpenAI</tag>
        <tag>ChatGPT</tag>
        <tag>Prompt Engineering</tag>
        <tag>Text-to-Speech (TTS)</tag>
        <tag>Anki</tag>
        <tag>Refold</tag>
        <tag>Scouter</tag>
      </tags>
  </entry>
  <entry>
    <title>[Speak] Speak: 一种全新的学习语言的方式</title>
    <url>/2023/06/18/Artificial-Intelligence-AI/Speak/speak-a-completely-new-way-to-learn-a-language/</url>
    <content><![CDATA[<h1>Speak: 一种全新的学习语言的方式</h1>
<p>学习一门新语言一直以来都是一个令人头疼的任务。要想精通一门语言,实践是一个非常重要的组成部分。但要找到一位母语者进行练习对话却不是一件容易的事情,私人教师的费用也昂贵。</p>
<p>Speak是一个全新的手机应用,能够让你轻松进行口语练习,而无需人工老师在另一端。这款应用使用了世界上最先进的人工智能语音技术,能够实现0.1秒的延迟和95%的准确度,并且可以100%实时地进行会话。</p>
<p><a href="https://www.usespeak.com/">https://www.usespeak.com/</a></p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a6b676e7-22cd-4a21-a3e0-ec4e5a4d0b05/Untitled.png" alt="Untitled"></p>
<p>Speak目前尚未推出所有语言版本,但很快会陆续推出更多语言。你可以在官网上预约,首先获得最新版本的通知。</p>
<p>一位Speak的用户分享道:“我的一生从未如此频繁地讲英语。”这位用户来自韩国,通过Speak应用获得了大量的英语口语练习。<br>
Speak应用使用了极为advanced的人工智能语音技术。它是第一个也是唯一一个可以让你获得真实的对话练习而无需人工老师的应用。为了实现这一目标,Speak投入了大量的技术研发。<br>
与传统的学习语言的方式相比,Speak应用具有以下三大优势:</p>
<ol>
<li>超低延迟。Speak应用的延迟只有0.1秒,这意味着你的口语表达可以得到极为及时的反馈,就像与真人对话一样顺畅。</li>
<li>高精度。Speak应用的语音识别精度高达95%,远超传统APP。这为学习者提供了更加准确可靠的评价和反馈。</li>
<li>100%实时。Speak使用最先进的语音识别技术,可以实现100%的实时会话。学习者可以随时提问,并得到AI的即时回应,就像真人对话一样自然流畅。</li>
</ol>
<p>总之,Speak是一个非常有创新精神的新型语言学习应用。它运用最尖端的人工智能来实现真实的口语对话练习,提供语音交互式学习体验。相比传统的学习方式,它更加高效、便捷和趣味性。未来,这类人工智能驱动的沉浸式学习应用必将给语言学习带来革命性的变化。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://www.usespeak.com/">Speak - The speaking app that actually talks - https://www.usespeak.com/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Speak</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>English Speaking</tag>
        <tag>Speak</tag>
      </tags>
  </entry>
  <entry>
    <title>[Stable Diffusion] I画图工具Stable Doodle开启无限Imaging新纪元</title>
    <url>/2023/07/18/Artificial-Intelligence-AI/Stable-Diffusion/ai-drawing-tool-stable-doodle-ushers-in-a-new-era-of-unlimited-imaging-possibilities/</url>
    <content><![CDATA[<h1>AI画图工具Stable Doodle开启无限Imaging新纪元</h1>
<p>知名AI创业公司Stability AI推出了Stable Doodle草图转图像工具,用户仅需简单手绘,即可转换生成动态图像。这一创新工具为众多专业创作者和爱好者打开了无限的imaging可能,必将对教育、设计、时尚、艺术等诸多行业带来革命性影响。</p>
<p><a href="https://clipdrop.co/stable-doodle">https://clipdrop.co/stable-doodle</a></p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/91f49eaa-e89d-4cca-beaa-d53bb82ed7bb/Untitled.png" alt="Untitled"></p>
<p>Stable Doodle易于上手使用,无论专业程度高低,都可以通过简单草图描线和选择艺术风格,在几秒内生成高品质原创图像。设计师、插画师等创作者可以节约大量时间,极大提升工作效率。手绘草图可以快速实现为客户作品、演示文稿、网站素材,甚至LOGO。该工具带来了无限创作可能,而且非常有趣!</p>
<p>技术上,Stable Doodle整合了Stability AI领先的Stable Diffusion XL图像生成技术和腾讯ARC开发的T2I-Adapter条件控制解决方案。后者通过为diffusion模型增加可训练参数,可以输入额外条件如草图、分割图等进行精确控制。两者结合,形成对输入草图轮廓的理解并转换生成图像的系统。</p>
<p>Stable Doodle目前已在Clipdrop网站和App中推出,用户可以免登录试用。其友好界面和强大功能令人印象深刻。不过,也应认识到其固有局限,结果依赖初始输入和描述,复杂场景生成准确性存疑。用户需要审慎使用,遵守服务条款。</p>
<p>总体来看,Stable Doodle代表了AI绘图技术的新高度。它不但为广大用户提供了简易图像生成工具,也将推动创意产业变革,引领imagining的新趋势。预计各行各业都将应用这类AI绘图工具提升工作流程。教育、设计、娱乐等领域将出现全新的创作形态和可能。甚至个人用户也可以实现想象成真,开启无限创作之旅。AI赋能的创作工具时代已经来临。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://clipdrop.co/stable-doodle">ClipDrop - Stable Doodle - https://clipdrop.co/stable-doodle</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Stable Diffusion</category>
        <category>Stable Doodle</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Stable Diffusion</tag>
        <tag>Stable Doodle</tag>
      </tags>
  </entry>
  <entry>
    <title>[Stable Diffusion] DreamStudio: AI图像生成新工具,图片效果惊艳</title>
    <url>/2023/04/20/Artificial-Intelligence-AI/Stable-Diffusion/dreamstudio-a-new-ai-image-generation-tool-with-stunning-picture-effects/</url>
    <content><![CDATA[<h1>DreamStudio: AI图像生成新工具,图片效果惊艳</h1>
<p>DreamStudio 是 Stability AI 公司开发的一款人工智能文本-图像扩散(CLIP)模型,能根据输入的文本提示词生成高质量的图像。DreamStudio界面简洁明了,分类清晰,参数面板也很易于理解,使用体验远超之前的同类产品。</p>
<span id="more"></span>
<p>[DreamStudio - <a href="https://beta.dreamstudio.ai/generate">https://beta.dreamstudio.ai/generate</a>](<a href="https://beta.dreamstudio.ai/generate">https://beta.dreamstudio.ai/generate</a>)</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/29320c55-c1ab-441d-a2a8-050769a05211/Untitled.png" alt="Untitled"></p>
<h2 id="使用">使用</h2>
<p>-&gt; 根据提示词生成图片<br>
A pirate port, with ships setting sail, blacksmiths crafting weapons, and treasure-filled caves, adventurous, detailed, historic, swashbuckling</p>
<pre><code>![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3c8fe6c6-60cd-4304-a948-7412374bae12/Untitled.png)
</code></pre>
<p>使用DreamStudio生成图片的基本步骤是:</p>
<p>首先在右侧面板设置图片大小、文本图像相似度、渲染步数和数量等参数;</p>
<p>然后在下方文本框内输入文本提示词;</p>
<p>最后点击“Dream”按钮等待图片生成。</p>
<p>图片显示后可点击下载。</p>
<p>右侧面板的部分参数概念:</p>
<p>“Clg Scale”表示生成图像与文本提示的相似度,值越高相似度越高;</p>
<p>“Steps”表示模型渲染步数,步数越高图片细节越丰富,但渲染时间也越长,一般50步左右足够;</p>
<p>“Sampler”表示扩散采样方式,不同方式生成的图像效果不同;</p>
<p>“Seed”表示种子数,填入这个值可以再次生成同样的图片。</p>
<p>在左侧栏的“History”可以查看自己生成的所有图片,显示图片的文本提示、大小、种子和相似度值,点击“Redream”可再次生成该图片。</p>
<p>想让DreamStudio生成精确高质的图像,填写准确的文本提示词很重要。</p>
<p>DreamStudio在左侧栏的“Prompt Guide”提供了填写提示词的入门指引,建议在输入提示词前仔细阅读。</p>
<p>不要只输入简单词语,要使用风格提示词和艺术家名称让图像更富艺术性,在文本末尾加修饰词可以使图像更符合想要的效果。DreamStudio作为新一代的文本图像生成工具,功能强大,操作简单直观,能快速生成各类高质量图像,必将成为设计师和艺术家不可或缺的创作工具之一。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [DreamStudio - <a href="https://beta.dreamstudio.ai/generate">https://beta.dreamstudio.ai/generate</a>](<a href="https://beta.dreamstudio.ai/generate">https://beta.dreamstudio.ai/generate</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Stable Diffusion</category>
        <category>DreamStudio</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Stable Diffusion</tag>
        <tag>DreamStudio</tag>
      </tags>
  </entry>
  <entry>
    <title>[Stable Diffusion] 太乙Stable Diffusion模型根据给定的中文文本生成相应的图像</title>
    <url>/2023/04/19/Artificial-Intelligence-AI/Stable-Diffusion/stable-diffusion-model-generates-corresponding-images-according-to-the-given-chinese-text/</url>
    <content><![CDATA[<h1>太乙Stable Diffusion模型根据给定的中文文本生成相应的图像</h1>
<p>随着人工智能技术的不断发展，AI绘画成为了近年来备受瞩目的领域之一。最近，Stable Diffusion模型的开源为AI绘画领域注入了新的活力，而随之而来的是各种创新性的应用和作品。然而，在国内，大部分的团队依赖于翻译API和英文Stable Diffusion模型进行开发，这导致了一些问题，例如在叙述和表达中文独特之处时，模型难以提供正确的图片内容匹配。针对这一问题，IDEA研究院认知计算与自然语言研究中心（IDEA CCNL）推出了太乙Stable Diffusion模型的中文版本，这为中国文化内核的AIGC模型开辟了一条新的道路。</p>
<span id="more"></span>
<blockquote>
<p>输入中文提示词“中国海边城市，科幻，未来感，唯美，插画”，AI 自动生成图像。</p>
</blockquote>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cedd5817-d4ac-4588-a644-d7b9bccb859c/Untitled.png" alt="Untitled"></p>
<p>链接地址：[IDEA-CCNL/Taiyi-Stable-Diffusion-1B-Chinese-v0.1 · Hugging Face - <a href="https://huggingface.co/IDEA-CCNL/Taiyi-Stable-Diffusion-1B-Chinese-v0.1">https://huggingface.co/IDEA-CCNL/Taiyi-Stable-Diffusion-1B-Chinese-v0.1</a>](<a href="https://huggingface.co/IDEA-CCNL/Taiyi-Stable-Diffusion-1B-Chinese-v0.1">https://huggingface.co/IDEA-CCNL/Taiyi-Stable-Diffusion-1B-Chinese-v0.1</a>)</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2ffac226-d92d-4f46-a54a-76fc00073b16/Untitled.png" alt="Untitled"></p>
<p>太乙Stable Diffusion模型是一种基于语言模型的图像生成模型，它能够根据给定的中文文本生成相应的图像。这个模型是以Stable Diffusion模型为基础的，但是在其基础上，IDEA CCNL团队对中文语言处理进行了深度优化。太乙Stable Diffusion模型有两个版本，分别是纯中文版本和中英双语版本，这两个版本的模型均能够生成具有中国文化内核的图像。</p>
<p>相较于以往的图像生成模型，太乙Stable Diffusion模型的一个显著优势是其能够根据文本内容进行智能调整。比如，在给定一句描述人物风貌的句子时，模型会自动调整生成的图像，使其更符合人物的形象特征。此外，太乙Stable Diffusion模型还能够生成非常精美的艺术风格图像，如油画、水彩画等。这些图像不仅美观，而且具有高度的艺术价值。</p>
<p>除此之外，太乙Stable Diffusion模型的中文版本还具有一个显著的优势，那就是其能够更好地处理中文叙事和表达。在中文语境下，有很多叙事和表达方式是英文所不具备的，而太乙Stable Diffusion模型的中文版本正是针对这些问题进行了优化。模型能够更好地理解中文文本，从而生成更加符合中文文化内核的图像。</p>
<p>太乙Stable Diffusion模型的开源是一个非常重要的里程碑。通过开源，这个模型可以更广泛地应用于各个领域，如艺术、设计、娱乐等等，为中文世界的AIGC应用提供了更好的基础和条件。</p>
<p>值得注意的是，与英文文化和语言环境有所不同的是，中文文化内核是非常独特和丰富的，具有丰富的意象和文化符号。而这些文化元素往往是深植于中文语言和文化之中的，因此仅仅是基于英文模型进行翻译和应用并不能完全满足中文语境下的需求。太乙Stable Diffusion模型的开源，为中文文化与中文语境下的AIGC应用提供了更好的解决方案，能够更加贴合中文文化背景，更加准确地识别和表达中文语境中的文化元素，使得AIGC应用的表现力和创造力更加突出。</p>
<p>当然，太乙Stable Diffusion模型开源的意义不仅仅在于中文文化与语境的应用，它还为中文世界提供了更好的基础和条件，让更多的人能够更加方便地使用这种技术，从而推动中文世界AIGC应用的发展。通过开源，太乙Stable Diffusion模型可以为中文世界的AIGC应用提供更多的资源和支持，进一步激发中文世界的创造力和创新精神，让我们更好地探索和发现这个世界的美好和可能性。</p>
<p>总之，太乙Stable Diffusion模型的开源为中文世界的AIGC应用提供了更好的基础和条件，推动了中文世界的AIGC技术的发展和创新。它不仅仅是一个技术创新，更是一个文化交流和创造的过程。我们相信，在太乙Stable Diffusion模型的基础上，中文世界的AIGC应用将会越来越丰富、精彩和多样化，为我们带来更多的创新和惊喜。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [IDEA-CCNL/Taiyi-Stable-Diffusion-1B-Chinese-v0.1 · Hugging Face - <a href="https://huggingface.co/IDEA-CCNL/Taiyi-Stable-Diffusion-1B-Chinese-v0.1">https://huggingface.co/IDEA-CCNL/Taiyi-Stable-Diffusion-1B-Chinese-v0.1</a>](<a href="https://huggingface.co/IDEA-CCNL/Taiyi-Stable-Diffusion-1B-Chinese-v0.1">https://huggingface.co/IDEA-CCNL/Taiyi-Stable-Diffusion-1B-Chinese-v0.1</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Stable Diffusion</category>
        <category>IDEA-CCNL</category>
        <category>Taiyi</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Chinese</tag>
        <tag>Stable Diffusion</tag>
        <tag>IDEA-CCNL</tag>
        <tag>Taiyi</tag>
      </tags>
  </entry>
  <entry>
    <title>[TOKO] TOKO:与AI轻松练习英语口语</title>
    <url>/2023/06/18/Artificial-Intelligence-AI/TOKO/practice-english-speaking-with-ai/</url>
    <content><![CDATA[<h1>TOKO:与AI轻松练习英语口语</h1>
<p>TOKO 是一款人工智能英语学习应用,它拥有独特的AI技术,可以让用户与真人对话般与其交流。TOKO提供轻松的学习环境,用户可以毫无压力地练习英语思考和对话,而TOKO永远不会对用户的发言进行判断。</p>
<span id="more"></span>
<p><a href="https://www.tokotutor.com/">https://www.tokotutor.com/</a></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ee9a1b88-2fe0-40dd-9783-a1f867573706/Untitled.png" alt="Untitled"></p>
<p>TOKO有以下优点:</p>
<ol>
<li>AI生成:TOKO使用AI技术为用户快速生成英语对话框架,用户只需输入主题或示例,AI就可以生成符合要求的框架。这大大简化了学习流程,让用户专注于对话的定制和个性化。</li>
<li>直观操作:TOKO提供拖拽式操作界面,所有元素均可通过鼠标移动、调整大小等。这种操作方式简化了英语学习曲线,适合不同人群。</li>
<li>实时预览:在TOKO中进行的所有操作均可实时在应用中显示,使得用户在观看界面同时进行调整。这种交互式设计大大提高了用户的学习体验。</li>
<li>高度定制:TOKO为用户提供多种工具进行高度定制,包括添加动画、选择网站导航方式等。这使得每个用户的学习进程看起来独一无二。</li>
<li>社区支持:TOKO拥有庞大的社区用户群以及详尽的在线教程和文档,可以为用户遇到的各类问题提供帮助。</li>
</ol>
<p>TOKO致力于让英语学习尽可能简单,其独特的产品定位和强大的功能受到许多用户的青睐。相信随着AI技术的不断发展,TOKO会不断增强自身实力,为更多英语学习者提供卓越体验。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://www.tokotutor.com/">Toko | 毫無壓力練習英文口說 - https://www.tokotutor.com/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>TOKO</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>English Speaking</tag>
        <tag>TOKO</tag>
      </tags>
  </entry>
  <entry>
    <title>[Webcam Motion Capture] AI技术让你成为虚拟3D虚拟形象，无需购买昂贵的设备</title>
    <url>/2023/07/01/Artificial-Intelligence-AI/Webcam-Motion-Capture/ai-technology-allows-you-to-become-a-3d-virtual-avatar-without-the-need-to-purchase-expensive-equipment/</url>
    <content><![CDATA[<h1>AI技术让你成为虚拟3D虚拟形象，无需购买昂贵的设备</h1>
<p>Webcam Motion Capture 凭借AI技术驱动的网络摄像头动作捕捉，你的计算机或智能手机上的摄像头可以完全控制你的3D虚拟形象。</p>
<p>自2021年11月推出以来，来自85个国家的9700多名用户已经订阅了网络摄像头动作捕捉！</p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0cb0f581-55c6-48bf-89e4-f736683b311d/Untitled.png" alt="Untitled"></p>
<h2 id="功能特点">功能特点</h2>
<p>仅需网络摄像头即可实现高质量的手部和手指追踪</p>
<p>无需购买Leap Motion或任何特殊设备即可成为虚拟YouTuber</p>
<p>通过仅使用网络摄像头实现自然而强大的手部和手指追踪</p>
<p>还包括头部追踪、眼睛注视追踪、眨眼检测、嘴唇同步和上半身追踪。</p>
<p>支持Face ID的人脸追踪应用程序与完美同步兼容（支持的应用程序列表）。</p>
<p>通过VMC协议将追踪数据发送到外部应用程序</p>
<p>将动作捕捉数据保存为FBX文件</p>
<p>AI驱动的Webcam Motion Capture技术为虚拟YouTuber（VTuber）提供了一个简便且经济实惠的选择。使用仅需普通摄像头的手部和手指跟踪功能，您可以通过计算机或智能手机上的摄像头完全控制您的3D虚拟形象。此外，头部跟踪、眼神跟踪、眨眼检测、嘴唇同步和上半身跟踪等功能也被包含在内。</p>
<p>Webcam Motion Capture还支持通过VMC协议将跟踪数据发送到外部应用程序，并可以将动作捕捉数据保存为FBX文件。此外，该技术与一些支持完美同步的面部追踪应用程序兼容，这些应用程序使用iPhone/iPad的Face ID进行丰富的面部表情。</p>
<p>您可以免费下载这款软件，并尝试所有的跟踪功能。订阅只需每月1.99美元，订阅包括所有未来的软件更新，并且您可以随时停止订阅。</p>
<p>Webcam Motion Capture还提供了一系列常见问题（FAQ）的解答，涵盖了诸多使用方面的疑问。如果您遇到任何问题，您可以通过电子邮件或Twitter与开发团队取得联系。</p>
<p>随着AI技术的不断发展，虚拟YouTuber和虚拟形象的应用前景变得更加广阔。AI驱动的Webcam Motion Capture为普通用户提供了进入这个领域的机会，无需购买昂贵的设备。通过简单的设置和操作，您可以开始探索虚拟创作、直播和视频制作的新方式。</p>
<p>无论是作为个人创作者还是作为企业用户，Webcam Motion Capture技术都为您带来了更多的创作可能性。它代表了虚拟YouTuber领域的一项重要进展，同时也展示了AI技术在娱乐和创意领域的广阔应用前景。让我们拭目以待，看看虚拟形象技术将如何继续演进并丰富我们的数字体验。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://webcammotioncapture.info/">Hand Tracking with Only Webcam - Webcam Motion Capture - https://webcammotioncapture.info/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>TOKO</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>English Speaking</tag>
        <tag>TOKO</tag>
      </tags>
  </entry>
  <entry>
    <title>[通义听悟] 通义听悟：万语千言，心领神悟</title>
    <url>/2023/07/05/Artificial-Intelligence-AI/tingwu/tingwu/</url>
    <content><![CDATA[<h1>通义听悟：万语千言，心领神悟</h1>
<h2 id="通义听悟是什么？">通义听悟是什么？</h2>
<p>「通义听悟」是你的工作学习AI助手，依托大模型，为每一个人提供全新的音视频体验。</p>
<p>通义听悟可以在会议、学习、访谈、培训等场景下：</p>
<ul>
<li>🚀 实时记录交流内容，同步翻译</li>
<li>🚀 批量转写音视频文件，区分发言人</li>
<li>🚀 智能提炼全文概要、章节速览、发言总结</li>
<li>🚀 自动提取关键词、问题、待办事项</li>
<li>🚀 编辑整理笔记，导出记录</li>
</ul>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7f2b3f5e-ffa3-45f4-81a8-6fd3f751da48/Untitled.png" alt="Untitled"></p>
<h2 id="💡-如何使用通义听悟？">💡 如何使用通义听悟？</h2>
<p>电脑端</p>
<p><a href="https://tingwu.aliyun.com/">点击此处</a>立即登录体验。<a href="https://tingwu.aliyun.com/?spm=5176.28158887.0.0.373b6b8cECbnBY">https://tingwu.aliyun.com</a></p>
<p>手机端</p>
<p>微信小程序：使用微信扫描下方小程序码即可体验。</p>
<p>!<a href="https://img.alicdn.com/imgextra/i3/O1CN01Ti6ZsI1lIcO7bcBip_!!6000000004796-0-tps-430-430.jpg">https://img.alicdn.com/imgextra/i3/O1CN01Ti6ZsI1lIcO7bcBip_!!6000000004796-0-tps-430-430.jpg</a></p>
<p>钉钉小程序：使用钉钉扫描下方二维码即可体验。</p>
<p>!<a href="https://img.alicdn.com/imgextra/i2/O1CN01tTGNxM25zwAC9ZSAA_!!6000000007598-2-tps-400-400.png">https://img.alicdn.com/imgextra/i2/O1CN01tTGNxM25zwAC9ZSAA_!!6000000007598-2-tps-400-400.png</a></p>
<p>浏览器插件</p>
<p>适用于Chrome、Edge浏览器，点击此处安装插件。<a href="https://tingwu.aliyun.com/helpcenter/9ba338">https://tingwu.aliyun.com/helpcenter/9ba338</a></p>
<h2 id="通义听悟能为我做什么？">通义听悟能为我做什么？</h2>
<h3 id="解放双手，专注聆听">解放双手，专注聆听</h3>
<p>实时语音转文字，多语言同步翻译，1 小时音视频 5 分钟转写，精准区分发言人</p>
<h3 id="智能总结，高效回顾">智能总结，高效回顾</h3>
<p>关键信息一清二楚，全文总结一目了然，议程待办了如指掌，问答内容一览无余</p>
<h3 id="快捷整理，轻松导出">快捷整理，轻松导出</h3>
<p>高效有序整理笔记，多种格式一键导出，本地、云盘存储随意挑，信息安全更可靠</p>
<h3 id="多元场景，即时记录">多元场景，即时记录</h3>
<p>网页、插件、小程序数据同步，使用方式丰富多样，一键标记关键信息，捕捉你的奇思妙想</p>
<h2 id="一分钟了解通义听悟">一分钟了解通义听悟</h2>
<p>💡带你1分钟快速了解通义听悟通义听悟支持在会议、课程、访谈、培训等场景下实时转录和音视频转文字，智能生成总结，实时翻译打破跨语言沟通障碍。通义听悟还支持快速标记关键信息，识别结果和笔记能够轻松导出至本地或阿里云盘知识管理更高效。</p>
<p>下面一起来了解通义听悟的核心能力吧～</p>
<h3 id="实时语音转写，生成智能记录，搜索定位助力高效回顾">实时语音转写，生成智能记录，搜索定位助力高效回顾</h3>
<ul>
<li>开启实时记录，完整沉淀沟通内容，精准快捷生成记录，音字对应播放</li>
<li>支持自主检索关键词，精准定位核心信息，轻松回顾会话重点</li>
</ul>
<p>!<a href="https://img.alicdn.com/imgextra/i1/O1CN01IvWA1f21Ez5QQRNLc_!!6000000006954-1-tps-2874-1578.gif">https://img.alicdn.com/imgextra/i1/O1CN01IvWA1f21Ez5QQRNLc_!!6000000006954-1-tps-2874-1578.gif</a></p>
<p>!<a href="https://img.alicdn.com/imgextra/i3/O1CN01Ujd3Jr1rQl6q24H2Q_!!6000000005626-1-tps-2874-1580.gif">https://img.alicdn.com/imgextra/i3/O1CN01Ujd3Jr1rQl6q24H2Q_!!6000000005626-1-tps-2874-1580.gif</a></p>
<h3 id="文件转写，海量文件同时上传，帮你省时又省力">文件转写，海量文件同时上传，帮你省时又省力</h3>
<ul>
<li>会议、学习、访谈等音视频文件快速上传，同时可上传50个本地文件，也可以上传阿里云盘中的文件</li>
<li>支持自动区分发言人，转写结果自动保存在「我的记录」中，方便随时查看回顾</li>
</ul>
<p>!<a href="https://img.alicdn.com/imgextra/i2/O1CN014mOsYB22ITjNYEkN9_!!6000000007097-1-tps-1920-1080.gif">https://img.alicdn.com/imgextra/i2/O1CN014mOsYB22ITjNYEkN9_!!6000000007097-1-tps-1920-1080.gif</a></p>
<p>!<a href="https://img.alicdn.com/imgextra/i1/O1CN015o2uwN1mriLk5mN7K_!!6000000005008-1-tps-1920-1080.gif">https://img.alicdn.com/imgextra/i1/O1CN015o2uwN1mriLk5mN7K_!!6000000005008-1-tps-1920-1080.gif</a></p>
<p>!<a href="https://img.alicdn.com/imgextra/i1/O1CN01gvIMfr1rGgOdejJBl_!!6000000005604-1-tps-1920-1080.gif">https://img.alicdn.com/imgextra/i1/O1CN01gvIMfr1rGgOdejJBl_!!6000000005604-1-tps-1920-1080.gif</a></p>
<h3 id="实时翻译，支持中英互译，跨语言协作流畅自如">实时翻译，支持中英互译，跨语言协作流畅自如</h3>
<ul>
<li>实时转写中和结束后，支持一键开启中英互译，打破语言壁垒，轻松实现无障碍沟通</li>
</ul>
<p>!<a href="https://img.alicdn.com/imgextra/i4/O1CN01xHe6gz1VhJswhi4O7_!!6000000002684-1-tps-2874-1580.gif">https://img.alicdn.com/imgextra/i4/O1CN01xHe6gz1VhJswhi4O7_!!6000000002684-1-tps-2874-1580.gif</a></p>
<h3 id="快速标记，高亮重点、问题、待办，重点信息一目了然">快速标记，高亮重点、问题、待办，重点信息一目了然</h3>
<ul>
<li>支持高亮标记重点、问题、待办事项，支持筛选和批量摘录，回顾整理更清晰</li>
</ul>
<p>!<a href="https://img.alicdn.com/imgextra/i3/O1CN01uPL8E11UdMqkZ3lnr_!!6000000002540-1-tps-2874-1578.gif">https://img.alicdn.com/imgextra/i3/O1CN01uPL8E11UdMqkZ3lnr_!!6000000002540-1-tps-2874-1578.gif</a></p>
<p>!<a href="https://img.alicdn.com/imgextra/i1/O1CN01le0qDG1FPsxL2HIx9_!!6000000000480-1-tps-1920-1080.gif">https://img.alicdn.com/imgextra/i1/O1CN01le0qDG1FPsxL2HIx9_!!6000000000480-1-tps-1920-1080.gif</a></p>
<h3 id="轻松导出，丰富内容任你挑，多样格式供你选">轻松导出，丰富内容任你挑，多样格式供你选</h3>
<ul>
<li>支持导出原文、笔记、音视频和译文，可勾选多项批量导出</li>
<li>多种导出文档格式：原文和译文均支持 word、pdf 和 srt 字幕文件导出</li>
</ul>
<p>!<a href="https://img.alicdn.com/imgextra/i1/O1CN01daGgMi24CBWVvcopb_!!6000000007354-0-tps-2872-1628.jpg">https://img.alicdn.com/imgextra/i1/O1CN01daGgMi24CBWVvcopb_!!6000000007354-0-tps-2872-1628.jpg</a></p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://tingwu.aliyun.com/">通义听悟 - 你的工作学习AI助手 - https://tingwu.aliyun.com/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>通义听悟</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>通义听悟</tag>
      </tags>
  </entry>
  <entry>
    <title>[Awosome Software] Z-Library 电子书网站的客户端 ZLibrary</title>
    <url>/2023/03/18/Awosome-Software/Z-Library/z-library-e-book-website-desktop-zlibrary/</url>
    <content><![CDATA[<h1>Z-Library 电子书网站的客户端 ZLibrary</h1>
<p>在当今的数字化时代，随着互联网的普及，获取知识和学习资料变得越来越便捷。电子书网站在这个过程中扮演着举足轻重的角色，其中，Z-Library（电子书网站）就是一个值得关注的优秀平台。</p>
<p>由于网络的限制以及注册登录限制，使用 Z-Library 并不太方便。有热心网友制作了 Z-Library 的客户端 ZLibrary。搜索和下载电子书籍非常方便。</p>
<span id="more"></span>
<p>Z-Library是一个全球最大的免费电子书资源库，拥有超过数百万本电子书和论文。这个网站的宗旨是为广大读者提供免费、高质量的电子书，使他们能够随时随地进行自我学习和提升。Z-Library汇集了众多领域的书籍，包括科学、技术、文学、艺术、历史等，涵盖了世界各地的著名出版社和作者的作品。</p>
<p>Z-Library的界面设计简洁，用户可以轻松地在网站上进行搜索和下载。通过输入关键词、书名、作者或ISBN，用户便可在短时间内找到所需的书籍。此外，Z-Library还提供了丰富的筛选功能，如按照出版日期、语言、文件格式等进行筛选，方便用户快速找到心仪的书籍。</p>
<p>值得一提的是，Z-Library支持多种常见的电子书格式，如PDF、ePub、Mobi等，适用于不同类型的电子阅读器和设备。用户可以根据个人需求和设备情况选择合适的格式进行下载。</p>
<p>然而，Z-Library也面临着一些版权方面的争议。由于其提供免费电子书的模式，可能会对作者和出版商的权益造成影响。因此，在使用Z-Library时，请务必遵守相关法律法规，尊重知识产权。</p>
<p><img src="Z-Library%20%E7%94%B5%E5%AD%90%E4%B9%A6%E7%BD%91%E7%AB%99%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%20ZLibrary%20a20545c7269c41fea3dcd365acd58206/ZLibrary.jpeg" alt="ZLibrary.jpeg"></p>
<p>下载链接：</p>
<p>Linux</p>
<p><a href="https://github.com/tw93/Pake/releases/download/V1.0.3/ZLibrary_amd64.AppImage">ZLibrary_amd64.AppImage - https://github.com/tw93/Pake/releases/download/V1.0.3/ZLibrary_amd64.AppImage</a></p>
<p><a href="https://github.com/tw93/Pake/releases/download/V1.0.3/ZLibrary_amd64.deb">ZLibrary_amd64.deb - https://github.com/tw93/Pake/releases/download/V1.0.3/ZLibrary_amd64.deb</a></p>
<p>maOS</p>
<p><a href="https://github.com/tw93/Pake/releases/download/V1.0.3/ZLibrary.dmg">ZLibrary.dmg - https://github.com/tw93/Pake/releases/download/V1.0.3/ZLibrary.dmg</a></p>
<p>Windows</p>
<p><a href="https://github.com/tw93/Pake/releases/download/V1.0.3/ZLibrary_x64.msi">ZLibrary_x64.msi - https://github.com/tw93/Pake/releases/download/V1.0.3/ZLibrary_x64.msi</a></p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://github.com/tw93/Pake/releases/tag/V1.0.3">ZLibrary - Release V1.0.3 · tw93/Pake - https://github.com/tw93/Pake/releases/tag/V1.0.3</a></p>
<p>[2] <a href="https://github.com/tw93/Pake">tw93/Pake: 🤱🏻 Turn any webpage into a desktop app with Rust. 🤱🏻 很简单的用 Rust 打包网页生成很小的桌面 App - https://github.com/tw93/Pake</a></p>
]]></content>
      <categories>
        <category>Awosome Software</category>
        <category>Z-Library</category>
        <category>ZLibrary</category>
      </categories>
      <tags>
        <tag>E-Book</tag>
        <tag>Awosome Software</tag>
        <tag>Z-Library</tag>
        <tag>ZLibrary</tag>
      </tags>
  </entry>
  <entry>
    <title>[Awosome Software] asdf: 统一管理多版本的软件工具/编程语言/运行环境</title>
    <url>/2022/07/09/Awosome-Software/asdf/asdf-Getting-Started/</url>
    <content><![CDATA[<h1>asdf: 统一管理多版本的软件工具/编程语言/运行环境</h1>
<p>asdf 是软件工具/编程语言/运行环境版本管理器。比 <code>nvm</code>(Node.js)、<code>rvm</code>(Ruby)等版本管理器功能更强大，支持范围更广，完全可以替换它们。</p>
<p>本文介绍在 macOS 上安装 asdf，并通过 asdf Node.js 插件安装 Node.js 多版本。</p>
<h2 id="推荐理由">推荐理由</h2>
<p>CloudoLife 推荐使用 asdf 统一管理不同工具/编程语言/运行环境多版本。推荐理由：</p>
<ul>
<li>
<p><strong>简单性</strong>，只需要安装 asdf 和对应工具/编程语言/运行环境的插件，无需为不同的工具/编程语言/运行环境安装其他多版本管理工具。</p>
</li>
<li>
<p><strong>一致性</strong>，使用相同的 asdf 基本命令和配置，可以统一管理不同工具/编程语言/运行环境多版本，按您所需，灵活熟练切换不同版本。</p>
</li>
<li>
<p><strong>多样性</strong>，官方和社区插件已经支持多达数百种工具/编程语言/运行环境，几乎涵盖到所有工具/编程语言/运行环境。</p>
</li>
<li>
<p><strong>及时性</strong>，插件支持的工具/编程语言/运行环境与上游保持同步，版本更新非常及时，非常容易尝试新版本。</p>
</li>
</ul>
<span id="more"></span>
<h2 id="项目简介">项目简介</h2>
<p>asdf 是一个工具/运行环境（如 Dart, Elixir, Flutter, Golang (Go), Java, Node.js, Python, Ruby 等）版本管理器。所有的工具版本定义都包含在一个文件（<code>.tool-versions</code>）中，你可以将配置文件 <code>.tool-versions</code> 放在项目的 Git 存储库中以便于和团队其他成员共享，从而确保每个人都使用<strong>完全</strong>相同的工具版本。</p>
<p>传统工作方式需要多个命令行版本管理器（如 <code>nvm</code>, <code>rvm</code> 等等），而且每个管理器都有其不同的 API、配置文件和实现方式（比如，<code>$PATH</code> 操作、shim、环境变量等等）。asdf 提供单个交互方式和配置文件来简化开发工作流程，并可通过简单的插件接口扩展到所有工具和运行环境<br>
。</p>
<h2 id="它是如何工作的">它是如何工作的</h2>
<p>一旦 asdf 核心在 Shell 配置中设置好之后，你可以安装插件来管理特定的工具。当通过插件安装工具时，安装的可执行程序会为每个可执行程序创建 <a href="https://zh.wikipedia.org/wiki/%E5%9E%AB%E7%89%87_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)">shimopen in new window</a>。当你尝试运行其中一个可执行程序时，将运行 shim，从而允许 asdf 识别 <code>.tool-versions</code> 文件中设置的工具版本并执行该版本。</p>
<h2 id="为什么使用-asdf？">为什么使用 asdf？</h2>
<p>asdf 确保团队可以使用完全相同的工具版本，通过插件系统支持很多工具，以及作为 Shell 配置中包含的单个 Shell 脚本的 简单性和熟悉性。</p>
<h2 id="插件列表">插件列表</h2>
<p>除 Dart, Flutter, Golang, Java, Node.js, Python, Ruby, Rust 等常见插件外，asdf 官方和社区已经为不同的软件工具/编程语言/运行环境提供 100+ 插件。而且新的插件还在陆续开发中…</p>
<p>查看 <a href="https://github.com/asdf-vm/asdf-plugins#plugin-list">Plugin List | asdf-vm/asdf-plugins: Central plugin repository for asdf - https://github.com/asdf-vm/asdf-plugins#plugin-list</a> 了解 asdf 支持的插件。</p>
<h2 id="快速入门">快速入门</h2>
<p>asdf 安装过程包括：</p>
<ul>
<li>
<p>安装依赖</p>
</li>
<li>
<p>下载 asdf 核心</p>
</li>
<li>
<p>安装 asdf</p>
</li>
<li>
<p>为每一个你想要管理的工具/运行环境安装插件</p>
</li>
<li>
<p>安装工具/运行环境的一个版本</p>
</li>
<li>
<p>通过 <code>.tool-versions</code> 配置文件设置全局和项目版本</p>
</li>
</ul>
<p>接下来以 macOS 操作系统、Homebrew 包管理器、Oh My Zsh Shell 命令行配置工具为例，介绍：</p>
<ul>
<li>
<p>如何安装 asdf 以及所需要的依赖</p>
</li>
<li>
<p>如何安装 Node.js 最新运行环境</p>
</li>
<li>
<p>如何安装 Node.js 其他版本运行环境</p>
</li>
</ul>
<h3 id="Hombrew-安装-asdf-以及所需要的依赖">Hombrew 安装 asdf 以及所需要的依赖</h3>
<p>Homebrew 是一款 macOS 操作系统平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令 <code>brew &lt;subcommand&gt;</code>，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p>
<p>访问<a href="https://brew.sh/">The Missing Package Manager for macOS (or Linux) — Homebrew - https://brew.sh/</a>了解更多信息。</p>
<p>得益于功能强大的 Homebrew 包管理器，Homebrew 安装 asdf 时将会自动安装所需要的依赖。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install asdf</span><br></pre></td></tr></table></figure>
<h3 id="包管理器-和-Oh-My-Zsh-Shell-命令行配置">包管理器 和 Oh My Zsh Shell 命令行配置</h3>
<p>Oh My Zsh 是基于 zsh 命令行的一个扩展工具集，提供了丰富的扩展功能。它是一种全新的工作方式。它基于 zsh 命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。</p>
<p>访问<a href="https://ohmyz.sh/">Oh My Zsh - a delightful &amp; open source framework for Zsh - https://ohmyz.sh/</a>了解更多信息。</p>
<p>使用以下命令将 <code>asdf.sh</code> 加入到 <code>~/.zshrc</code> 文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;\n. $(brew --prefix asdf)/libexec/asdf.sh&quot; &gt;&gt; $&#123;ZDOTDIR:-~&#125;/.zshrc</span><br></pre></td></tr></table></figure>
<p>或者 使用 ZSH 框架插件，比如 <a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/asdf">asdf for oh-my-zsh - https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/asdf</a> 将会使脚本生效并安装补全功能。</p>
<p>补全功能可以被 ZSH 框架 asdf 或者 <a href="https://docs.brew.sh/Shell-Completion#configuring-completions-in-zsh">按照 Homebrew 的指引 - https://docs.brew.sh/Shell-Completion#configuring-completions-in-zsh</a> 完成配置。如果你正在使用 ZSH 框架，有关的 asdf 插件或许需要更新才能通过 fpath 正确地使用最新的 ZSH 补全功能。Oh-My-ZSH asdf 插件还在更新中，请查看 <a href="https://asdf-vm.com/zh-hans/guide/getting-started.html#_3-%E5%AE%89%E8%A3%85-asdf:~:text=%E4%B8%AD%EF%BC%8C%E8%AF%B7%E6%9F%A5%E7%9C%8B-,ohmyzsh/ohmyzsh%238837,open%20in%20new%20window,-%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E3%80%82">ohmyzsh/ohmyzsh#8837 - https://asdf-vm.com/zh-hans/guide/getting-started.html#_3-%E5%AE%89%E8%A3%85-asdf:~:text=%E4%B8%AD%EF%BC%8C%E8%AF%B7%E6%9F%A5%E7%9C%8B-,ohmyzsh/ohmyzsh%238837,open%20in%20new%20window,-%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E3%80%82</a>了解更多。</p>
<p>asdf 脚本需要在设置好的 <code>$PATH</code> 之后和已经生效的框架（比如 oh-my-zsh 等等）之后的位置生效。</p>
<p>通常打开一个新的终端标签页来重启你的 <code>shell</code> 让 <code>PATH</code> 更改即时生效。</p>
<p>或者在当前窗口运行 <code>source ~/.zshrc</code> 让 <code>PATH</code> 更改即时生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> ~/.zshrc</span></span><br></pre></td></tr></table></figure>
<h3 id="核心安装完成！">核心安装完成！</h3>
<p>这样就完成了 asdf 核心的安装 🎉</p>
<p>asdf 仅在你安装插件、工具和管理它们的版本时才开始真正发挥作用。请继续阅读下面的指南来了解这些是如何做到的。</p>
<h3 id="安装插件">安装插件</h3>
<p>出于演示目的，我们将通过 <code>asdf-nodejs</code> 插件来安装和设置 Node.js。</p>
<h4 id="插件依赖">插件依赖</h4>
<p>每个插件都有依赖，所以我们需要确认应该列举了这些依赖的插件源码。对于 asdf-nodejs 来说，它们是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install gpg gawk</span><br></pre></td></tr></table></figure>
<p>我们应该提前安装这些依赖，因为有些插件有 <code>post-install</code> 钩子。</p>
<h4 id="安装插件-2">安装插件</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">asdf plugin add nodejs https://github.com/asdf-vm/asdf-nodejs.git</span><br></pre></td></tr></table></figure>
<p>访问<a href="https://github.com/asdf-vm/asdf-nodejs">asdf-vm/asdf-nodejs: Node.js plugin for asdf version manager - https://github.com/asdf-vm/asdf-nodejs</a>了解更多信息。</p>
<h4 id="安装指定版本">安装指定版本</h4>
<p>现在我们已经有了 Node.js 插件，所以我们可以开始安装某个版本了。</p>
<p>我们通过 <code>asdf list all nodejs</code> 可以看到所有可用的版本或者通过 <code>asdf list all nodejs 14</code> 查看版本子集。</p>
<p>我们将只安装最新可用的 <code>latest</code> 版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">asdf install nodejs latest</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>
asdf 强制使用准确的版本。<code>latest</code> 是一个通过 asdf 来解析到执行时刻的实际版本号的辅助工具。</p>
</blockquote>
<p>可以安装可用的 <code>15.10.0</code> 版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">asdf install nodejs 15.10.0</span><br></pre></td></tr></table></figure>
<h3 id="设置默认版本">设置默认版本</h3>
<p>asdf 在从当前工作目录一直往上到 <code>$HOME</code> 目录的所有 <code>.tool-versions</code> 文件中进行工具的版本查找。查找在执行 asdf 管理的工具时实时发生。</p>
<blockquote>
<p>警告<br>
如果没有为工具找到指定的版本，则会出现错误。<code>asdf current</code> 将显示当前目录中的工具和版本解析结果，或者不存在，以便你可以观察哪些工具将无法执行。</p>
</blockquote>
<h4 id="全局">全局</h4>
<p>全局默认配置在 <code>~/.tool-versions</code> 文件中进行管理。使用以下命令可以设置一个全局版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">asdf global nodejs latest</span><br></pre></td></tr></table></figure>
<p><code>~/.tool-versions</code> 文件内容将会如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.tool-versions</span></span><br><span class="line">nodejs 16.5.0</span><br></pre></td></tr></table></figure>
<p>某些操作系统已经有一些由系统而非 asdf 安装和管理的工具了，python 就是一个常见的例子。你需要告诉 asdf 将管理权还给系统。版本参考部分 将会引导你。</p>
<h4 id="本地">本地</h4>
<p>本地版本被定义在 <code>./.tool-versions</code> 文件中（当前工作目录）。通常，这将会是一个项目的 Git 存储库。当在你想要的目录执行：</p>
<p>如果当前工作目录没有 <code>.tool-versions</code>，您可以手动创建:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> .tool-versions</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">asdf local nodejs latest</span><br></pre></td></tr></table></figure>
<p><code>./.tool-versions</code> 文件内容将会如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ./.tool-versions</span></span><br><span class="line">nodejs 16.5.0</span><br></pre></td></tr></table></figure>
<h2 id="使用现有工具版本文件">使用现有工具版本文件</h2>
<p>asdf 支持从其他版本管理器的现有版本文件中迁移过来，比如 <code>rbenv</code> 的 <code>.ruby-version</code> 文件。这在每个插件中都原生支持。</p>
<p><code>asdf-nodejs</code> 支持从 <code>.nvmrc</code> 和 <code>.node-version</code> 文件进行迁移。为了启用此功能，请在 asdf 配置文件 <code>$HOME/.asdfrc</code> 中加入以下内容：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">legacy_version_file</span> = <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<p>请查看 <a href="https://asdf-vm.com/zh-hans/manage/configuration.html">配置 - https://asdf-vm.com/zh-hans/manage/configuration.html</a> 参考页面可以了解更多配置选项。</p>
<h2 id="完成指南！">完成指南！</h2>
<p>恭喜你完成了 asdf 的快速上手 🎉 你现在可以管理你的项目的 <code>nodejs</code> 版本了。对于项目中的其他工具/运行环境可以执行类似步骤即可！</p>
<h2 id="更多命令">更多命令</h2>
<p>asdf 还有更多命令需要熟悉，你可以通过运行 <code>asdf --help</code> 或者 asdf 来查看它们。命令主要分为三类：</p>
<ul>
<li>
<p>asdf 核心</p>
</li>
<li>
<p>插件</p>
</li>
<li>
<p>（工具的）版本</p>
</li>
</ul>
<p>asdf 中所有可用命令的列表。这个列表就是 <code>asdf help</code> 命令的打印内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">asdf</span></span><br><span class="line">MANAGE PLUGINS</span><br><span class="line">asdf plugin add &lt;name&gt; [&lt;git-url&gt;]      从插件仓库添加插件或者，添加一个 Git repo 作为插件</span><br><span class="line">asdf plugin list [--urls] [--refs]      列出已安装的插件。可选择显示 git url 和 git-ref</span><br><span class="line">asdf plugin list all                    列出所有在 asdf-plugins 上注册的 List 插件带有 URL 的存储库</span><br><span class="line">asdf plugin remove &lt;name&gt;               删除插件和软件包版本</span><br><span class="line">asdf plugin update &lt;name&gt; [&lt;git-ref&gt;]   更新插件到最新提交默认分支或特定的 git-ref</span><br><span class="line">asdf plugin update --all                更新所有插件到最新提交默认分支</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MANAGE PACKAGES</span><br><span class="line">asdf install                            安装所有在 .tool-versions 文件中列出的软件包版本</span><br><span class="line">asdf install &lt;name&gt;                     安装一个在 .tool-versions 文件中列出的特定软件包版本</span><br><span class="line">asdf install &lt;name&gt; &lt;version&gt;           安装特定版本的包</span><br><span class="line">asdf install &lt;name&gt; latest[:&lt;version&gt;]  安装最新的稳定版本包，或可选版本，安装最新的稳定版本，或以给定的字符串开头</span><br><span class="line">asdf uninstall &lt;name&gt; &lt;version&gt;         删除特定版本的包</span><br><span class="line">asdf current                            显示当前版本集或正在用于所有包</span><br><span class="line">asdf current &lt;name&gt;                     显示当前版本集或正在用于包装</span><br><span class="line">asdf where &lt;name&gt; [&lt;version&gt;]           示已安装的安装路径或当前版本</span><br><span class="line">asdf which &lt;command&gt;                    显示可执行文件的路径</span><br><span class="line">asdf local &lt;name&gt; &lt;version&gt;             设置包本地版本</span><br><span class="line">asdf local &lt;name&gt; latest[:&lt;version&gt;]    将包本地版本设置为提供的最新版本</span><br><span class="line">asdf global &lt;name&gt; &lt;version&gt;            设置包全局版本</span><br><span class="line">asdf global &lt;name&gt; latest[:&lt;version&gt;]   将包全局版本设置为提供的最新版本</span><br><span class="line">asdf shell &lt;name&gt; &lt;version&gt;             将包版本设置为当前 shell 中的 `ASDF_$&#123;LANG&#125;_VERSION`</span><br><span class="line">asdf latest &lt;name&gt; [&lt;version&gt;]          显示包的最新稳定版本</span><br><span class="line">asdf latest --all                       显示所有最新的稳定版本软件包以及是否已安装</span><br><span class="line">asdf list &lt;name&gt; [version]              列出软件包的已安装版本和可选择过滤版本</span><br><span class="line">asdf list all &lt;name&gt; [&lt;version&gt;]        列出包的所有版本和可选择过滤返回的版本</span><br><span class="line">asdf help &lt;name&gt; [&lt;version&gt;]            插件和工具的输出文档</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UTILS</span><br><span class="line">asdf exec &lt;command&gt; [args...]           为当前版本执行命令 shim</span><br><span class="line">asdf env &lt;command&gt; [util]               在用于命令 shim 执行的环境</span><br><span class="line">asdf info                               打印操作系统、Shell 和 ASDF 调试信息</span><br><span class="line">asdf reshim &lt;name&gt; &lt;version&gt;            为特定包的版本重新创建 shims</span><br><span class="line">asdf shim-versions &lt;command&gt;            列出插件和版本提供命令</span><br><span class="line">                                        provide a command</span><br><span class="line">asdf update                             更新到最新的稳定版本</span><br><span class="line">asdf update --head                      将 asdf 更新到 master 分支上的最新版本</span><br><span class="line"></span><br><span class="line">RESOURCES</span><br><span class="line">GitHub: https://github.com/asdf-vm/asdf</span><br><span class="line">Docs:   https://asdf-vm.com</span><br></pre></td></tr></table></figure>
<h2 id="常见问题-FAQs">常见问题 FAQs</h2>
<h3 id="brew-upgrade-asdf-升级新版本后-No-such-file-or-directory-没有这样的文件或目录">brew upgrade asdf 升级新版本后 No such file or directory 没有这样的文件或目录</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew upgrade asdf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">node -v</span></span><br><span class="line">~/.asdf/shims/node: line 8: /usr/local/Cellar/asdf/0.9.0/libexec/bin/asdf: No such file or directory</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.asdf/shims/rails</span></span><br><span class="line">exec /usr/local/Cellar/asdf/0.9.0/libexec/bin/asdf exec &quot;node&quot; &quot;$@&quot;</span><br></pre></td></tr></table></figure>
<p>先将 <code>~/.asdf/shims</code> 备份，然后运行 <code>asdf reshim</code> 重新生成最新的 <code>~/.asdf/shims</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> ~/.asdf/shims ~./asdf/shims.bak</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">asdf reshim</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$ asdf reshim node</span></span><br></pre></td></tr></table></figure>
<h3 id="command-not-found-pnpm-命令未找到：pnpm">command not found: pnpm 命令未找到：pnpm</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i pnpm</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pnpm -v</span></span><br><span class="line">zsh: command not found: pnpm</span><br></pre></td></tr></table></figure>
<p>原因可能是安装 pnpm 时没有使用 <code>-g</code> 选项安装。</p>
<p>记得使用 <code>-g</code> 选项将 <code>pnpm</code> 命令安装到 <code>$HOME/.asdf/shims</code> 目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g pnpm</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pnpm -v</span></span><br><span class="line">7.3.0</span><br></pre></td></tr></table></figure>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://asdf-vm.com/">Home | asdf - https://asdf-vm.com/</a></p>
<p>[2] <a href="https://brew.sh/">The Missing Package Manager for macOS (or Linux) — Homebrew - https://brew.sh/</a></p>
<p>[3] <a href="https://ohmyz.sh/">Oh My Zsh - a delightful &amp; open source framework for Zsh - https://ohmyz.sh/</a></p>
<p>[4] <a href="https://github.com/asdf-vm/asdf-nodejs">asdf-vm/asdf-nodejs: Node.js plugin for asdf version manager - https://github.com/asdf-vm/asdf-nodejs</a></p>
<p>[5] <a href="https://nodejs.org/en/">Node.js - https://nodejs.org/en/</a></p>
]]></content>
      <categories>
        <category>Awosome Software</category>
        <category>asdf</category>
      </categories>
      <tags>
        <tag>brew</tag>
        <tag>Homebrew</tag>
        <tag>macOS</tag>
        <tag>Awosome Software</tag>
        <tag>shim</tag>
        <tag>zsh</tag>
        <tag>Oh My Zsh</tag>
        <tag>Node.js</tag>
        <tag>node</tag>
        <tag>asdf</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云 Docker 镜像加速</title>
    <url>/2022/04/09/Cloud-Native/Container/Aliyun-Docker-Images-Acceleration/</url>
    <content><![CDATA[<h1>阿里云 Docker 镜像加速</h1>
<p>由于网络原因，国内下载一个 Docker 官方镜像可能会需要很长的时间，甚至下载失败。为此，阿里云容器镜像服务 ACR 提供了 Docker 官方的镜像站点，从而加速 Docker 官方镜像的下载。</p>
<h2 id="前置条件">前置条件</h2>
<p>注册并登录阿里云账号。查看<a href="https://help.aliyun.com/document_detail/69335.html">注册账号 - https://help.aliyun.com/document_detail/69335.html</a>了解更多信息。</p>
<p>如果已经有一个阿里云账号，也可以创建一个 RAM 用户。查看<a href="https://help.aliyun.com/document_detail/93720.html">创建RAM用户 - https://help.aliyun.com/document_detail/93720.html</a>了解更多信息。</p>
<p>开通阿里云容器镜像服务 ACR。以华东2（上海）为例，地址为<a href="https://cr.console.aliyun.com/cn-shanghai/instances/">https://cr.console.aliyun.com/cn-shanghai/instances/</a>。</p>
<h2 id="获取镜像加速器地址">获取镜像加速器地址</h2>
<p>阿里云容器镜像服务 ACR 会为每一个账号（阿里云账号或 RAM 用户）生成一个镜像加速器地址，配置镜像加速器前，您需要获取镜像加速器地址。</p>
<p>登录容器镜像服务控制台，，在左侧导航栏选择 镜像工具 &gt; 镜像加速器，在镜像加速器页面获取镜像加速地址。</p>
<p>镜像加速地址格式一般为 <code>https://&lt;随机字符串&gt;.mirror.aliyuncs.com</code></p>
<h2 id="使用镜像加速器地址">使用镜像加速器地址</h2>
<h3 id="Docker">Docker</h3>
<h4 id="配置-Linux-Docker-daemon">配置 Linux Docker daemon</h4>
<p>在 Linux 操作系统环境手动启动 <code>dockerd</code> 时传递 <code>--registry-mirror</code> 选项，或者编辑 <code>/etc/docker/daemon.json</code> 并添加 <code>registry-mirrors</code> 键和值，以使更改持久化。</p>
<blockquote>
<p>如果 <code>/etc/docker</code> 目录不存在，需要手工创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">mkdir</span> -p /etc/docker</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://&lt;随机字符串&gt;.mirror.aliyuncs.com&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>保存文件并重新加载 Docker 以使更改生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure>
<h4 id="配置-macOS-Windows-Docker-Desktop">配置 macOS / Windows Docker Desktop</h4>
<p>选择 Docker Engine</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;experimental&quot;: true,</span><br><span class="line">    &quot;debug&quot;: true,</span><br><span class="line"><span class="addition">+     &quot;registry-mirrors&quot;: [&quot;https://&lt;随机字符串&gt;.mirror.aliyuncs.com&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检查镜像加速器地址">检查镜像加速器地址</h4>
<p>在命令行执行 <code>docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker info</span></span><br><span class="line">...</span><br><span class="line">Registry Mirrors:</span><br><span class="line">https://&lt;随机字符串&gt;.mirror.aliyuncs.com</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="Containerd">Containerd</h3>
<p>当您使用 Containerd 作为容器运行时，需要按照以下内容修改 Containerd 的 <code>cri</code> 配置，才能让 Pod 的镜像使用镜像加速器。配置路径一般为 <code>/etc/containerd/config.toml</code>。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">[plugins.cri]</span><br><span class="line">  [plugins.cri.registry]</span><br><span class="line"><span class="addition">+     [plugins.cri.registry.mirrors]</span></span><br><span class="line"><span class="addition">+       [plugins.cri.registry.mirrors.&quot;docker.io&quot;]</span></span><br><span class="line"><span class="addition">+         endpoint = [&quot;https://&lt;随机字符串&gt;.mirror.aliyuncs.com&quot;]</span></span><br></pre></td></tr></table></figure>
<p>重启 Containerd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">enable</span> --now containerd</span></span><br></pre></td></tr></table></figure>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://www.alibabacloud.com/help/zh/container-registry/latest/accelerate-the-download-of-docker-official-images">官方镜像加速 - https://www.alibabacloud.com/help/zh/container-registry/latest/accelerate-the-download-of-docker-official-images</a></p>
<p>[2] <a href="https://docs.docker.com/registry/recipes/mirror/">Registry as a pull through cache | Docker Documentation - https://docs.docker.com/registry/recipes/mirror/</a></p>
<p>[3] <a href="https://cn.aliyun.com/product/acr">容器镜像服务_镜像构建_镜像授权_镜像托管-阿里云 - https://cn.aliyun.com/product/acr</a></p>
<p>[4] <a href="https://help.aliyun.com/document_detail/69335.html">注册账号 - https://help.aliyun.com/document_detail/69335.html</a></p>
<p>[5] <a href="https://help.aliyun.com/document_detail/93720.html">创建RAM用户 - https://help.aliyun.com/document_detail/93720.html</a></p>
<p>[6] <a href="https://github.com/containerd/containerd/blob/main/docs/getting-started.md">containerd/getting-started.md at main · containerd/containerd - https://github.com/containerd/containerd/blob/main/docs/getting-started.md</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Container</category>
        <category>Aliyun</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Containerd</tag>
        <tag>ACR</tag>
        <tag>Alibaba Cloud Container Registry</tag>
        <tag>Alibaba Cloud Container Registry (ACR)</tag>
        <tag>Alibaba Cloud</tag>
        <tag>Cloud Native</tag>
        <tag>Container</tag>
        <tag>Aliyun</tag>
      </tags>
  </entry>
  <entry>
    <title>[Ruby] Ruby Memoization 指南</title>
    <url>/2022/12/22/Programming-Language/Ruby/A-Guide-to-Memoization-in-Ruby/</url>
    <content><![CDATA[<h1>Ruby Memoization 指南</h1>
<blockquote>
<p>原文链接 <a href="https://blog.appsignal.com/2022/12/20/a-guide-to-memoization-in-ruby.html">A Guide to Memoization in Ruby | AppSignal Blog - https://blog.appsignal.com/2022/12/20/a-guide-to-memoization-in-ruby.html</a></p>
</blockquote>
<blockquote>
<p>中文翻译已获得 <a href="https://www.appsignal.com/">AppSignal - https://www.appsignal.com/</a> 和 <a href="https://blog.appsignal.com/authors/abiodun-olowode">Abiodun Olowode - https://blog.appsignal.com/authors/abiodun-olowode</a> 授权。</p>
</blockquote>
<p>Memoization 是一种缓存技术，可以使您的 Ruby 应用程序运行得更高效、更快。</p>
<p>在本文中，我们将探讨记忆化的好处以及何时在您的 Ruby 应用程序中使用它。我们还将研究一些要避免的 Memoization 使用错误。</p>
<p>让我们首先从代码优化开始——它是什么以及一些不同的可用优化技术。</p>
<span id="more"></span>
<h2 id="什么是代码优化？">什么是代码优化？</h2>
<p>代码优化是提高代码质量以使一段代码或程序更高效和更实用的过程。它的优势包括——但不限于：</p>
<ul>
<li>
<p>在昂贵的计算中减少内存消耗</p>
</li>
<li>
<p>执行速度快得多</p>
</li>
<li>
<p>有时，代码库的空间更少</p>
</li>
</ul>
<p>在应用程序的生命周期中，有时会出现实现上述某些目标的需求。如果您不知道从哪里开始代码优化，请尝试 Profiling！</p>
<h2 id="什么是-Profiling？">什么是 Profiling？</h2>
<p>Profiling 是指分析程序以测量其空间和时间复杂性。通过分析，我们可以获得以下信息：</p>
<ul>
<li>
<p>函数调用的频率和持续时间</p>
</li>
<li>
<p>与其他函数相比，一个函数所花费的程序执行时间百分比</p>
</li>
<li>
<p>每个函数的调用栈</p>
</li>
<li>
<p>成功加载 HTML 页面需要多少次数据库调用以及需要多长时间</p>
</li>
</ul>
<p>这些信息可以指导我们找到非常需要代码优化的地方。</p>
<h2 id="Ruby-和-Rails-的代码优化方法">Ruby 和 Rails 的代码优化方法</h2>
<p>一些 Ruby 和 Rails 代码优化技术包括：</p>
<ul>
<li>
<p><strong>摆脱 N+1 查询</strong> ——这有助于提高应用程序的速度。<a href="https://rubygems.org/gems/bullet/versions/6.1.0">Bullet - https://rubygems.org/gems/bullet</a>或<a href="https://rubygems.org/gems/prosopite/versions/1.0.8">Prosopite - https://rubygems.org/gems/prosopite</a> 可以在这里提供帮助。<a href="https://labs.factorialhr.com/posts/bullet-or-prosopite-for-nplus1">N+1 困境—— Bullet 还是 Prosopite？ - https://labs.factorialhr.com/posts/bullet-or-prosopite-for-nplus1</a>需要对两者进行简要比较。</p>
</li>
<li>
<p><strong>使用静态代码分析器</strong> ——这些可以减少内存消耗和代码库大小，因为我们会收到代码重复、未使用的变量或方法参数等的警报。示例包括<a href="https://rubocop.org/">Rubocop - https://rubocop.org/</a>和<a href="https://blog.appsignal.com/2022/10/19/improve-code-in-your-ruby-application-with-rubycritic.html">RubyCritic - https://blog.appsignal.com/2022/10/19/improve-code-in-your-ruby-application-with-rubycritic.html</a>。</p>
</li>
<li>
<p><strong>缓存</strong>- 存储在请求-响应周期中生成的内容，并在响应类似请求时重用它，以提高应用程序的速度。在 Rails 中，我们有页面缓存、片段缓存、动作缓存、低级缓存等等。</p>
</li>
<li>
<p><strong>选择合适的数据结构</strong>——某些数据结构在某些情况下比其他数据结构表现更好。因此，优化代码的一个好方法是针对每种情况使用最合适的数据结构，同时考虑它们的空间和时间复杂性。</p>
</li>
<li>
<p><strong>Memoization</strong>  - 通过减少执行某些计算的次数来提高速度。<br>
现在让我们把注意力转向记忆。</p>
</li>
</ul>
<h2 id="Ruby-Memoization-简介">Ruby Memoization 简介</h2>
<p>Memoization 是缓存方法结果的行为，以便下次调用该方法时，返回先前的结果（与执行重新计算相反）。这有助于在运行程序时节省时间。</p>
<p>让我们看一个涉及字谜的例子。</p>
<p>在下面的类中，我们创建了一个字典来将任何单词作为参数传递，并找到字谜。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dictionary</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">words</span></span><br><span class="line">		puts <span class="string">&quot;creating my dictionary&quot;</span></span><br><span class="line">		words = <span class="title class_">File</span>.readlines(<span class="string">&#x27;/usr/share/dict/words&#x27;</span>)</span><br><span class="line">		dictionary = <span class="title class_">Hash</span>.new &#123;|<span class="params">h,k</span>| h[k] = []&#125;</span><br><span class="line">		words.each <span class="keyword">do</span> |<span class="params">word</span>|</span><br><span class="line">			word = word.chomp</span><br><span class="line">			dictionary[word.chars.sort.join(<span class="string">&quot;&quot;</span>)] = word</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		dictionary</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">word</span>)</span><br><span class="line">		words[word.chars.sort.join(<span class="string">&quot;&quot;</span>)]</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>测试上面的类，我们得到：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">dictionary = <span class="title class_">Dictionary</span>.new</span><br><span class="line">dictionary.check(<span class="string">&#x27;rasp&#x27;</span>)</span><br><span class="line"><span class="comment"># creating my dictionary</span></span><br><span class="line">=&gt; <span class="string">&quot;spar&quot;</span></span><br><span class="line">dictionary.check(<span class="string">&#x27;kame&#x27;</span>)</span><br><span class="line"><span class="comment"># creating my dictionary</span></span><br><span class="line">=&gt; <span class="string">&quot;make&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，每次调用check方法，我们都会重新创建字典。这绝对不是最优的，因为字典不会改变。</p>
<p>如果我们只创建一次字典并在需要时使用它会怎么样？我们可以; 使用 Memoization 。Memoization 允许我们缓存之前创建的字典。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">words</span></span><br><span class="line">	<span class="variable">@words</span> |<span class="params"></span>|= <span class="keyword">begin</span></span><br><span class="line">		puts <span class="string">&quot;creating my dictionary&quot;</span></span><br><span class="line">		words = <span class="title class_">File</span>.readlines(<span class="string">&#x27;/usr/share/dict/words&#x27;</span>)</span><br><span class="line">		dictionary = <span class="title class_">Hash</span>.new &#123;|<span class="params">h,k</span>| h[k] = []&#125;</span><br><span class="line">		words.each <span class="keyword">do</span> |<span class="params">word</span>|</span><br><span class="line">			word = word.chomp</span><br><span class="line">			dictionary[word.chars.sort.join(<span class="string">&quot;&quot;</span>)] = word</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		dictionary</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>测试以上，我们得到：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">dict.check(<span class="string">&#x27;eat&#x27;</span>)</span><br><span class="line"><span class="comment">#creating my dictionary</span></span><br><span class="line">=&gt; <span class="string">&quot;tea&quot;</span></span><br><span class="line">dict.check(<span class="string">&#x27;kame&#x27;</span>)</span><br><span class="line">=&gt; <span class="string">&quot;make&quot;</span></span><br><span class="line">dict.check(<span class="string">&#x27;live&#x27;</span>)</span><br><span class="line">=&gt; <span class="string">&quot;vile&quot;</span></span><br></pre></td></tr></table></figure>
<p>如我们所见，字典创建一次，之后使用缓存版本。</p>
<p>让我们做一个基准测试，看看我们的程序因为 Memoization 而变得有多快。命名 <code>memoized_check</code>和 <code>check</code>：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&quot;benchmark&quot;</span></span><br><span class="line">dictionary = <span class="title class_">Dictionary</span>.new</span><br><span class="line">puts <span class="title class_">Benchmark</span>.measure &#123; <span class="number">10</span>.times &#123; dictionary.check(<span class="string">&#x27;rasp&#x27;</span>) &#125; &#125;</span><br><span class="line">puts <span class="title class_">Benchmark</span>.measure &#123; <span class="number">10</span>.times &#123; dictionary.memoized_check(<span class="string">&#x27;rasp&#x27;</span>) &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>我们得到以下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">5.771061   0.044656   5.815717 (  5.836218)</span><br><span class="line">0.563966   0.000016   0.563982 (  0.564909)</span><br></pre></td></tr></table></figure>
<p>这向我们展示了未记忆的版本需要<code>5.83</code>几秒钟，而记忆的版本需要几<code>0.56</code>秒钟，速度快了大约十倍。</p>
<h2 id="在-Ruby-应用程序中要避免的-Memoization-错误">在 Ruby 应用程序中要避免的 Memoization 错误</h2>
<p>现在让我们看看在使用 Memoization 时要避免的一些错误。</p>
<h3 id="忽略-False-或-Nil-返回">忽略 False 或 Nil 返回</h3>
<p>在方法的计算返回 false 或 nil 的情况下，无论何时调用该方法（即使 Memoization），每次调用都会导致重新计算。这是因为比较是使用<code>or</code>— 进行的，而在 Ruby 中，<code>nil</code>和<code>false</code>都是<code>false</code>值。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> |<span class="params"></span>| <span class="number">4</span>+<span class="number">5</span></span><br><span class="line">=&gt; <span class="number">2</span></span><br><span class="line"><span class="literal">nil</span> |<span class="params"></span>| <span class="number">4</span>+<span class="number">5</span></span><br><span class="line">=&gt; <span class="number">9</span></span><br><span class="line"><span class="literal">false</span> |<span class="params"></span>| <span class="number">4</span>+<span class="number">5</span></span><br><span class="line">=&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>Memoization using<code>||=</code>不考虑 false/nil 返回值，所以应该处理这种情况。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_computation</span></span><br><span class="line">	puts <span class="string">&quot;I am computing&quot;</span></span><br><span class="line">	<span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span></span><br><span class="line">	<span class="variable">@check</span> |<span class="params"></span>|= do_computation</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>调用check方法，我们得到如下结果：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">check</span><br><span class="line"><span class="comment"># I am computing</span></span><br><span class="line">=&gt; nil</span><br><span class="line">check</span><br><span class="line"><span class="comment"># I am computing</span></span><br><span class="line">=&gt; nil</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们可以确定变量是否已经定义。如果是这样，我们会在继续计算之前提前返回。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check</span></span><br><span class="line">	<span class="keyword">return</span> <span class="variable">@check</span> <span class="keyword">if</span> <span class="keyword">defined</span>?(<span class="variable">@check</span>)</span><br><span class="line">	<span class="variable">@check</span> |<span class="params"></span>|= do_computation</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这导致：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">check</span><br><span class="line"><span class="comment"># I am computing</span></span><br><span class="line">=&gt; nil</span><br><span class="line">check</span><br><span class="line">=&gt; nil</span><br></pre></td></tr></table></figure>
<h3 id="将参数传递给方法">将参数传递给方法</h3>
<p>另一个常见的错误是假设将参数传递给方法时，Memoization将以不同的方式工作。</p>
<p>假设方法的结果是使用 Memoization 的<code>||=</code>，但该结果取决于参数。如果这些参数改变，结果不会改变。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change_params</span>(<span class="params">num</span>)</span><br><span class="line">	<span class="variable">@params</span> |<span class="params"></span>|= num</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>让我们看看这里发生了什么：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">change_params(<span class="number">4</span>)</span><br><span class="line">=&gt; <span class="number">4</span></span><br><span class="line">change_params(<span class="number">8</span>)</span><br><span class="line">=&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>结果不会因为我们改变了参数而改变，坦率地说，考虑到 Memoization 的基本形式，这是预期的结果。</p>
<p>要处理此类情况，您必须熟悉：</p>
<ul>
<li>将参数存储为散列中的键</li>
<li>使用考虑所有不同情况的 gem 或模块来处理</li>
</ul>
<p>使用哈希：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change_params</span>(<span class="params">num</span>)</span><br><span class="line">	<span class="variable">@params_hash</span> |<span class="params"></span>|= &#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">@params_hash</span>.has_key?(num))</span><br><span class="line">		<span class="variable">@params_hash</span>[num]</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		puts <span class="string">&#x27;creating a new key-value pair&#x27;</span></span><br><span class="line">		<span class="variable">@params_hash</span>[num] = num</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>尝试一下，我们有：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">change_params(<span class="number">4</span>)</span><br><span class="line">creating a new key-value pair</span><br><span class="line">=&gt; <span class="number">4</span></span><br><span class="line">change_params(<span class="number">8</span>)</span><br><span class="line">creating a new key-value pair</span><br><span class="line">=&gt; <span class="number">8</span></span><br><span class="line">change_params(<span class="number">4</span>)</span><br><span class="line">=&gt; <span class="number">4</span></span><br><span class="line">change_params(<span class="number">8</span>)</span><br><span class="line">=&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>重写它的另一种方法如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change_params</span>(<span class="params">num</span>)</span><br><span class="line">	<span class="variable">@params_hash</span> |<span class="params"></span>|= &#123;&#125;</span><br><span class="line">	<span class="variable">@params_hash</span>[num] |<span class="params"></span>|= num</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>或者你可以使用 gem <a href="https://github.com/matthewrudy/memoist">Memoist - https://github.com/matthewrudy/memoist</a>。考虑到传递的参数，它处理缓存方法的结果。它还提供了一种刷新对象的当前值或整个缓存的方法。</p>
<h2 id="何时-Memoization-——何时不-Memoization">何时 Memoization ——何时不 Memoization</h2>
<p>要决定何时进行 Memoization，请注意以下几点：</p>
<h3 id="昂贵的操作">昂贵的操作</h3>
<p>假设一个昂贵的操作肯定会在一个类中多次调用并返回相同的结果。</p>
<p>我们可以将其移动到对象实例化时初始化的实例变量中（此时也完成了昂贵的操作）。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="built_in">attr_reader</span> <span class="symbol">:result</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">	<span class="variable">@result</span> = do_expensive_calculation</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>result</code>在类实例的整个生命周期中都可用，昂贵的计算只进行一次。</p>
<p>在这种情况下，我们不需要单独的方法来记忆<code>do_expensive_calculation</code>值。</p>
<p>一个可能不会发生的昂贵计算——但如果发生了，可能会发生不止一次（并返回相同的值）——是 Memoization 的一个很好的候选者。这意味着我们只<code>do_expensive_calculation</code>在需要时才缓存结果。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">expensive_calculation</span></span><br><span class="line">	<span class="variable">@expensive_calculation</span> |<span class="params"></span>|= do_expensive_calculation</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="分析潜在的性能改进">分析潜在的性能改进</h3>
<p>只有在我们进行了性能分析之后，才可能认为记忆是必要的。我们需要准确地确定实施的记忆实际上提高了性能（就像我们在<code>Dictionary</code>课堂上所做的那样）。</p>
<p>否则，我们可能会向代码库添加不必要的复杂性。确保与运行时的收益相比，记忆化引起的空间和代码复杂性较低。</p>
<h3 id="更改参数">更改参数</h3>
<p>如果用于计算的参数不断变化，则记忆化不是一个好的选择。</p>
<p>记忆化更适合纯函数，其返回值对于同一组参数是相同的。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculation</span>(<span class="params">a, b</span>)</span><br><span class="line">	a + b + <span class="title class_">Time</span>.now.to_i</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，假设我们确实缓存了方法结果。每次我们调用该方法时，我们缓存的值都是错误的，因为发生了<code>Time.now</code>变化。</p>
<h2 id="总结">总结</h2>
<p>在这篇文章中，我们探讨了 Memoization，就像每一种缓存技术一样，都有它的优点和缺点。在深入研究涉及 Memoization 的示例之前，我们首先研究了一系列代码优化技术。然后我们谈到了一些需要注意的错误。最后，我们探讨了 Memoization 何时有益以及何时避免。</p>
<p>当对类实例可用的方法执行 Memoization 时，Memoization 的结果仅在该对象的生命周期内可用。如果多个类实例（例如，多个 Web 请求）的结果相同，则类级别的 Memoization 通常是首选。</p>
<p>但是，这可能会在缓存失效方面增加更多的复杂性。使用缓存存储可能是缓存的更好替代方案，并且可以实现更好的优化。</p>
<p>在您决定使用它之前，您必须确定 Memoization 对于您的特定用例的利大于弊。</p>
<p>快乐记忆！</p>
<p><strong>PS 如果您想在 Ruby Magic 发布后立即阅读它们，请<a href="https://blog.appsignal.com/ruby-magic">订阅我们的 Ruby Magic 时事通讯，不要错过任何一篇文章 - https://blog.appsignal.com/ruby-magic</a>！</strong></p>
<h2 id="Abiodun-Olowode">Abiodun Olowode</h2>
<p>我们的客座作者 Abiodun 是一名使用 Ruby/Rails 和 React 的软件工程师。她热衷于通过写作/口语分享知识，并在空闲时间唱歌、狂看电影和观看足球比赛。</p>
<p><a href="https://blog.appsignal.com/authors/abiodun-olowode">Abiodun Olowode 的所有文章 - https://blog.appsignal.com/authors/abiodun-olowode</a></p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://github.com/charkost/prosopite">charkost/prosopite: Rails N+1 queries auto-detection with zero false positives / false negatives - https://github.com/charkost/prosopite</a></p>
<p>[2] <a href="https://github.com/flyerhzm/bullet">flyerhzm/bullet: help to kill N+1 queries and unused eager loading - https://github.com/flyerhzm/bullet</a></p>
<p>[3] <a href="https://bhserna.com/tools-to-help-you-detect-n-1-queries.html">Tools to help you detect n+1 queries - https://bhserna.com/tools-to-help-you-detect-n-1-queries.html</a></p>
<p>[4] <a href="https://rubocop.org/">RuboCop | The Ruby Linter/Formatter that Serves and Protects - https://rubocop.org/</a></p>
<p>[5] <a href="https://github.com/whitesmith/rubycritic">whitesmith/rubycritic: A Ruby code quality reporter - https://github.com/whitesmith/rubycritic</a></p>
<p>[6] <a href="https://github.com/matthewrudy/memoist">matthewrudy/memoist: ActiveSupport::Memoizable with a few enhancements - https://github.com/matthewrudy/memoist</a></p>
<p>[7] <a href="https://blog.appsignal.com/ruby-magic">AppSignal Blog atom feed | AppSignal Blog - https://blog.appsignal.com/ruby-magic</a></p>
]]></content>
      <categories>
        <category>Programming Language</category>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Profiling</tag>
        <tag>Bullet</tag>
        <tag>Prosopite</tag>
        <tag>Rubocop</tag>
        <tag>RubyCritic</tag>
        <tag>Memoist</tag>
        <tag>AppSignal</tag>
        <tag>Abiodun Olowode</tag>
        <tag>RoR</tag>
        <tag>Ruby on Rails</tag>
        <tag>Ruby on Rails (RoR)</tag>
        <tag>Programming Language</tag>
        <tag>Ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>[Ruby] Ruby 3.2.0 发布</title>
    <url>/2022/12/31/Programming-Language/Ruby/Ruby-3-2-0-Released/</url>
    <content><![CDATA[<ul>
<li>
<h1>Ruby 3.2.0 发布</h1>
</li>
</ul>
<blockquote>
<p>原文链接 <a href="https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/">Ruby 3.2.0 Released - https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/</a></p>
</blockquote>
<p>由 naruse 发表于 2022 年 12 月 25 日</p>
<p>我们很高兴地宣布发布 Ruby 3.2.0。Ruby 3.2 添加了许多功能和性能改进。</p>
<span id="more"></span>
<h2 id="基于-WASI-的-WebAssembly-支持">基于 WASI 的 WebAssembly 支持</h2>
<p>这是基于 WASI 的 WebAssembly 支持的初始端口。这使得 CRuby 二进制文件可以在 Web 浏览器、无服务器边缘环境或其他类型的 WebAssembly/WASI 嵌入器上使用。目前这个移植通过了不使用 Thread API 的基本和引导测试套件。</p>
<p><img src="https://i.imgur.com/opCgKy2.png" alt=""></p>
<h3 id="背景">背景</h3>
<p>WebAssembly (Wasm)最初是为了在网络浏览器中安全快速地运行程序而引入的。但它的目标——在各种环境中高效、安全地运行程序——不仅是 web，也是一般应用程序长期以来所需要的。</p>
<p>WASI（WebAssembly 系统接口）专为此类用例而设计。尽管此类应用程序需要与操作系统通信，但 WebAssembly 运行在没有系统接口的虚拟机上。WASI 将其标准化。</p>
<p>Ruby 中的 WebAssembly/WASI 支持旨在利用这些项目。它使 Ruby 开发人员能够编写在此类承诺平台上运行的应用程序。</p>
<h3 id="用例">用例</h3>
<p>这种支持鼓励开发人员在 WebAssembly 环境中使用 CRuby。一个示例用例是 TryRuby playground 的 CRuby 支持。现在您可以在您的网络浏览器中尝试原始的 CRuby。</p>
<h3 id="技术要点">技术要点</h3>
<p>今天的 WASI 和 WebAssembly 本身缺少一些功能来实现 Fiber、异常和 GC，因为它仍在发展，也出于安全原因。因此 CRuby 通过使用 Asyncify 填补了空白，这是一种控制用户空间执行的二进制转换技术。</p>
<p>此外，我们在 WASI 之上构建了一个 VFS，以便我们可以轻松地将 Ruby 应用程序打包到单个 .wasm 文件中。这使得 Ruby 应用程序的分发更容易一些。</p>
<h3 id="相关链接">相关链接</h3>
<p><a href="https://github.com/ruby/ruby/pull/5407">添加基于 WASI 的 WebAssembly 支持 #5407 - https://github.com/ruby/ruby/pull/5407</a></p>
<p><a href="https://itnext.io/final-report-webassembly-wasi-support-in-ruby-4aface7d90c9">Ruby 中对 WebAssembly/WASI 支持的更新 - https://itnext.io/final-report-webassembly-wasi-support-in-ruby-4aface7d90c9</a></p>
<h2 id="生产就绪的-YJIT">生产就绪的 YJIT</h2>
<p><img src="https://i.imgur.com/X9ulfac.png" alt=""></p>
<ul>
<li>
<p>YJIT 不再是实验性的</p>
<ul>
<li>已经在生产工作负载上进行了一年多的测试，证明非常稳定。</li>
</ul>
</li>
<li>
<p>YJIT 现在支持 Linux、MacOS、BSD 和其他 UNIX 平台上的 x86-64 和 arm64/aarch64 CPU。</p>
<ul>
<li>此版本支持 Apple M1/M2、AWS Graviton、Raspberry Pi 4 等。</li>
</ul>
</li>
<li>
<p>构建 YJIT 现在需要 Rust 1.58.0+。[功能#18481]</p>
<ul>
<li>
<p>为了确保 CRuby 是使用 YJIT 构建的，请rustc在运行脚本之前安装 &gt;= 1.58.0 ./configure。</p>
</li>
<li>
<p>如果您遇到任何问题，请联系 YJIT 团队。</p>
</li>
</ul>
</li>
<li>
<p>YJIT 3.2 版本比 3.1 更快，内存开销大约是 3.1 的 1/3。</p>
<ul>
<li>
<p>总体而言，YJIT 比yjit-bench上的 Ruby 解释器快 41%（几何平均值）。</p>
</li>
<li>
<p>JIT 代码的物理内存是延迟分配的。与 Ruby 3.1 不同，Ruby 进程的 RSS 被最小化，因为分配的虚拟内存页–yjit-exec-mem-size在 JIT 代码实际使用之前不会映射到物理内存页。</p>
</li>
<li>
<p>引入 Code GC，当 JIT 代码的内存消耗达到–yjit-exec-mem-size.</p>
</li>
<li>
<p>RubyVM::YJIT.runtime_stats除了现有的inline_code_size和outlined_code_size键之外，还返回代码 GC 指标： code_gc_count、live_page_count、freed_page_count和freed_code_size。</p>
</li>
</ul>
</li>
<li>
<p>由 <code>RubyVM::YJIT.runtime_stats</code> 生成的大部分统计数据现在都可以在发布版本中使用。</p>
<ul>
<li>只需运行 ruby–yjit-stats​​ 来计算和转储统计信息（会产生一些运行时开销）。</li>
</ul>
</li>
<li>
<p>YJIT 现在经过优化以利用对象形状。[功能#18776]</p>
</li>
<li>
<p>在定义新常量时，利用更细粒度的常量失效来使更少的代码无效。[功能#18589]</p>
</li>
<li>
<p>默认–yjit-exec-mem-size值更改为 64 (MiB)。</p>
</li>
<li>
<p>默认–yjit-call-threshold值更改为 30。</p>
</li>
</ul>
<h2 id="针对-ReDoS-的正则表达式改进">针对 ReDoS 的正则表达式改进</h2>
<p>众所周知，Regexp 匹配可能会花费意想不到的时间。如果您的代码尝试将可能低效的 Regexp 与不受信任的输入进行匹配，攻击者可能会利用它进行有效的拒绝服务（所谓的正则表达式 DoS 或 ReDoS）。</p>
<p>我们引入了两项可显着缓解 ReDoS 攻击的改进。</p>
<h3 id="改进的正则表达式匹配算法">改进的正则表达式匹配算法</h3>
<p>从 Ruby 3.2 开始，Regexp 的匹配算法通过使用记忆技术得到了极大的改进。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This match takes 10 sec. in Ruby 3.1, and 0.003 sec. in Ruby 3.2</span></span><br><span class="line"></span><br><span class="line">/^a*b?a*<span class="variable">$/</span> =~ <span class="string">&quot;a&quot;</span> * <span class="number">50000</span> + <span class="string">&quot;x&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cache.ruby-lang.org/pub/media/ruby320_regex_1.png" alt=""></p>
<p><img src="https://cache.ruby-lang.org/pub/media/ruby320_regex_2.png" alt=""></p>
<p>改进后的匹配算法使得大多数 Regexp 匹配（在我们的实验中大约为 90%）在线性时间内完成。</p>
<p>（对于预览用户：此优化可能会消耗与每个匹配的输入长度成比例的内存。我们预计不会出现实际问题，因为此内存分配通常会延迟，并且正常的 Regexp 匹配最多应消耗 10 倍的内存输入长度。如果在实际应用程序中匹配正则表达式时内存不足，请报告。）</p>
<p>最初的提议是https://bugs.ruby-lang.org/issues/19104</p>
<h3 id="正则表达式超时">正则表达式超时</h3>
<p>上面的优化不能应用于某些类型的正则表达式，例如那些包含高级功能（例如，反向引用或环视）或具有大量固定重复次数的正则表达式。作为后备措施，还引入了 Regexp 匹配的超时功能。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Regexp</span>.timeout = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">/^a*b?a*()\<span class="number">1</span><span class="variable">$/</span> =~ <span class="string">&quot;a&quot;</span> * <span class="number">50000</span> + <span class="string">&quot;x&quot;</span></span><br><span class="line"><span class="comment">#=&gt; Regexp::TimeoutError is raised in one second</span></span><br></pre></td></tr></table></figure>
<p>请注意，这Regexp.timeout是一个全局配置。如果您想对某些特殊的正则表达式使用不同的超时设置，您可能需要使用timeout关键字 for Regexp.new。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Regexp</span>.timeout = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This regexp has no timeout</span></span><br><span class="line">long_time_re = <span class="title class_">Regexp</span>.new(<span class="string">&#x27;^a*b?a*()\1$&#x27;</span>, <span class="symbol">timeout:</span> <span class="title class_">Float</span><span class="symbol">:</span><span class="symbol">:INFINITY</span>)</span><br><span class="line"></span><br><span class="line">long_time_re =~ <span class="string">&quot;a&quot;</span> * <span class="number">50000</span> + <span class="string">&quot;x&quot;</span> <span class="comment"># never interrupted</span></span><br></pre></td></tr></table></figure>
<p>最初的提议是https://bugs.ruby-lang.org/issues/17837。</p>
<h2 id="其他值得注意的新功能">其他值得注意的新功能</h2>
<h3 id="语法建议">语法建议</h3>
<ul>
<li>
<p>syntax_suggest（以前）的功能dead_end已集成到 Ruby 中。这可以帮助您找到错误的位置，例如丢失或多余end的 s，让您更快地回到正轨，例如以下示例：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Unmatched</span> <span class="string">`end&#x27;, missing keyword (`</span><span class="keyword">do</span><span class="string">&#x27;, `def`, `if`, etc.) ?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1  class Dog</span></span><br><span class="line"><span class="string">&gt; 2    defbark</span></span><br><span class="line"><span class="string">&gt; 3    end</span></span><br><span class="line"><span class="string">  4  end</span></span><br></pre></td></tr></table></figure>
<p>[功能 #18159]</p>
</li>
</ul>
<h3 id="错误高亮">错误高亮</h3>
<ul>
<li>现在它指向 TypeError 和 ArgumentError 的相关参数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test.rb:2:in `+&#x27;: nil can&#x27;t be coerced into Integer (TypeError)</span><br><span class="line"></span><br><span class="line">sum = ary[0] + ary[1]</span><br><span class="line">               ^^^^^^</span><br></pre></td></tr></table></figure>
<h3 id="语言">语言</h3>
<ul>
<li>匿名 rest 和关键字 rest 参数现在可以作为参数传递，而不仅仅是在方法参数中使用。[功能#18351]</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">*</span>)</span><br><span class="line">  bar(*)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">baz</span>(<span class="params">**</span>)</span><br><span class="line">  quux(**)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>接受单个位置参数和关键字的 proc 将不再 autosplat。[错误#18633]</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="built_in">proc</span>&#123;|<span class="params">a, **k</span>| a&#125;.call([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># Ruby 3.1 and before</span></span><br><span class="line"><span class="comment"># =&gt; 1</span></span><br><span class="line"><span class="comment"># Ruby 3.2 and after</span></span><br><span class="line"><span class="comment"># =&gt; [1, 2]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在显式对象上赋值的常量的常量赋值运行顺序已与单个属性赋值运行顺序一致。使用此代码：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">foo::<span class="variable constant_">BAR</span> = baz</span><br></pre></td></tr></table></figure>
<ul>
<li>foo 现在在 baz 之前运行。类似地，对于对常量的多次赋值，使用从左到右的运行顺序。使用此代码：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">foo1::<span class="variable constant_">BAR1</span>, foo2::<span class="variable constant_">BAR2</span> = baz1, baz2</span><br></pre></td></tr></table></figure>
<ul>
<li>现在使用以下运行顺序：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">foo1</span><br><span class="line">foo2</span><br><span class="line">baz1</span><br><span class="line">baz2</span><br></pre></td></tr></table></figure>
<p>[错误#15928]</p>
<ul>
<li>
<p>查找模式不再是实验性的。[功能#18585]</p>
</li>
<li>
<p>采用 rest 参数（如*args）并希望通过其委托关键字参数的方法foo(<em>args)现在必须标记为ruby2_keywords （如果尚未标记）。换句话说，所有希望委托关键字参数的方法</em>args现在都必须用 标记ruby2_keywords，无一例外。一旦库可能需要 Ruby 3+，这将使过渡到其他委托方式变得更容易。以前，ruby2_keywords 如果接收方法采用 ，则保留标志 *args，但这是一个错误和不一致。找到潜在缺失的一个好方法ruby2_keywords 是运行测试套件，找到最后一个方法，该方法必须为测试套件失败的每个地方接收关键字参数，然后使用 puts nil, caller, nil 那里。然后检查必须委托关键字的调用链上的每个方法/块是否正确标记为 ruby2_keywords。</p>
</li>
</ul>
<p>[错误#18625] [错误#16466]</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">target</span>(<span class="params">**kw</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Accidentally worked without ruby2_keywords in Ruby 2.7-3.1, ruby2_keywords</span></span><br><span class="line"><span class="comment"># needed in 3.2+. Just like (*args, **kwargs) or (...) would be needed on</span></span><br><span class="line"><span class="comment"># both #foo and #bar when migrating away from ruby2_keywords.</span></span><br><span class="line">ruby2_keywords <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">*args</span>)</span><br><span class="line">  target(*args)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ruby2_keywords <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">*args</span>)</span><br><span class="line">  bar(*args)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">foo(<span class="symbol">k:</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="性能改进">性能改进</h2>
<h3 id="MJIT">MJIT</h3>
<ul>
<li>
<p>MJIT 编译器已在 Ruby 中重新实现为ruby_vm/mjit/compiler.</p>
</li>
<li>
<p>MJIT 编译器在派生的 Ruby 进程下执行，而不是在称为 MJIT worker 的本机线程中执行。[功能 #18968]</p>
<ul>
<li>因此，不再支持 Microsoft Visual Studio (MSWIN)。</li>
</ul>
</li>
<li>
<p>不再支持 MinGW。[功能#18824]</p>
</li>
<li>
<p>重命名–mjit-min-calls为–mjit-call-threshold.</p>
</li>
<li>
<p>将默认值–mjit-max-cache从 10000 改回 100。</p>
</li>
</ul>
<h3 id="PubGrub">PubGrub</h3>
<ul>
<li>
<p>Bundler 2.4 现在使用 PubGrub 解析器而不是 Molinillo。</p>
<ul>
<li>
<p>pubPubGrub 是 Dart 编程语言的包管理器使用的下一代求解算法。</p>
</li>
<li>
<p>此更改后您可能会得到不同的分辨率结果。请将此类情况报告给 RubyGems/Bundler issues</p>
</li>
</ul>
</li>
<li>
<p>RubyGems 在 Ruby 3.2 中仍然使用 Molinillo 解析器。我们计划在未来将其替换为 PubGrub。</p>
</li>
</ul>
<h2 id="自-3-1-以来的其他显着变化">自 3.1 以来的其他显着变化</h2>
<h3 id="数据">数据</h3>
<ul>
<li>新的核心类来表示简单的不可变值对象。该类类似于 Struct 并部分共享一个实现，但具有更精简和严格的 API。[功能#16122]</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Measure</span> = <span class="title class_">Data</span>.define(<span class="symbol">:amount</span>, <span class="symbol">:unit</span>)</span><br><span class="line">distance = <span class="title class_">Measure</span>.new(<span class="number">100</span>, <span class="string">&#x27;km&#x27;</span>)            <span class="comment">#=&gt; #&lt;data Measure amount=100, unit=&quot;km&quot;&gt;</span></span><br><span class="line">weight = <span class="title class_">Measure</span>.new(<span class="symbol">amount:</span> <span class="number">50</span>, <span class="symbol">unit:</span> <span class="string">&#x27;kg&#x27;</span>) <span class="comment">#=&gt; #&lt;data Measure amount=50, unit=&quot;kg&quot;&gt;</span></span><br><span class="line">weight.with(<span class="symbol">amount:</span> <span class="number">40</span>)                      <span class="comment">#=&gt; #&lt;data Measure amount=40, unit=&quot;kg&quot;&gt;</span></span><br><span class="line">weight.amount                                <span class="comment">#=&gt; 50</span></span><br><span class="line">weight.amount = <span class="number">40</span>                           <span class="comment">#=&gt; NoMethodError: undefined method `amount=&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Hash</p>
<ul>
<li>Hash#shift 如果哈希为空，现在总是返回 nil，而不是返回默认值或调用默认过程。[错误#16908]</li>
</ul>
</li>
<li>
<p>匹配数据</p>
<ul>
<li>MatchData#byteoffset 已添加。[功能#13110]</li>
</ul>
</li>
<li>
<p>模块</p>
<ul>
<li>
<p>Module.used_refinements 已添加。[功能#14332]</p>
</li>
<li>
<p>Module#refinements 已添加。[功能#12737]</p>
</li>
<li>
<p>Module#const_added 已添加。[功能#17881]</p>
</li>
</ul>
</li>
<li>
<p>过程</p>
<ul>
<li>
<p>Proc#dup 返回子类的实例。[错误#17545]</p>
</li>
<li>
<p>Proc#parameters 现在接受 lambda 关键字。[功能#15357]</p>
</li>
</ul>
</li>
<li>
<p>求精</p>
<ul>
<li>Refinement#refined_class 已添加。[功能#12737]</li>
</ul>
</li>
<li>
<p>RubyVM::抽象语法树</p>
<ul>
<li>
<p>添加 error_tolerant 选项 parse,parse_file 和 of。[功能 #19013] 使用此选项</p>
<ul>
<li>
<ol>
<li>SyntaxError 被抑制</li>
</ol>
</li>
<li>
<ol start="2">
<li>AST 返回无效输入</li>
</ol>
</li>
<li>
<ol start="3">
<li>end当解析器到达输入末尾但end不够时被补充</li>
</ol>
</li>
<li>
<ol start="4">
<li>end被视为基于缩进的关键字</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Without error_tolerant option</span></span><br><span class="line">root = <span class="title class_">Ruby</span>VM::<span class="title class_">AbstractSyntaxTree</span>.parse(<span class="string">&lt;&lt;~RUBY)</span></span><br><span class="line"><span class="string">def m</span></span><br><span class="line"><span class="string">  a = 10</span></span><br><span class="line"><span class="string">  if</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">RUBY</span></span><br><span class="line"><span class="comment"># =&gt; &lt;internal:ast&gt;:33:in `parse&#x27;: syntax error, unexpected `end&#x27; (SyntaxError)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># With error_tolerant option</span></span><br><span class="line">root = <span class="title class_">Ruby</span>VM::<span class="title class_">AbstractSyntaxTree</span>.parse(<span class="string">&lt;&lt;~RUBY, error_tolerant: true)</span></span><br><span class="line"><span class="string">def m</span></span><br><span class="line"><span class="string">  a = 10</span></span><br><span class="line"><span class="string">  if</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">RUBY</span></span><br><span class="line">p root <span class="comment"># =&gt; #&lt;RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-4:3&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># `end` is treated as keyword based on indent</span></span><br><span class="line">root = <span class="title class_">Ruby</span>VM::<span class="title class_">AbstractSyntaxTree</span>.parse(<span class="string">&lt;&lt;~RUBY, error_tolerant: true)</span></span><br><span class="line"><span class="string">module Z</span></span><br><span class="line"><span class="string">  class Foo</span></span><br><span class="line"><span class="string">    foo.</span></span><br><span class="line"><span class="string">  end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  def bar</span></span><br><span class="line"><span class="string">  end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">RUBY</span></span><br><span class="line">p root.children[-<span class="number">1</span>].children[-<span class="number">1</span>].children[-<span class="number">1</span>].children[-<span class="number">2</span>..-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># =&gt; [#&lt;RubyVM::AbstractSyntaxTree::Node:CLASS@2:2-4:5&gt;, #&lt;RubyVM::AbstractSyntaxTree::Node:DEFN@6:2-7:5&gt;]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加 keep_tokens 选项 parse, parse_file 和 of。[功能 #19070]</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">root = <span class="title class_">Ruby</span>VM::<span class="title class_">AbstractSyntaxTree</span>.parse(<span class="string">&quot;x = 1 + 2&quot;</span>, <span class="symbol">keep_tokens:</span> <span class="literal">true</span>)</span><br><span class="line">root.tokens <span class="comment"># =&gt; [[0, :tIDENTIFIER, &quot;x&quot;, [1, 0, 1, 1]], [1, :tSP, &quot; &quot;, [1, 1, 1, 2]], ...]</span></span><br><span class="line">root.tokens.map&#123;_1[<span class="number">2</span>]&#125;.join <span class="comment"># =&gt; &quot;x = 1 + 2&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Set</p>
<ul>
<li>Set 现在可以作为内置类使用，无需 require “set”. [功能 #16989] 当前通过 Set 常量或调用自动加载 Enumerable#to_set。</li>
</ul>
</li>
<li>
<p>String</p>
<ul>
<li>
<p>String#byteindex 并 String#byterindex 已添加。[功能#13110]</p>
</li>
<li>
<p>将 Unicode 更新到版本 15.0.0 和表情符号版本 15.0。[功能 #18639]（也适用于正则表达式）</p>
</li>
<li>
<p>String#bytesplice 已添加。[功能#18598]</p>
</li>
</ul>
</li>
<li>
<p>结构体</p>
<ul>
<li>
<p>也可以使用关键字参数初始化 Struct 类而不 keyword_init: true 使用 Struct.new [功能 #16806]</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Post</span> = <span class="title class_">Struct</span>.new(<span class="symbol">:id</span>, <span class="symbol">:name</span>)</span><br><span class="line"><span class="title class_">Post</span>.new(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">#=&gt; #&lt;struct Post id=1, name=&quot;hello&quot;&gt;</span></span><br><span class="line"><span class="comment"># From Ruby 3.2, the following code also works without keyword_init: true.</span></span><br><span class="line"><span class="title class_">Post</span>.new(<span class="symbol">id:</span> <span class="number">1</span>, <span class="symbol">name:</span> <span class="string">&quot;hello&quot;</span>) <span class="comment">#=&gt; #&lt;struct Post id=1, name=&quot;hello&quot;&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="兼容性问题">兼容性问题</h2>
<p>注意：不包括功能错误修复。</p>
<h3 id="删除常量">删除常量</h3>
<p>删除了以下不推荐使用的常量。</p>
<ul>
<li>
<p>Fixnum 和 Bignum [功能 #12005]</p>
</li>
<li>
<p>Random::DEFAULT [功能#17351]</p>
</li>
<li>
<p>Struct::Group</p>
</li>
<li>
<p>Struct::Passwd</p>
</li>
</ul>
<h3 id="删除的方法">删除的方法</h3>
<p>删除了以下弃用的方法。</p>
<ul>
<li>
<p>Dir.exists? [功能#17391]</p>
</li>
<li>
<p>File.exists? [功能#17391]</p>
</li>
<li>
<p>Kernel#=~ [功能#15231]</p>
</li>
<li>
<p>Kernel#taint, Kernel#untaint, Kernel#tainted? [功能 #16131]</p>
</li>
<li>
<p>Kernel#trust, Kernel#untrust, Kernel#untrusted? [功能 #16131]</p>
</li>
</ul>
<h2 id="标准库兼容性问题">标准库兼容性问题</h2>
<h3 id="不再捆绑第三方资源">不再捆绑第三方资源</h3>
<ul>
<li>
<p>我们不再捆绑 3rd 方资源，如 libyaml, libffi。</p>
<ul>
<li>
<p>libyaml 源已从 psych 中删除。您可能需要 libyaml-dev 使用 Ubuntu/Debian 平台进行安装。每个平台的包名称都不同。</p>
</li>
<li>
<p>捆绑的 libffi 源也从 fiddle</p>
</li>
</ul>
</li>
<li>
<p>Psych 和 fiddle 支持使用特定版本的 libyaml 和 libffi 源进行静态构建。您可以像这样使用 libyaml-0.2.5 构建 psych：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure --with-libyaml-source-dir=/path/to/libyaml-0.2.5</span></span><br></pre></td></tr></table></figure>
<p>您可以像这样使用 libffi-3.4.4 构建小提琴：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure --with-libffi-source-dir=/path/to/libffi-3.4.4</span></span><br></pre></td></tr></table></figure>
<p>[功能#18571]</p>
</li>
</ul>
<h2 id="C-API-更新">C API 更新</h2>
<h3 id="更新的-C-API">更新的 C API</h3>
<p>更新了以下 API。</p>
<ul>
<li>
<p>PRNG 更新</p>
<ul>
<li>rb_random_interface_t 更新和版本化。使用此接口并为旧版本构建的扩展库。还 init_int32 需要定义函数。</li>
</ul>
</li>
</ul>
<h3 id="删除的-C-API">删除的 C API</h3>
<ul>
<li>
<p>删除了以下弃用的 API。</p>
<ul>
<li>
<p>rb_cData 多变的。</p>
</li>
<li>
<p>“taintedness” 和 “trustedness” 功能。[功能 #16131]</p>
</li>
</ul>
</li>
</ul>
<h2 id="标准库更新">标准库更新</h2>
<ul>
<li>
<p>Bundler</p>
<ul>
<li>
<p>添加 –ext=rust 支持内置 gem，以创建带有 Rust 扩展的简单 gem。[GH-rubygems-6149]</p>
</li>
<li>
<p>使克隆 git repos 更快 [GH-rubygems-4475]</p>
</li>
</ul>
</li>
<li>
<p>RubyGems</p>
<ul>
<li>添加对 cargo builder 的 mswin 支持。[GH-rubygems-6167]</li>
</ul>
</li>
</ul>
<h3 id="ERB">ERB</h3>
<ul>
<li>
<p>ERB::Util.html_escape 比 CGI.escapeHTML.</p>
<ul>
<li>
<p>当不需要转义字符时，它不再分配 String 对象。</p>
</li>
<li>
<p>#to_s 当参数已经是字符串时，它会跳过调用方法。</p>
</li>
<li>
<p>ERB::Escape.html_escape 作为别名添加到 ERB::Util.html_escape，它还没有被 Rails 修补。</p>
</li>
</ul>
</li>
</ul>
<h3 id="IRB">IRB</h3>
<ul>
<li>
<p>已添加 debug.gem 集成命令：debug, break, catch, next, delete, step, continue, finish, backtrace, info</p>
<ul>
<li>
<p>gem “debug” 即使您的 Gemfile 中没有，它们也能正常工作。</p>
</li>
<li>
<p>另请参阅：Ruby 3.2 的 IRB 中有哪些新功能？</p>
</li>
</ul>
</li>
<li>
<p>添加了更多类似 Pry 的命令和功能。</p>
<ul>
<li>
<p>edit 和 show_cmds（如 Pry 的 help ）被添加。</p>
</li>
<li>
<p>lstakes-g 或 -Goption 来过滤掉输出。</p>
</li>
<li>
<p>show_source 别名来自 $ 并接受未引用的输入。</p>
</li>
<li>
<p>whereami 别名为 @.</p>
</li>
</ul>
</li>
</ul>
<p>以下默认 gem 已更新。</p>
<ul>
<li>
<p>RubyGems 3.4.1</p>
</li>
<li>
<p>abbrev 0.1.1</p>
</li>
<li>
<p>benchmark 0.2.1</p>
</li>
<li>
<p>bigdecimal 3.1.3</p>
</li>
<li>
<p>bundler 2.4.1</p>
</li>
<li>
<p>cgi 0.3.6</p>
</li>
<li>
<p>csv 3.2.6</p>
</li>
<li>
<p>date 3.3.3</p>
</li>
<li>
<p>delegate 0.3.0</p>
</li>
<li>
<p>did_you_mean 1.6.3</p>
</li>
<li>
<p>digest 3.1.1</p>
</li>
<li>
<p>drb 2.1.1</p>
</li>
<li>
<p>english 0.7.2</p>
</li>
<li>
<p>erb 4.0.2</p>
</li>
<li>
<p>error_highlight 0.5.1</p>
</li>
<li>
<p>etc 1.4.2</p>
</li>
<li>
<p>fcntl 1.0.2</p>
</li>
<li>
<p>fiddle 1.1.1</p>
</li>
<li>
<p>fileutils 1.7.0</p>
</li>
<li>
<p>forwardable 1.3.3</p>
</li>
<li>
<p>getoptlong 0.2.0</p>
</li>
<li>
<p>io-console 0.6.0</p>
</li>
<li>
<p>io-nonblock 0.2.0</p>
</li>
<li>
<p>io-wait 0.3.0</p>
</li>
<li>
<p>ipaddr 1.2.5</p>
</li>
<li>
<p>irb 1.6.2</p>
</li>
<li>
<p>json 2.6.3</p>
</li>
<li>
<p>logger 1.5.3</p>
</li>
<li>
<p>mutex_m 0.1.2</p>
</li>
<li>
<p>net-http 0.3.2</p>
</li>
<li>
<p>net-protocol 0.2.1</p>
</li>
<li>
<p>nkf 0.1.2</p>
</li>
<li>
<p>open-uri 0.3.0</p>
</li>
<li>
<p>open3 0.1.2</p>
</li>
<li>
<p>openssl 3.1.0</p>
</li>
<li>
<p>optparse 0.3.1</p>
</li>
<li>
<p>ostruct 0.5.5</p>
</li>
<li>
<p>pathname 0.2.1</p>
</li>
<li>
<p>pp 0.4.0</p>
</li>
<li>
<p>pstore 0.1.2</p>
</li>
<li>
<p>psych 5.0.1</p>
</li>
<li>
<p>racc 1.6.2</p>
</li>
<li>
<p>rdoc 6.5.0</p>
</li>
<li>
<p>readline-ext 0.1.5</p>
</li>
<li>
<p>reline 0.3.2</p>
</li>
<li>
<p>resolv 0.2.2</p>
</li>
<li>
<p>resolv-replace 0.1.1</p>
</li>
<li>
<p>securerandom 0.2.2</p>
</li>
<li>
<p>set 1.0.3</p>
</li>
<li>
<p>stringio 3.0.4</p>
</li>
<li>
<p>strscan 3.0.5</p>
</li>
<li>
<p>syntax_suggest 1.0.2</p>
</li>
<li>
<p>syslog 0.1.1</p>
</li>
<li>
<p>tempfile 0.1.3</p>
</li>
<li>
<p>time 0.2.1</p>
</li>
<li>
<p>timeout 0.3.1</p>
</li>
<li>
<p>tmpdir 0.1.3</p>
</li>
<li>
<p>tsort 0.1.1</p>
</li>
<li>
<p>un 0.2.1</p>
</li>
<li>
<p>uri 0.12.0</p>
</li>
<li>
<p>weakref 0.1.2</p>
</li>
<li>
<p>win32ole 1.8.9</p>
</li>
<li>
<p>yaml 0.2.1</p>
</li>
<li>
<p>zlib 3.0.0</p>
</li>
</ul>
<p>以下内置的 gem 已更新。</p>
<ul>
<li>
<p>minitest 5.16.3</p>
</li>
<li>
<p>power_assert 2.0.3</p>
</li>
<li>
<p>test-unit 3.5.7</p>
</li>
<li>
<p>net-ftp 0.2.0</p>
</li>
<li>
<p>net-imap 0.3.3</p>
</li>
<li>
<p>net-pop 0.1.2</p>
</li>
<li>
<p>net-smtp 0.3.3</p>
</li>
<li>
<p>rbs 2.8.2</p>
</li>
<li>
<p>typeprof 0.21.3</p>
</li>
<li>
<p>debug 1.7.1</p>
</li>
</ul>
<p>有关默认 gem 或内置 gem 的详细信息，请参阅 GitHub 版本，例如 GitHub Releases of logger 或 changelog。</p>
<p>有关详细信息，请参阅新闻 或提交日志。</p>
<p>通过这些更改， 自 Ruby 3.1.0 以来，更改了 3048 个文件，218253 个插入 (+)，131067 个删除 (-) ！</p>
<p>圣诞快乐，节日快乐，享受使用 Ruby 3.2 编程的乐趣！</p>
<h2 id="下载">下载</h2>
<p><a href="https://cache.ruby-lang.org/pub/ruby/3.2/ruby-3.2.0.tar.gz">https://cache.ruby-lang.org/pub/ruby/3.2/ruby-3.2.0.tar.gz</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SIZE: 20440715</span><br><span class="line">SHA1: fb4ab2ceba8bf6a5b9bc7bf7cac945cc94f94c2b</span><br><span class="line">SHA256: daaa78e1360b2783f98deeceb677ad900f3a36c0ffa6e2b6b19090be77abc272</span><br><span class="line">SHA512: 94203051d20475b95a66660016721a0457d7ea57656a9f16cdd4264d8aa6c4cd8ea2fab659082611bfbd7b00ebbcf0391e883e2ebf384e4fab91869e0a877d35</span><br></pre></td></tr></table></figure>
<p><a href="https://cache.ruby-lang.org/pub/ruby/3.2/ruby-3.2.0.tar.xz">https://cache.ruby-lang.org/pub/ruby/3.2/ruby-3.2.0.tar.xz</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SIZE: 15058364</span><br><span class="line">SHA1: bcdae07183d66fd902cb7bf995545a472d2fefea</span><br><span class="line">SHA256: d2f4577306e6dd932259693233141e5c3ec13622c95b75996541b8d5b68b28b4</span><br><span class="line">SHA512: 733ecc6709470ee16916deeece9af1c76220ae95d17b2681116aff7f381d99bc3124b1b11b1c2336b2b29e468e91b90f158d5ae5fca810c6cf32a0b6234ae08e</span><br></pre></td></tr></table></figure>
<p><a href="https://cache.ruby-lang.org/pub/ruby/3.2/ruby-3.2.0.zip">https://cache.ruby-lang.org/pub/ruby/3.2/ruby-3.2.0.zip</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SIZE: 24583271</span><br><span class="line">SHA1: 581ec7b9289c2a85abf4f41c93993ecaa5cf43a5</span><br><span class="line">SHA256: cca9ddbc958431ff77f61948cb67afa569f01f99c9389d2bbedfa92986c9ef09</span><br><span class="line">SHA512: b7d2753825cc0667e8bb391fc7ec59a53c3db5fa314e38eee74b6511890b585ac7515baa2ddac09e2c6b6c42b9221c82e040af5b39c73e980fbd3b1bc622c99d</span><br></pre></td></tr></table></figure>
<h2 id="什么是-Ruby">什么是 Ruby</h2>
<p>Ruby 最早由 Matz（Yukihiro Matsumoto）于 1993 年开发，现在作为 Open Source 开发。它在多个平台上运行，并在世界范围内广泛使用，尤其是用于 Web 开发。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/">Ruby 3.2.0 Released - https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/</a></p>
<p>[2] <a href="https://www.ruby-lang.org/en/">Ruby Programming Language - https://www.ruby-lang.org/en/</a></p>
]]></content>
      <categories>
        <category>Programming Language</category>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Programming Language</tag>
        <tag>Ruby</tag>
        <tag>Shopify Engineering</tag>
        <tag>Shopify</tag>
        <tag>YJIT</tag>
        <tag>Yet Another Ruby JIT</tag>
        <tag>Yet Another Ruby JIT (YJIT)</tag>
        <tag>WASI</tag>
        <tag>Wasm</tag>
        <tag>WebAssembly</tag>
        <tag>WebAssembly (Wasm)</tag>
        <tag>Ruby 3.2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>[asdf/Ruby] 使用 asdf 和 asdf-ruby 插件安装多个 Ruby 版本</title>
    <url>/2022/06/18/Programming-Language/Ruby/using-asdf-and-asdf-ruby-to-install-multiple-ruby-versions/</url>
    <content><![CDATA[<h1>使用 asdf 和 asdf-ruby 插件安装多个 Ruby 版本</h1>
<p><code>asdf</code> 是用于管理多个运行时版本的单个 CLI 工具。 它扩展了一个简单的插件系统来安装你最喜欢的编程语言、框架或软件工具：Dart、Flutter、Elixir、Golang (Go)、Java、Node.js、Python、Ruby 等等。</p>
<p>本文介绍如何使用 <code>asdf</code> 和 Ruby 插件通过 Homebrew 包管理器在 macOS 上安装多个 Ruby 版本。</p>
<span id="more"></span>
<h2 id="推荐理由">推荐理由</h2>
<p>CloudoLife 推荐使用 asdf 统一管理不同工具/编程语言/运行环境多版本。推荐理由：</p>
<ul>
<li>
<p><strong>简单性</strong>，只需要安装 asdf 和对应工具/编程语言/运行环境的插件，无需为不同的工具/编程语言/运行环境安装其他多版本管理工具。</p>
</li>
<li>
<p><strong>一致性</strong>，使用相同的 asdf 基本命令和配置，可以统一管理不同工具/编程语言/运行环境多版本，按您所需，灵活熟练切换不同版本。</p>
</li>
<li>
<p><strong>多样性</strong>，官方和社区插件已经支持多达数百种工具/编程语言/运行环境，几乎涵盖到所有工具/编程语言/运行环境。</p>
</li>
<li>
<p><strong>及时性</strong>，插件支持的工具/编程语言/运行环境与上游保持同步，版本更新非常及时，非常容易尝试新版本。</p>
</li>
</ul>
<h2 id="先决条件">先决条件</h2>
<ul>
<li>
<p><a href="https://developer.apple.com/downloads/index.action">Xcode Command Line Tools</a></p>
<p>Xcode Command Line Tools 是一个小型的独立包，可从 Xcode 单独下载，它允许您在 macOS 中进行命令行开发，它由 macOS SDK 和命令行工具（如 Clang）组成。</p>
<p>有关安装和使用 Xcode 命令行工具的更多信息，请参阅 <a href="https://developer.apple.com/downloads/index.action">Xcode Command Line Tools</a></p>
</li>
<li>
<p><a href="https://brew.sh/">Homebrew</a></p>
<p>Homebrew 是 macOS（或 Linux）的缺失包管理器。</p>
<p>有关安装和使用 Homebrew 的更多信息，请参阅<a href="https://brew.sh/">Homebrew - https://brew.sh/</a>.</p>
</li>
</ul>
<h2 id="安装">安装</h2>
<h3 id="安装-asdf">安装 asdf</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 asdf 依赖</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew install coreutils curl git</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 asdf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew install asdf</span></span><br></pre></td></tr></table></figure>
<h3 id="安装-asdf-Ruby-Plugin">安装 asdf Ruby Plugin</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 Ruby Plugin依赖</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew install openssl readline</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 asdf Ruby Plugin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">asdf plugin-add ruby https://github.com/asdf-vm/asdf-ruby.git</span></span><br></pre></td></tr></table></figure>
<h3 id="添加到你的-Shell">添加到你的 Shell</h3>
<p>假设使用 <code>zsh</code>，运行以下命令将内容添加到 <code>~/.zshrc</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;\n. <span class="subst">$(brew --prefix asdf)</span>/asdf.sh&quot;</span> &gt;&gt; <span class="variable">$&#123;ZDOTDIR:-~&#125;</span>/.zshrc</span></span><br></pre></td></tr></table></figure>
<p>或查看 [3. Install asdf | Getting Started | asdf - <a href="https://asdf-vm.com/guide/getting-started.html#_3-install-asdf">https://asdf-vm.com/guide/getting-started.html#_3-install-asdf</a>]<a href="https://asdf-vm.com/guide/getting-started.html#_3-install-asdf">https://asdf-vm.com/guide/getting-started.html#_3-install-asdf</a>) 了解何时使用配置其他 Shell.</p>
<h3 id="列出所有-Ruby-版本">列出所有 Ruby 版本</h3>
<p>更新 Ruby 插件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">asdf plugin update ruby</span></span><br></pre></td></tr></table></figure>
<p>列出所有 Ruby 版本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">asdf list all ruby</span></span><br></pre></td></tr></table></figure>
<h3 id="安装-Ruby-版本">安装 Ruby 版本</h3>
<p>手动安装 Ruby 版本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">asdf install ruby 3.0.2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者安装其他版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$ asdf install ruby 2.6.1</span></span><br></pre></td></tr></table></figure>
<h3 id="配置-Ruby-版本">配置 Ruby 版本</h3>
<p>创建或修改 <code>.tool-versions</code> 文件（当前目录生效）或 <code>~.tool-versions</code> 文件（全局生效）配置 Ruby 版本。</p>
<p>配置使用 Ruby 3.0.2 版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .tool-versions</span></span><br><span class="line">ruby 3.0.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ruby -v</span></span><br><span class="line">ruby 3.0.2p107 (2021-07-07 revision 0db68f0233) [x86_64-darwin20]</span><br></pre></td></tr></table></figure>
<p>配置使用 Ruby 2.6.1 版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .tool-versions</span></span><br><span class="line">ruby 2.6.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ruby -v</span></span><br><span class="line">ruby 2.6.1p33 (2019-01-30 revision 66950) [x86_64-darwin19]</span><br></pre></td></tr></table></figure>
<h2 id="从另一个-Ruby-版本管理器迁移过来">从另一个 Ruby 版本管理器迁移过来</h2>
<p>asdf 使用 <code>.tool-versions</code> 在软件版本之间自动切换。 为了简化迁移，您可以让它读取现有的 <code>.ruby-version</code> 文件以找出应该使用的 Ruby 版本。 为此，将以下内容添加到 <code>$HOME/.asdfrc</code>:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">legacy_version_file</span> = <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<p>如果您从支持 <code>.ruby-version</code> 中的模糊匹配的版本管理器（如 rvm 或 chruby）迁移，请注意您可能必须更改 <code>.ruby-version</code> 以包含完整版本（例如，将 2.6 更改为 2.6.1）。</p>
<h2 id="常见问题">常见问题</h2>
<h3 id="env-ruby-executable-hooks-No-such-file-or-directory">env: ruby_executable_hooks: No such file or directory</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bundle</span></span><br><span class="line">env: ruby_executable_hooks: No such file or directory</span><br></pre></td></tr></table></figure>
<p>安装 <code>bundler</code> gem，然后运行 <code>bundle</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gem install bundler</span><br><span class="line"></span><br><span class="line">bundle</span><br></pre></td></tr></table></figure>
<h3 id="asdf-shims-rails-line-8-usr-local-Cellar-asdf-0-9-0-libexec-bin-asdf-No-such-file-or-directory">/.asdf/shims/rails: line 8: /usr/local/Cellar/asdf/0.9.0/libexec/bin/asdf: No such file or directory</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rails c</span></span><br><span class="line">~/.asdf/shims/rails: line 8: /usr/local/Cellar/asdf/0.9.0/libexec/bin/asdf: No such file or directory</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.asdf/shims/rails</span></span><br><span class="line">exec /usr/local/Cellar/asdf/0.9.0/libexec/bin/asdf exec &quot;rails&quot; &quot;$@&quot;</span><br></pre></td></tr></table></figure>
<p>备份 <code>~/.asdf/shims</code> 后，运行 <code>asdf reshim</code> 更新所有 <code>~/.asdf/shims</code> 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv ~/.asdf/shims ~/.asdf/shims.bak</span><br><span class="line"></span><br><span class="line">asdf reshim</span><br></pre></td></tr></table></figure>
<p>请参阅 <a href="https://github.com/asdf-vm/asdf/issues/1147">bug: Updating asdf did not update version number in shim paths · Issue #1147 · asdf-vm/asdf - https://github.com/asdf-vm/asdf/issues/1147</a> 以了解更多信息。</p>
<h2 id="​参考链接">​参考链接</h2>
<p>[1] <a href="https://asdf-vm.com/#/core-manage-asdf">Manage asdf - https://asdf-vm.com/#/core-manage-asdf</a></p>
<p>[2] <a href="https://github.com/asdf-vm/asdf-ruby">asdf-vm/asdf-ruby: Ruby plugin for asdf version manager - https://github.com/asdf-vm/asdf-ruby</a></p>
<p>[3] <a href="https://github.com/rbenv/ruby-build/wiki#suggested-build-environment">Home · rbenv/ruby-build Wiki - https://github.com/rbenv/ruby-build/wiki#suggested-build-environment</a></p>
<p>[4] <a href="https://wolfgangrittner.dev/switching-to-asdf-for-ruby/">Switching to asdf - https://wolfgangrittner.dev/switching-to-asdf-for-ruby/</a></p>
<p>[5] <a href="https://www.nikitakazakov.com/asdf-vm-version-manager-for-ruby-tutorial/">ASDF VM Version Manager for Ruby Tutorial - https://www.nikitakazakov.com/asdf-vm-version-manager-for-ruby-tutorial/</a></p>
<p>[6] <a href="https://brew.sh/">Homebrew - https://brew.sh/</a></p>
<p>[7] <a href="https://www.wiserfirst.com/blog/how-to-use-asdf-on-macos/">How to Use asdf Version Manager on macOS | Peaceful Revolution - https://www.wiserfirst.com/blog/how-to-use-asdf-on-macos/</a></p>
<p>[8] <a href="https://www.zsh.org/">Zsh - https://www.zsh.org/</a></p>
<p>[9] <a href="https://www.ruby-lang.org/en/">Ruby Programming Language - https://www.ruby-lang.org/en/</a></p>
<p>[10] <a href="https://bundler.io/">Bundler: The best way to manage a Ruby application’s gems - https://bundler.io/</a></p>
<p>[11] <a href="https://developer.apple.com/downloads/index.action">Xcode Command Line Tools - https://developer.apple.com/downloads/index.action</a></p>
]]></content>
      <categories>
        <category>Programming Language</category>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Homebrew (brew)</tag>
        <tag>macOS</tag>
        <tag>asdf</tag>
        <tag>Programming Language</tag>
        <tag>Ruby</tag>
        <tag>asdf-ruby</tag>
        <tag>bundle</tag>
        <tag>Xcode</tag>
        <tag>Xcode Command Line Tools</tag>
        <tag>Best Practices</tag>
      </tags>
  </entry>
  <entry>
    <title>CloudoLife 面向云生活 周刊 2023 年第 04 期：明确目标，然后实践，犯错，失败，学习</title>
    <url>/2023/01/28/Weekly/2023/2023-04/</url>
    <content><![CDATA[<h1>CloudoLife 面向云生活 周刊 2023 年第 04 期：明确目标，然后实践，犯错，失败，学习</h1>
<p>本周是中国农历新年，祝大家新年快乐！同时今天是大年初七，很多朋友已经开始工作，祝大家开工大吉！</p>
<span id="more"></span>
<h2 id="Books-书籍">Books / 书籍</h2>
<p><a href="https://book.douban.com/subject/36071759/">创造 (豆瓣) - https://book.douban.com/subject/36071759/</a></p>
<p>托尼·法德尔的《创造》，这本书内容丰富、精彩、实用，每个创造者都能从中获得价值。</p>
<ul>
<li>这本书用实际的经历解答了以下问题：
<ul>
<li>如何规划职业发展？</li>
<li>如何知道自己想法的优劣？</li>
<li>如何应对失败？</li>
<li>何时启动创业以及该如何创业？</li>
<li>如何在公司发展的同时保持公司文化的完整性？</li>
</ul>
</li>
</ul>
<blockquote>
<p>首先明确目标，然后实践，犯错，失败，学习，其他的自然会跟着到来。</p>
</blockquote>
<p><a href="https://baijiahao.baidu.com/s?id=1699113654357781152&amp;wfr=spider&amp;for=pc&amp;searchword=%E9%80%BB%E8%BE%91%E5%AD%A6%E8%87%AA%E5%AD%A6%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90">逻辑学书单：全网最全4大类40本学习逻辑的好书！北京大学推荐！ - https://baijiahao.baidu.com/s?id=1699113654357781152&amp;wfr=spider&amp;for=pc&amp;searchword=%E9%80%BB%E8%BE%91%E5%AD%A6%E8%87%AA%E5%AD%A6%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90</a></p>
<p>逻辑学是一个哲学分支学科，也是一门基础性的学科，更是一门工具性学科，为包括基础学科在内的一切科学提供逻辑分析、逻辑批判、逻辑推理、逻辑论证的工具。</p>
<p>而显然，逻辑学作为思维工具，有助于提高逻辑思维能力；有助于获取新知识；有助于正确表达思想；有助于提高工作效率。</p>
<p><strong>逻辑学书单 40 本</strong></p>
<p>一、入门篇</p>
<pre><code>- 01.《简单的逻辑学》麦克伦尼
- 02.《一本小小的蓝色逻辑书》
- 03.《牛津通识读本：简明逻辑学中》
- 04.《系统之美》
- 05.《思考，快与慢》丹尼尔·卡尼曼
- 06.《沃顿商学院逻辑思维课：超简单的逻辑学读本》
- 07.《十二堂趣味逻辑课》
- 08.《我的第一本逻辑思考入门》
- 09.《论证是一门学问》
- 10.《简单逻辑学》吴昱荣
</code></pre>
<p>二、进阶篇</p>
<pre><code>- 11.《金字塔原理：麦肯锡40年经典培训教材》
- 12.《学会提问(第10版）》
- 13.《思考的艺术》
- 14.《超越感觉：批判性思考指南》文森特·鲁吉罗
- 15.《策略思维》迪克西特
- 16.《清醒思考的艺术》
- 17.《思辨与立场：生活中无处不在的批判性思维工具》
- 18.《隐性逻辑：教你快速切换思考方式》
- 19.《小逻辑：让选择变简单的方法》
- 20.《哲学是怎样炼成的：从普通常识到逻辑推理》
- 21.《逻辑思维与诡辩：60堂改变思维方式的逻辑公开课》
- 22.《聪明人总能避免的66个逻辑陷阱》
</code></pre>
<p>三、高阶篇</p>
<pre><code>- 23.《逻辑学导论：21世纪大学文科教材》陈波
- 24.《批判性思维工具(原书第3版)》
- 25.《逻辑新引：怎样判别是非》
- 26.《逻辑与哲学》保罗·蒂德曼|霍华德·卡哈尼
- 27.《逻辑思维》理查德·尼斯贝特
- 28.《逻辑学十五讲》
- 29.《逻辑思考的艺术》
- 30.《逻辑的引擎》
- 31.《魔鬼逻辑学》
- 32.《逻辑十九讲》
</code></pre>
<p>四、实务篇</p>
<pre><code>- 33.《麦肯锡入职培训第一课：让职场新人一生受用的逻辑思考力》
- 34.《麦肯锡教我的思考武器：从逻辑思考到真正解决问题》
- 35.《你以为你以为的就是你以为的吗》
- 36.《你的灯亮着吗？》
- 37.《有逻辑地提问：知道你不知道又想知道的一切》
- 38.《逻辑说服力：如何有逻辑地说服人》
- 39.《有用的逻辑学》
- 40.《生活中的逻辑学》
</code></pre>
<p><a href="https://www.indigox.me/2023-book-list-recommendations/">2023 精选书单 / 从信息经济到量子引力 认知世界趋势的十二本书 - https://www.indigox.me/2023-book-list-recommendations/</a></p>
<p>科技依旧是世界进步之源，这份书单围绕科技也超越科技，我们将从驱动创新的风险投资开始，学习什么是信息资本论，了解科技冷战和逆全球化格局；然后是网络国家、元宇宙和数字化生命的未来；再回到脑科学、细胞与人类的意识；最后在意大利物理学家 Carlo Rovelli 新书《现实不似你所见》的带领下，了解宇宙构成的最新本质。路径很长，但内容丰富，适合阅读一整年😄</p>
<p><strong>十二本书的快速索引</strong></p>
<pre><code>- The Power Law - 风险投资与企业家的创新
- Knowledge and Power - 信息资本论
- Chip War - 科技新冷战
- The End Of The World Is Just The Beginning - 逆全球化
- The Network State - 网络国家
- The Metaverse - 正解元宇宙
- Make Things Think - 让机器思考
- Life 3.0 - 智能生命的未来
- Models of the Mind - 心智的数学模型
- The Song of the Cell - 细胞之歌
- Being You - 意识的新框架
- Reality is Not What it Seems - 量子引力
</code></pre>
<p><a href="https://singlelogin.me/">Z-Library single sign on - https://singlelogin.me/</a></p>
<p>Z-Library（简称Z-Lib，前身为 BookFinder ）是是世界上最大的免费在线图书馆，用户可在此一网站上下载期刊文章以及各种类型的书籍。目前该网站目前只能在 Tor 与 I2P 网路中使用。</p>
<h2 id="English-英语">English / 英语</h2>
<p><a href="https://sspai.com/post/77853">2021 到 2023 英语学习探索之路 - 少数派 - https://sspai.com/post/77853</a></p>
<p>从 2021 年到 2023 年，作者这段时间里尝试过的所有方法梳理下来形成此文。如果你也想好好学习英语又感到有些迷茫，那么你不妨尝试读下去，希望能对你有所启发。</p>
<p><a href="https://a-programmers-guide-to-english.harryyu.me/">关于本指南 · A Programmer’s Guide to English - https://a-programmers-guide-to-english.harryyu.me/</a></p>
<p>专为程序员编写的英语学习指南。本教程目标人群是想要花一些时间真正掌握英语的人，本指南会深挖语言学习的本质（主要用中文举例）并用程序员易于理解的方式去思考，并提供自己根据本质推演出来的训练方法和经验做参考。重中之重是你要根据本质自己设计适合自己的训练方法，同时可以甄别网上看到学习方法和资料，判断是否适合自己使用。</p>
<blockquote>
<p>学习英语的唯一的银弹：重复训练。你越早明白语言学习没有技巧，就会越少浪费时间和金钱在各种资料和经验上面，走越少的弯路。</p>
</blockquote>
<p><a href="https://qwerty.kaiyi.cool/">Qwerty Learner - https://qwerty.kaiyi.cool/</a></p>
<p>Qwerty Learner 为键盘工作者设计的单词记忆与英语肌肉记忆锻炼软件 / Words learning and English muscle memory training software designed for keyboard workers</p>
<h2 id="Personal-Knowledge-Management-PKM-个人知识管理">Personal Knowledge Management (PKM) / 个人知识管理</h2>
<p><a href="https://medium.com/@pkmbeth/how-to-use-the-zotero-logseq-integration-57f1fe07df1e">How to use the Zotero &amp; Logseq integration | by PKM Beth | Jan, 2023 | Medium - https://medium.com/@pkmbeth/how-to-use-the-zotero-logseq-integration-57f1fe07df1e</a></p>
<p>PKM Beth 不定期分享使用 Logseq 等工具的经验，以及个人知识管理的方法论。</p>
<p><a href="https://www.kele.me/">🥤可乐周报 | happy xiao | Substack - https://www.kele.me/</a></p>
<p>作者是 happy xiao，🥤可乐周报是在每周二发送的一封邮件（准时率87.6%），通过这封邮件，会分享给你4-5个可以立即执行的想法。灵感来自于平时的阅读和思考，想通过这封邮件，帮助你升级思维方式，让你通过行动来改变，变得更健康、更富有、更快乐，变成你一直想成为的自己。</p>
<h2 id="Wealth-财富">Wealth / 财富</h2>
<p><a href="https://read.douban.com/column/1391975/">全球理财没那么难 - ETF理财猫 - 生活风尚 - 原创 | 豆瓣阅读 - https://read.douban.com/column/1391975/</a></p>
<p>投资工具ETF，就是基于指数而来的一种非常适合长期投资的，简单易行的产品。</p>
<p>“理财”其实就是管理财富。作者建议要以积极的形态理财，不要以“本来每个月就没剩下几个钱”或者作为媒体报道的股市大跌有风险等理由不作为，更不要把理财当成节衣缩食降低生活品质的负担，或者太多投入时间和精力到股市里，影响你生活中真正赚钱的行为（如工资、奖金、创业收益等等）。实际上，合理的收支管理和投资，恰恰会让你的生活品质稳定提高，同时保持更安全的节奏。</p>
<p>作者希望开拓大家视野，让大家更轻松的以ETF等工具进行理财。当然，作者无法给出你详细的投资建议，请记住，每天你都会听到有人在推荐可能大涨的股票，但是从长期理财而言，最终还是需要你掌握信息和知识，做出自己的判断。</p>
<p>具体操作请把风险控制和本金安全放在首位。具体包括：</p>
<pre><code>- 现金合理规划
- 姿态保持进取
- 操作严守纪律
- 心态保持淡定
- 眼光放眼全球
</code></pre>
<p><a href="https://www.revolut.com/">One app, all things money | Revolut - https://www.revolut.com/</a></p>
<p>Revolut 是一间英国金融科技公司，早于 2015 年成立，其后在 2018 年取得欧盟银行牌照，现时主要为欧美地区和部分亚洲国家提供数字银行服务。 Revolut 的主打服务为综合货币帐户、扣账卡和国际汇款。 Revolut 帐户支援25+种货币，客户除了可以享受免手续费兑换外币，更可以用外币投资加密货币、基金股票等产品。</p>
<h2 id="Technology-科技">Technology / 科技</h2>
<h3 id="WebAssembly-Wasm">WebAssembly (Wasm)</h3>
<p>Wasm 是一种二进制格式。许多不同的语言都可以编译为相同的格式，并且该二进制格式可以在大量操作系统和体系结构上运行。它的设计目标包括：高可移植性、高安全性、高效率。Wasm 重新定义了应用软件的开发模式，正逐渐接近其跨语言的 “一次编写，随处运行” 的愿景。随着 Ruby, Python, Go, Rust 等语言的支持，Wasm 已经成为了一种通用的编译目标，可以用于构建 Web 应用、移动应用、桌面应用、游戏、物联网设备、甚至是嵌入式设备。Docker 宣布与 CNCF Wasm 运行时项目 WasmEdge 合作推出 Docker + Wasm 技术。预测今年 Wasm 将开始成为云原生的主流开发者工具。</p>
<p><a href="https://mp.weixin.qq.com/s/c83vUxGK8kNtdtQEOkTyGg">云原生Wasm的开发者工具正在成为主流 - https://mp.weixin.qq.com/s/c83vUxGK8kNtdtQEOkTyGg</a></p>
<p><a href="https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/">WebAssembly serverless functions in AWS Lambda | Cloud Native Computing Foundation - https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/</a></p>
<p><a href="https://wa-lang.org/">凹语言 | 为WebAssembly而生 - https://wa-lang.org/</a></p>
<h3 id="Artificial-Intelligence-AI-人工智能">Artificial Intelligence (AI) / 人工智能</h3>
<p><a href="https://mp.weixin.qq.com/s/OPZ0s4uGhShy9T43LkBQzw">美版头条ChatGPT上岗写稿消息一出，股价暴涨119%，此前刚裁员12% - https://mp.weixin.qq.com/s/OPZ0s4uGhShy9T43LkBQzw</a></p>
<p>当地时间周四，“美版今日头条”BuzzFeed宣布和OpenAI合作，未来将使用ChatGPT帮助创作内容。</p>
<p><a href="https://mp.weixin.qq.com/s/X5JVsLXSJs4oCIXgmbkmmg">谷歌大脑深度学习调参（炼丹）指南出炉，Hinton点赞，一天收获1500星 - https://mp.weixin.qq.com/s/X5JVsLXSJs4oCIXgmbkmmg</a></p>
<p><a href="https://mp.weixin.qq.com/s/d1nno1gIDjgBBPoS6uTvug">用AI分析，跨年演唱会上鸽鸽们是否假唱了？作者已收到律师函 - https://mp.weixin.qq.com/s/d1nno1gIDjgBBPoS6uTvug</a></p>
<p><a href="https://google-research.github.io/seanet/musiclm/examples/">MusicLM - https://google-research.github.io/seanet/musiclm/examples/</a></p>
<p><a href="https://vercel.com/blog/deploying-ai-applications">Deploying AI-driven apps on Vercel – Vercel - https://vercel.com/blog/deploying-ai-applications</a></p>
<p>介绍 AI 团队如何在 Vercel 上更快地构建新项目。一站式模版包括：</p>
<ul>
<li>
<p><a href="https://vercel.com/blog/deploying-ai-applications#twitter-bio-generator">Twitter Bio Generator - https://vercel.com/blog/deploying-ai-applications#twitter-bio-generator</a></p>
</li>
<li>
<p><a href="https://vercel.com/blog/deploying-ai-applications#photo-restorer-(with-replicate)">Photo Restorer - https://vercel.com/blog/deploying-ai-applications#photo-restorer-(with-replicate)</a></p>
</li>
<li>
<p><a href="https://vercel.com/blog/deploying-ai-applications#image-alt-text-generator-(with-replicate)">Image Alt Text Generator - https://vercel.com/blog/deploying-ai-applications#image-alt-text-generator-(with-replicate)</a></p>
</li>
<li>
<p><a href="https://vercel.com/blog/deploying-ai-applications#dall%C2%B7e-2-art-generator">DALL·E 2 Art Generator - https://vercel.com/blog/deploying-ai-applications#dall%C2%B7e-2-art-generator</a></p>
</li>
<li>
<p><a href="https://vercel.com/blog/deploying-ai-applications#extrapolate---ai-aging-app">Extrapolate - AI Aging App - https://vercel.com/blog/deploying-ai-applications#extrapolate—ai-aging-app</a></p>
</li>
</ul>
<h3 id="Serverless-无服务器架构">Serverless / 无服务器架构</h3>
<p><a href="https://serverlessland.com/">Serverless Land | Resources for learning about AWS serverless technology - https://serverlessland.com/</a></p>
<h3 id="Git-Git-版本管理">Git / Git 版本管理</h3>
<p>Git Large File Storage (LFS)</p>
<p>Git Large File Storage （大文件存储），即将 Git 存储库中的体积较大的，不利于打包的，修改不太频繁的文件单独存储到特定的服务器上，以减小存储库体积，加快用户的克隆拉取体验。</p>
<p><a href="https://git-lfs.com/">Git Large File Storage | Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise. - https://git-lfs.com/</a></p>
<p><a href="https://gitee.com/help/articles/4235#article-header5">Git LFS 操作指南 - Gitee - https://gitee.com/help/articles/4235#article-header5</a></p>
<blockquote>
<p><strong>注意</strong> GitHub 等免费套餐对 LFS 有存储和流量限制。开启 LFS 之前建议先了解具体限制。</p>
</blockquote>
<h3 id="Ruby-on-Rails-RoR">Ruby on Rails (RoR)</h3>
<p><a href="https://fly.io/ruby-dispatch/rails-on-docker/">Rails on Docker · Fly - https://fly.io/ruby-dispatch/rails-on-docker/</a></p>
<p>Rails 7.1 正在获得一个官方的 Dockerfile，这将使将 Rails 应用程序部署到支持 Docker 的生产环境变得更加容易。</p>
<p><a href="http://fly.io">fly.io</a> 是一个容器化的部署平台，只需要一个 Dockerfile 文件就能部署代码到 <a href="http://fly.io">fly.io</a> 的服务器上，同时还自动生成域名，同时提供一定免费服务额度。</p>
<h3 id="Cascading-Style-Sheets-CSS-层叠样式表">Cascading Style Sheets (CSS) / 层叠样式表</h3>
<p><a href="https://geeknote.net/Rei/posts/1995">Tailwind CSS，从入坑到退坑 - GeekNote - https://geeknote.net/Rei/posts/1995</a></p>
<p>Tailwind CSS 是一个实用类优先的 CSS 框架。跟其他 CSS 框架的主要不同是它不提供组件层面的样式，而是全部都是实用类。作者在一个新建的小项目上尝试只用 Tailwind 开发。经过一个多月，总结一下使用 Tailwind 的经验。</p>
<h3 id="Others-其它">Others / 其它</h3>
<p><a href="https://slite.com/">Slite – Your Modern Knowledge Base - https://slite.com/</a></p>
<p>Slite 是一个现代知识库，可帮助团队摆脱信息过载的混乱局面。借助 Slite 程序，您可以随时随地与团队保持协调，随时掌握工作情况。</p>
<p><a href="https://slite.com/ask">Ask -  Stop searching, start asking | Slite - https://slite.com/ask</a></p>
<p><a href="https://blog.google/inside-google/message-ceo/january-update/">A difficult decision to set us up for the future - https://blog.google/inside-google/message-ceo/january-update/</a></p>
<p>谷歌的母公司Alphabet周五表示，将裁员12000人，这相当于其总雇员数量的6%。该公司总裁皮查伊（Sundar Pichai）周五在发给员工的一封电邮中宣布了这一消息。</p>
<p>本周内，另一科技业巨头微软（Microsoft）刚刚宣布了裁员1万人的决定。</p>
<p>此前，亚马逊（Amazon）和脸书母公司Meta也分别宣布裁员1.8万和1.1万。</p>
<p>目前 苹果 (Apple) 还没发布裁员消息。</p>
<h2 id="Blog-博客">Blog / 博客</h2>
<p><a href="https://tw93.fun/">Tw93 - https://tw93.fun/</a></p>
<p>Tw93 是一位来自中国的前端工程师，喜欢折腾各种软件。是 MiaoYan / Pake / XRender / WeexUi / cz-emoji-chinese 等的创作者。</p>
<p><a href="https://tw93.fun/2023-01-25/my-2022.html">2022 年总结 - 率性而活 - Tw93 - https://tw93.fun/2023-01-25/my-2022.html</a></p>
<p><a href="https://www.indigox.me/">Indigo’s Digital Mirror - https://www.indigox.me/</a></p>
<p>个人博客“INDIGO 的数字镜像”，用图文并茂的形式来记录投资、科技和对这个世界不算太业余的思考</p>
<p><a href="https://chai2010.cn/">chai2010 的博客 - https://chai2010.cn/</a></p>
<p>chai2010 (柴树杉)是 凹语言 作者，KusionStack 作者，Go语言(1.2+)代码的贡献者(Chaishushan), 《Go语言圣经》翻译者, 《Go语言高级编程》开源免费图书作者, 《WebAssembly标准入门》等多本畅销图书作者。目前在蚂蚁从事 KusionStack 和 KCL 开源项目开发和推广工作。</p>
<h2 id="Entertainment-娱乐">Entertainment / 娱乐</h2>
<p><a href="https://space.bilibili.com/697166795/">徐云流浪中国的个人空间_哔哩哔哩_bilibili - https://space.bilibili.com/697166795/</a></p>
<p><a href="https://mp.weixin.qq.com/s/OykchEUNpjW0WYTaTZwoVg">【机台介绍】微信君带你玩转黄金堡 - https://mp.weixin.qq.com/s/OykchEUNpjW0WYTaTZwoVg</a></p>
<p>春节迷上了游乐场的黄金堡游戏机，找到一篇攻略，希望能帮到大家。</p>
<blockquote>
<p>当推板完全缩回时，再投币，这样币推下的几率大大增加，两个投币口同时投币，双管齐下，效果更赞~</p>
</blockquote>
]]></content>
      <categories>
        <category>Weekly</category>
        <category>2023</category>
      </categories>
      <tags>
        <tag>Weekly</tag>
        <tag>2023</tag>
      </tags>
  </entry>
  <entry>
    <title>CloudoLife 面向云生活 周刊 2023 年第 05 期：如果有人告诉你坏消息，他不一定是坏人</title>
    <url>/2023/02/05/Weekly/2023/2023-05/</url>
    <content><![CDATA[<h1>CloudoLife 面向云生活 期刊 2023 年第 05 期 如果有人告诉你坏消息，他不一定是坏人</h1>
<p>今天是中国农历传统节日元宵节，祝大家元宵节快乐！</p>
<p>本周热点是 是否需要招聘 DBA，微软旗下产品 Bing 和 Teams 嵌入 ChatGPT，以及基于去中心化社交网络 Nostr 的首个客户端 Damus 正式上线。</p>
<span id="more"></span>
<h2 id="是否需要招聘-DBA-？">是否需要招聘 DBA ？</h2>
<p>瑞典马工一篇文章<a href="https://mp.weixin.qq.com/s/DtRFnh8LgtfesCNMNl3eNw">你怎么还在招聘DBA? - https://mp.weixin.qq.com/s/DtRFnh8LgtfesCNMNl3eNw</a>捅了 DBA 的马蜂窝，很多技术群和业务群都在讨论这个话题，也出现很多相关文章，比如：</p>
<ul>
<li>
<p><a href="https://mp.weixin.qq.com/s/rtx4UWkuvrKf7gtd6pFr-A">大厂裁员轰轰烈烈，哪个技术岗位可以独善其身？ - https://mp.weixin.qq.com/s/rtx4UWkuvrKf7gtd6pFr-A</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/-jKJ1f39QOI30St1SNEHeA">读《你怎么还在招聘DBA》有感 - https://mp.weixin.qq.com/s/-jKJ1f39QOI30St1SNEHeA</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/LefEAXTcBH-KBJNhXNoc7A">云数据库是不是杀猪盘 - https://mp.weixin.qq.com/s/LefEAXTcBH-KBJNhXNoc7A</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/LFnWliDxPQnVePkDWsIVag">你怎么不招聘 DBA - https://mp.weixin.qq.com/s/LFnWliDxPQnVePkDWsIVag</a></p>
</li>
</ul>
<p>一时间众说纷纭，很多人感觉雾里看花。</p>
<p>其实企业和用户只关心一个问题：是什么技术工具和人能够解决数据库的问题，并不关心具体是什么岗位的人解决问题。技术和工具、人以及数据自身是没有价值，能够解决他人问题的才有价值。</p>
<p>随着互联网打破信息差异、计算机硬件的高速发展、云服务的普及，开源数据库的成熟，数据库的性能和可靠性已经有很大的提升，专职 DBA 的工作内容在逐渐减少。未来 DBA 岗位甚至会消失。</p>
<p>笔者建议，如果公司业务上对数据没特别的要求，建议人均营收</p>
<ul>
<li><strong>&lt; 100 万</strong>，不需要招聘 DBA</li>
<li><strong>100 万 - 1000 万</strong>，可以考虑招聘 DBA</li>
<li><strong>&gt; 1000 万</strong>，需要招聘的是 DB 研发，而不是 DBA</li>
</ul>
<p>如果您是一位 DBA，千万不要只光顾着低头看自己负责的 DBA 领域，应该时不时往前看，看看企业业务发展的目标，向周围看，看看周围的人在做什么。思考自己的技术是否能够满足企业的业务发展，如何才能更好提升自己的价值。</p>
<blockquote>
<p>正如瑞典马工在文章中说的：如果有人告诉你坏消息，他不一定是坏人。</p>
</blockquote>
<h2 id="ChatGPT">ChatGPT</h2>
<p>自从 1 月 23 日微软宣布向 ChatGPT 开发者 OpenAI 追加投资数十亿美元专注于将各类工具推向市场。当时分析人士预测微软将 All in AI，微软旗下产品要全线嵌入ChatGPT。本周微软与 ChatGPT 相关的重磅级消息不断，包括：</p>
<ul>
<li>
<p>微软正致力于在未来几周内将 ChatGPT 与 GPT 4.0 集成到其 Bing 搜索界面中。</p>
<p>很快，我们将会开始尝试问搜索引擎来获得答案，而不只是之前那样搜索网页。</p>
<blockquote>
<p>Stop searching, start asking.</p>
</blockquote>
<p><a href="https://searchengineland.com/microsoft-bings-chatgpt-interface-spotted-in-the-wild-392646">Microsoft Bing’s ChatGPT interface spotted in the wild - https://searchengineland.com/microsoft-bings-chatgpt-interface-spotted-in-the-wild-392646</a></p>
</li>
<li>
<p>北京时间2月2日上午，微软宣布 ChatGPT 在 Microsoft Teams Premium 上已普遍可用。</p>
<p>Teams Premium 由 OpenAI 的 GPT-3.5 提供支持的大型语言模型，使会议更加智能、个性化和受到保护——无论是一对一的 -一次，大型会议、虚拟约会或网络研讨会。在接下来的几个月里，用户将在会后看到关键点和要点，以及由 GPT-3.5 自动创建和支持的 AI 生成的笔记。通过 AI 生成的任务和自动为您建议的行动项目，跟进很容易。</p>
<p><a href="https://www.microsoft.com/en-us/microsoft-365/blog/2023/02/01/microsoft-teams-premium-cut-costs-and-add-ai-powered-productivity/">Microsoft Teams Premium: Cut costs and add AI-powered productivity | Microsoft 365 Blog - https://www.microsoft.com/en-us/microsoft-365/blog/2023/02/01/microsoft-teams-premium-cut-costs-and-add-ai-powered-productivity/</a></p>
</li>
</ul>
<h2 id="Damus-Nostr">Damus / Nostr</h2>
<p>2 月 1 日，Twitter 创始人 Jack Dorsey 发推称，基于去中心化社交网络 Nostr 的首个客户端 Damus 正式上线。推特和朋友圈被疯狂刷屏。</p>
<p>Damus 主要优势：建立在开放的互联网协议 Nostr 之上，没有任何平台可以禁止或审查，用户可以控制自己的数据；端到端加密的私人消息传递；无需服务器；消息通过去中心化的中继分发，无需运行任何基础设施，也没有单点故障；可编程，允许轻松集成机器人，帮助用户实现生活或业务自动化。</p>
<p>Damus 和作为基础设施的 Nostr 目前还处于早期阶段，种种功能可能还不是很完善，比如发图片、语音和视频。目前 Damus 看到不少黄、赌、密等垃圾内容。 Nostr 和 Damus 需要有更多有价值的内容，公开透明的社区治理（类似开源软件社区），要想成功挑战 Twitter，可能还有很长的路要走。</p>
<p><a href="https://mp.weixin.qq.com/s/TU5zlZ53n-0ESg3MMfzgLw">Twitter 创始人力挺项目 Damus，突然爆火！这是啥？如何体验？ - https://mp.weixin.qq.com/s/TU5zlZ53n-0ESg3MMfzgLw</a></p>
]]></content>
      <categories>
        <category>Weekly</category>
        <category>2023</category>
      </categories>
      <tags>
        <tag>Weekly</tag>
        <tag>2023</tag>
      </tags>
  </entry>
  <entry>
    <title>[Anthropic Claude] Anthropic 发布 Claude 2，性能更强、响应更长</title>
    <url>/2023/07/12/Artificial-Intelligence-AI/Anthropic/Claude/anthropic-releases-claude-2-with-improved-performance-and-longer-responses/</url>
    <content><![CDATA[<h1><strong>Anthropic 发布 Claude 2，性能更强、响应更长</strong></h1>
<p>Anthropic 是一家由 OpenAI 前高管共同创立的人工智能公司，今天发布了最新的人工智能模型 Claude 2。Claude 2 是 Anthropic 的第二代大型语言模型，在性能上有所提升，响应更长。</p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d843ef4c-814a-4280-8f61-2321493499cf/Untitled.png" alt="Untitled"></p>
<p>Claude 2 的最大特点是提高了单次可输入的长度——达 10 万 token，这几乎是目前商业可用模型中最大的。10 万 Token，意味着 Claude 2 可以一次性处理大约 75000 个单词，这相当于数百页的技术文档，甚至是书籍。</p>
<p>此外，Claude 2 的编程、数学、推理技能也得到了改善。在 Codex HumanEval（Python 编程测试）中，Claude 的得分从 1.3 的 56.0% 上升到了 2 的 71.2%。在小学数学问题（GSM8K）、多学科问答（MMLU）、科学问题（ARC-Challenge）等方面，Claude 2 较之前也均有所提升。</p>
<p>与 Claude 1.3 一样，Claude 2 可以实现文档搜索、总结，代码分析和编码等功能。</p>
<p>根据官网给出的示例，用户只需上传需要分析的文档，然后给出相应的指令，Claude 就会自动阅读文档，并作出回答。示例中的两个 pdf 大小总计近 300k，包含超过 83000 个 token，但 Claude 2 仍然成功地完成了任务。</p>
<p>另外，Anthropic 在其发布的论文中表示，Claude 2 具有支持 20 万 token 上下文的潜力，但目前暂未对外开放。</p>
<p>而在代码方面，官方展示了如何利用 Claude 2，在一幅静态地图上加入交互的动效。使用者只需将静态地图的 js 文件输入聊天框，就可以要求 Claude 2 分析代码的功能，而后输入想要实现的新功能，Claude 2 就会自动生成对应的代码。</p>
<p>此次更新还使用了最新的数据集，包括网站、第三方授权数据集和 2023 年初用户自愿提供的数据。相较之下，OpenAI 的 ChatGPT 未联网时，数据集还停留在 2021 年底。</p>
<p>不过，Anthropic 上市负责人 Sandy Banerjee 在接受 TechCrunch 时表示，Claude 2 与 1.3 在模型上并没有什么不同，只是 &quot; 不断迭代的模型开发方法的产物 &quot;。</p>
<p>截至目前，Anthropic 声称已有 &quot; 数千客户 &quot; 以及一批合作伙伴。公司的投资者之一谷歌，已承诺投资 3 亿美元，以换取该公司 10% 的股权。</p>
<p>Anthropic 还表示，要继续研发大模型，未来两年内公司还需要约 50 亿美元，其中大部分资金将用于计算。</p>
<p>Claude 2 的发布是人工智能领域的一大进步，它将使人工智能技术更加强大和实用。随着 Claude 2 的不断发展，我们可以期待人工智能技术在未来为我们的生活带来更多改变。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://claude.ai/login">Claude - https://claude.ai/login</a></p>
<p>[2] <a href="https://www.anthropic.com/index/claude-2">Anthropic \ Claude 2 - https://www.anthropic.com/index/claude-2</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Anthropic</category>
        <category>Claude</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Bard</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>ChatGPT</tag>
        <tag>Google</tag>
        <tag>Anthropic</tag>
        <tag>Claude 2</tag>
        <tag>Claude</tag>
      </tags>
  </entry>
  <entry>
    <title>[Anthropic] 下一代AI助手Claude助力创新突破</title>
    <url>/2023/03/18/Artificial-Intelligence-AI/Anthropic/Claude/next-generation-ai-assistant-claude-empowers-innovative-breakthroughs/</url>
    <content><![CDATA[<h1>下一代AI助手Claude助力创新突破</h1>
<p>近日，人工智能公司Anthropic宣布，将在与合作伙伴Notion、Quora和DuckDuckGo进行数月私人测试后，通过其AI助手Claude在更广范围内实现关键创新应用突破。Claude是一款具有高可靠性和可预测性的下一代AI助手，基于Anthropic在研发“有益、诚实和无害”的人工智能方面的研究成果打造。</p>
<p><a href="https://www.anthropic.com/earlyaccess/">试用Claude - https://www.anthropic.com/earlyaccess/</a></p>
<span id="more"></span>
<blockquote>
<p>Anthropic是另一家被认为是OpenAI ChatGPT潜在竞争对手之一的公司。这家由谷歌支持的公司已经发布了 “Claude”，一个不太可能产生有害内容的人工智能聊天机器人。</p>
</blockquote>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33d4917f-f0f4-42fe-9d4e-832a30488aca/Home.png" alt="Home.png"></p>
<p>Claude可应用于摘要、搜索、创意写作、协作写作、问答和编码等场景。与其他AI助手相比，它的输出更少有害内容，更易于交流和控制。Anthropic为Claude提供个性、语调和行为的定制服务。目前，Anthropic提供高级版Claude和轻量级入门版Claude Instant两款产品，并计划在未来几周推出更多升级版本。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/01f8b979-ad6b-491c-b8ab-443024a38fc8/demo.jpeg" alt="demo.jpeg"></p>
<p>合作伙伴Quora通过AI聊天应用Poe为用户提供Claude服务，表现出高度的易用性和自然交流体验。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d414fae7-6001-4533-871d-b0efe3d52a47/Quora-final.webp" alt="Quora-final.webp"></p>
<p>Juni Learning使用Claude技术为其Discord Juni教练机器人提供支持，提供在线辅导解决方案。Notion则利用Claude的创意写作和摘要能力，开发其网络AI助手Notion AI，提高用户工作效率。DuckDuckGo与Anthropic合作推出DuckAssist，为用户提供基于维基百科和其他相关来源的即时回答服务。</p>
<p>在法律行业，Robin AI使用Claude重新思考合同的未来，为客户提出新的友好的替代语言建议。此外，AssemblyAI正在与Anthropic合作，帮助推动其规模化转录和理解音频数据的API平台。</p>
<p>Anthropic期待Claude在各行各业的潜在应用，并邀请有兴趣的用户[<strong>请求试用 -</strong> <a href="https://www.anthropic.com/earlyaccess">https://www.anthropic.com/earlyaccess</a>](<a href="https://www.anthropic.com/earlyaccess">https://www.anthropic.com/earlyaccess</a>) ****。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1c1febfd-b2a3-49a0-986d-7ff1246619db/waitlist.png" alt="waitlist.png"></p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [Anthropic | Introducing Claude - <a href="https://www.anthropic.com/index/introducing-claude">https://www.anthropic.com/index/introducing-claude</a>](<a href="https://www.anthropic.com/index/introducing-claude">https://www.anthropic.com/index/introducing-claude</a>)</p>
<p>[2] [Early Access | Anthropic - <a href="https://www.anthropic.com/earlyaccess">https://www.anthropic.com/earlyaccess</a>](<a href="https://www.anthropic.com/earlyaccess">https://www.anthropic.com/earlyaccess</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Anthropic</category>
        <category>Claude</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Bard</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>ChatGPT</tag>
        <tag>Google</tag>
        <tag>Anthropic</tag>
        <tag>Claude</tag>
      </tags>
  </entry>
  <entry>
    <title>[Anthropic] Slack + Claude：更智能化的 AI 协作工具</title>
    <url>/2023/04/08/Artificial-Intelligence-AI/Anthropic/Claude/slack-claude-more-intelligent-ai-collaboration-tool/</url>
    <content><![CDATA[<h1>Slack + Claude：更智能化的 AI 协作工具</h1>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a995f22a-474d-450a-ba55-d3f704792e78/Untitled.png" alt="Untitled"></p>
<p>Slack 是一个广受欢迎的协作工具，可以帮助团队进行沟通、协作和项目管理。而最近，这个平台又加入了一位新成员：Claude。那么，Claude 是什么？它能为你的团队带来什么价值呢？</p>
<span id="more"></span>
<p><a href="https://www.anthropic.com/claude-in-slack">Claude in Slack | Anthropic - https://www.anthropic.com/claude-in-slack</a></p>
<p>Claude 是一种 AI 功能，可以帮助团队进行摘要、创意和协作写作、问答等工作。在 Slack 中，你可以通过简单地提及 @Claude 来与它进行交互。Claude 会在一个线程中回复你的请求，让你的团队成员都能看到这个线程，并继续参与讨论。</p>
<p>在 Slack 的频道和群组中，你可以使用 @Claude 来获取一些帮助。比如，你可以要求它为你的会议或讨论生成摘要，或者让它为你提供一些创意和灵感。Claude 还可以记住你在 Slack 中的整个对话，让你可以轻松地回顾和参考以前的讨论内容。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a1b76c78-72a7-4e19-9ccc-27481fcac972/Untitled.png" alt="Untitled"></p>
<p>而在 Slack 的一对一直接消息中，Claude 也同样可用。你可以向它提出各种问题，让它帮你查找信息、解答疑惑，或者为你提供一些灵感和创意。与 Claude 进行交互就像与同事聊天一样，非常自然和方便。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a3be0a33-e7ec-42bd-afe0-dd2e88dd63b9/Untitled.png" alt="Untitled"></p>
<p>Claude 的加入为 Slack 平台带来了更多的智能化和自动化功能，让团队成员可以更加专注于核心工作。与其手动地进行一些重复性和繁琐的工作，不如让 Claude 来帮你完成。这个 AI 功能能够迭代完成任务，让你感觉就像与一名积极投入的员工一起工作。</p>
<p>Claude 是一个非常有用的工具，可以帮助团队更高效地进行沟通和协作。它的加入为 Slack 用户带来了更多的智能化和自动化功能，让人们可以更好地专注于核心工作，提高工作效率和质量。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [Where work happens | Slack - <a href="https://slack.com/">https://slack.com/</a>](<a href="https://slack.com/">https://slack.com/</a>)</p>
<p>[2] <a href="https://www.anthropic.com/claude-in-slack">Claude in Slack | Anthropic - https://www.anthropic.com/claude-in-slack</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Anthropic</category>
        <category>Claude</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Bard</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>ChatGPT</tag>
        <tag>Google</tag>
        <tag>Anthropic</tag>
        <tag>Claude</tag>
        <tag>Slack</tag>
      </tags>
  </entry>
  <entry>
    <title>[ChatGPT] ChatGPT for WeChat 轻松将 WeChat 机器人打造成为你的个人 ChatGPT 助手</title>
    <url>/2023/03/04/Artificial-Intelligence-AI/ChatGPT/Awesome/chatgpt-for-wechat-an-easy-way-to-turn-your-wechat-bot-into-your-personal-chatgpt-assistant/</url>
    <content><![CDATA[<h1>ChatGPT for WeChat 轻松将 WeChat 机器人打造成为你的个人 ChatGPT 助手</h1>
<p>ChatGPT for WeChat 是一个 Chrome 浏览器插件，通过 ChatGPT 来自动响应微信私信或群聊中 @你 的消息的智能聊天机器人。这是目前最容易将你微信账户打造成为个人 ChatGPT 助手的最简单的方式。</p>
<p>这个插件可以帮助你快速搭建一个基于微信聊天的智能应答机器人，不需要任何服务器资源，只需要登录微信网页版页面和 ChatGPT 页面（推荐）或配置 OpenAI apikey 即可。</p>
<span id="more"></span>
<p>ChatGPT 是由 OpenAI 开发的一种大型自然语言处理（NLP）模型</p>
<ol>
<li>
<p>可以回答关于各种话题的问题，例如历史、科学、文化等。它可以提供相关的信息和细节，并且能够根据上下文作出适当的回应。</p>
</li>
<li>
<p>可以参与自然对话，即能够与人类进行多轮交流，并作出相应的回应。它可以通过文本或语音与人类交流，并理解他们的意图，从而使对话更加流畅自然。</p>
</li>
<li>
<p>可以提供建议和帮助，例如在人类面临某些问题或困难时，它可以提供可行的解决方案。它可以理解人类的需求，并根据他们的问题提供适当的帮助。</p>
</li>
<li>
<p>可以作为学习工具，即人类可以通过与它交流来提高他们的语言能力和知识水平。它可以提供丰富的信息和知识，并且能够持续不断地学习和更新，从而为人类提供更多的学习机会。</p>
</li>
<li>
<p>可以作为客服或人工智能助手使用，即能够与人类进行交流，并帮助他们解决问题。它可以用于提供客户服务或帮助人们完成日常任务，从而提高工作效率和满意度。</p>
</li>
</ol>
<h2 id="前提条件">前提条件</h2>
<ol>
<li>
<p>Chrome 浏览器，下载地址 <a href="https://www.google.com/intl/zh-CN/chrome/">Google Chrome 网络浏览器 - https://www.google.com/intl/zh-CN/chrome/</a></p>
</li>
<li>
<p>微信账号，并通过微信支付实名认证。（虽然被封号的概率很小，稳妥起见建议使用小号，避免被微信封号造成不便）</p>
</li>
<li>
<p>ChatGPT 账号或者 OpenAI apikey，以及可以轻松访问 ChatGPT 的网络环境</p>
</li>
</ol>
<h2 id="如何使用">如何使用</h2>
<ol>
<li>打开微信网页版页面</li>
</ol>
<p>通过 Chrome Store 安装最新版插件，通过此地址 <a href="https://wx.qq.com/?target=t">https://wx.qq.com/?target=t</a> 访问微信网页版。注意：务必带上后面的请求参数<code>?target=t</code>！</p>
<ol start="2">
<li>打开 ChatGPT 的页面</li>
</ol>
<p>如果有 ChatGPT 账号，请保持页面 <a href="https://chat.openai.com">https://chat.openai.com</a> 处于登录状态</p>
<ol start="3">
<li>触发 ChatGPT 应答微信消息</li>
</ol>
<p>在微信群组或私信中 <code>@你的昵称</code> 验证是否能收到 ChatGPT 的回复，注意问题字数需要超过 2 个字</p>
<h2 id="套餐选择">套餐选择</h2>
<p>插件有 Free 免费版(仅限个人微信群使用) 和 Plus 付费版(仅限个人微信群使用)，以及 商业版（可用于付费或企业微信群）</p>
<p>推荐先使用 Free 免费版，体验一下 ChatGPT 的应答效果，如果觉得效果不错，根据个人情况可以升级到 Plus 付费版或商业版享受更多的功能。</p>
<p>其中 Free 免费版 功能包括：</p>
<ul>
<li>
<p>支持ChatGPT 网页版</p>
</li>
<li>
<p>支持ChatGPT API</p>
</li>
<li>
<p>API支持上下文</p>
</li>
</ul>
<p>Plus 付费版 在 Free 免费版 功能基础上提供：</p>
<ul>
<li>
<p>🌟 定义AI身份/角色</p>
</li>
<li>
<p>🌟 自定义单用户提问频率</p>
</li>
<li>
<p>🌟 自定义队列积压告警阈值</p>
</li>
</ul>
<p>商业版 在 Plus 付费版功能基础上继续提供：</p>
<ul>
<li>
<p>含所有Plus版本所有功能</p>
</li>
<li>
<p>过滤敏感词API</p>
</li>
<li>
<p>模型定制</p>
</li>
<li>
<p>定制其他需求</p>
</li>
</ul>
<h2 id="离线版安装">离线版安装</h2>
<p>可能由于网络限制，插件无法正常通过 Chrome Store 商店在线安装，可以下载插件离线版通过以下步骤安装：</p>
<ol>
<li>
<p>下载 插件离线版 <a href="https://pub-f4cbfca0366a4813ba52fcbadc32509b.r2.dev/cdlangplaophialnpfbdfndiobanklfd_free_v3.crx">https://pub-f4cbfca0366a4813ba52fcbadc32509b.r2.dev/cdlangplaophialnpfbdfndiobanklfd_free_v3.crx</a></p>
</li>
<li>
<p>修改为 <code>zip</code> 文件扩展名，将 <code>cdlangplaophialnpfbdfndiobanklfd_free_v3.crx</code> 重新命名为 <code>cdlangplaophialnpfbdfndiobanklfd_free_v3.zip</code></p>
</li>
<li>
<p>开启 Chrome 开发者模式，浏览器地址栏输入 <code>chrome://extensions/</code>，打开 Chrome 扩展程序页面，勾选右上角的“开发者模式”。</p>
</li>
<li>
<p>将 <code>cdlangplaophialnpfbdfndiobanklfd_free_v3.zip</code> 拖拽到 Chrome 扩展程序页面，完成插件安装</p>
</li>
</ol>
<h2 id="FAQs-常见问题">FAQs 常见问题</h2>
<h3 id="微信网页版无法登录怎么办？">微信网页版无法登录怎么办？</h3>
<p>如果你在访问微信网页版时出现这个提示：“为了保障你的帐号安全，暂不支持使用网页版微信。你可以前往微信官网 <a href="https://weixin.qq.com/">https://weixin.qq.com/</a> 下载客户端登录。”。</p>
<p>请按照以下步骤操作：</p>
<ol>
<li>
<p>打开微信网页版页面，地址：<a href="https://wx.qq.com/?target=t">https://wx.qq.com/?target=t</a>。注意：务必带上后面的请求参数<code>?target=t</code>！</p>
</li>
<li>
<p>请通过 Chrome Store 下载最新版的插件 <a href="https://chrome.google.com/webstore/detail/chatgpt-for-wechat/cdlangplaophialnpfbdfndiobanklfd">ChatGPT for WeChat - Chrome Web Store - https://chrome.google.com/webstore/detail/chatgpt-for-wechat/cdlangplaophialnpfbdfndiobanklfd</a></p>
</li>
</ol>
<h3 id="为什么-机器人，但是没有任何响应？">为什么@机器人，但是没有任何响应？</h3>
<ol>
<li>
<p>请在 Chrome 浏览器导航栏找到本插件的图标，点击图标，看弹窗中的 ChatGPT 页面是否处于登录状态。如果未登录，请尝试多点击几次插件图标。</p>
</li>
<li>
<p>插件对提问字数做了限制，问题内容（不包括@昵称）需要超过2个字符才会触发 ChatGPT 的响应。</p>
</li>
<li>
<p>检查自己的微信昵称中是否存在表情符号或其他特殊字符，如果存在请修改为简单的昵称，建议只用数字、字母或中文，修改完毕后刷新微信网页版页面。</p>
</li>
</ol>
<h3 id="为什么会收到“抱歉，ChatGPT-服务异常”的消息？">为什么会收到“抱歉，ChatGPT 服务异常”的消息？</h3>
<p>以下几种情况可能导致返回上面的错误提示：</p>
<ol>
<li>
<p>因为 ChatGPT 加了 Cloudflare 保护，每隔 2 小时需要刷新一下 ChatGPT 页面，如果用户提问后收到上述错误提示，说明 <a href="https://chat.openai.com/chat">https://chat.openai.com/chat</a> 页面需要刷新或重新登录。</p>
</li>
<li>
<p>因为 ChatGPT 的并发限制，一次只能发送一条消息。请在发送另一条消息之前等待其他问题的响应完成，或者等待一分钟。</p>
</li>
<li>
<p>因为 ChatGPT 自身的服务异常，导致请求出错或网络错误等原因。</p>
</li>
<li>
<p>因为网络原因，如使用网络优化软件等导致频繁出现 Cloudflare 错误，需自行解决。</p>
</li>
</ol>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://chrome.google.com/webstore/detail/chatgpt-for-wechat/cdlangplaophialnpfbdfndiobanklfd">ChatGPT for WeChat - Chrome Web Store - https://chrome.google.com/webstore/detail/chatgpt-for-wechat/cdlangplaophialnpfbdfndiobanklfd</a></p>
<p>[2] <a href="https://chatgpt4wechat.aow.me/">ChatGPT for WeChat, ChatGPT, 微信, 浏览器插件, 聊天机器人 - https://chatgpt4wechat.aow.me/</a></p>
<p>[3] <a href="https://chat.openai.com/chat">New chat - ChatGPT - https://chat.openai.com/chat</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>ChatGPT</category>
        <category>WeChat Bot</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>ChatGPT</tag>
        <tag>ChatGPT for WeChat</tag>
        <tag>Personal Assistant</tag>
        <tag>Google Chrome</tag>
        <tag>Chrome Web Store</tag>
        <tag>Google Chrome Extension</tag>
        <tag>WeChat</tag>
        <tag>WeChat Bot</tag>
      </tags>
  </entry>
  <entry>
    <title>[ChatGPT] ChatGPT 在线体验网站收集列表：国内用户的在线应用指南</title>
    <url>/2023/04/01/Artificial-Intelligence-AI/ChatGPT/Awesome/chatgpt-online-experience-websites-collection-a-guide-to-online-applications-for-chinese-users/</url>
    <content><![CDATA[<h1>ChatGPT 在线体验网站收集列表：国内用户的在线应用指南</h1>
<p>随着人工智能技术的飞速发展，ChatGPT等大型语言模型逐渐成为研究和实际应用的焦点。然而，国内用户在体验ChatGPT方面仍面临诸多门槛，如网络访问限制、账号注册困难等。为了帮助国内用户克服这些障碍，本文将为您介绍一系列在线应用网站，这些网站基于OPENAI API开发，供条件受限的朋友参考使用。</p>
<span id="more"></span>
<p>站点列表(2071)：</p>
<ol>
<li><a href="http://175.178.88.119/">[⭐⭐] http://175.178.88.119</a> **301 Moved Permanently。**免费访问chatgpt</li>
<li><a href="https://chat.binjie.site:7777/">[⭐⭐] https://chat.binjie.site:7777</a> **仅用于开发学习交流。**基于 GPT3 的在线对话应用（非 OpenAI GTP 3.5+），支持部分信息在线搜索</li>
<li><a href="https://modelscope.cn/">[⭐⭐] https://modelscope.cn</a> 魔塔社区（阿里达摩院）</li>
<li><a href="https://www.chatsverse.xyz/">[⭐⭐] https://www.chatsverse.xyz</a> <strong>ChatGPT。</strong></li>
<li><a href="https://chat.ninvfeng.xyz/">[⭐] https://chat.ninvfeng.xyz</a> <strong>ChatGPT Web。</strong></li>
<li><a href="http://chat.apigpt.cn/">[⭐] http://chat.apigpt.cn</a> <strong>紧急通知。</strong> <code>[error][-1]timeout</code></li>
<li><a href="http://itecheasy.com.cn/">[⭐] http://itecheasy.com.cn</a> <strong>ChatGpt-智能Ai。</strong> <code>[error][-1]connect ECONNREFUSED 157.240.11.40:80</code></li>
<li><a href="http://www.zzdsgroup.com/">[⭐] http://www.zzdsgroup.com</a> <code>[error][-1]socket hang up</code></li>
<li><a href="https://06.chat/">[⭐] https://06.chat</a> <strong>ChatGPT Web。</strong></li>
<li><a href="https://1ight.xyz/">[⭐] https://1ight.xyz</a></li>
<li><a href="https://1prompt.cn/">[⭐] https://1prompt.cn</a> ChatGPT</li>
<li><a href="https://2618.eu.org/">[⭐] https://2618.eu.org</a> **ImGood Web。**ChatGPT API Demo</li>
<li><a href="https://35.maogou.xyz/">[⭐] https://35.maogou.xyz</a> ChatGPT3.5</li>
<li><a href="https://94gpt.com/">[⭐] https://94gpt.com</a> <strong>加载页面中…。</strong></li>
<li><a href="https://achieve-dream.netlify.app/">[⭐] https://achieve-dream.netlify.app</a> <strong>ChatGPT API Demo。</strong></li>
<li><a href="https://ad1865.xyz/">[⭐] https://ad1865.xyz</a></li>
<li><a href="https://ai-toolbox.codefuture.top/">[⭐] https://ai-toolbox.codefuture.top</a> **AI帮个忙 | 多功能AI小帮手。**AI帮个忙：多功能AI小帮手</li>
<li><a href="https://ai.6ix.com/">[⭐] https://ai.6ix.com</a> <strong>6ixAI。</strong></li>
<li><a href="https://ai.91duoniu.cn/">[⭐] https://ai.91duoniu.cn</a> <strong>多牛AI。</strong></li>
<li><a href="https://ai.aiyuanyuzhou.com/">[⭐] https://ai.aiyuanyuzhou.com</a> <strong>正义的ChatGPT。</strong></li>
</ol>
<p>更多站点内容请移步 [<a href="https://github.com/weekend-project-space/chatgpt-sites">https://github.com/weekend-project-space/chatgpt-sites</a>](<a href="https://github.com/weekend-project-space/chatgpt-sites">https://github.com/weekend-project-space/chatgpt-sites</a>)</p>
<p>在线体验网站收集的主要来源</p>
<ol>
<li>网络手动搜集整理：通过网络搜索和人工筛选，搜集整理出一系列国内用户可访问的基于OPENAI API开发的在线应用网站。</li>
<li>热心网友推荐或自荐：欢迎网友自荐或推荐相关在线应用，您的应用将获得更多的曝光机会。通过这种方式，我们可以确保不错过任何优质的ChatGPT在线体验网站。</li>
<li>程序自动抓取开源仓库信息：定时任务每日更新，自动获取开源仓库中的相关信息，以确保我们的在线应用列表始终保持最新状态。</li>
</ol>
<p>ChatGPT在线体验网站收集列表的意义</p>
<ol>
<li>为国内用户提供便捷的ChatGPT体验途径：通过收集整理可访问的在线应用网站，让国内用户可以更加轻松地体验和使用ChatGPT。</li>
<li>促进国内外技术交流与合作：通过搭建在线应用网站，国内外研究者和开发者可以共同探讨ChatGPT的应用领域，共享最新的技术成果。</li>
<li>激发国内人工智能应用的创新与发展：提供了一个平台，让国内开发者可以基于OPENAI API进行创新性的应用开发，推动人工智能技术在国内的应用和普及。</li>
</ol>
<h2 id="参考链接">参考链接</h2>
<p>[1] [weekend-project-space/chatgpt-sites: 搜集国内可用的 ChatGPT 在线体验免费网站列表。定时任务每日更新，点击下面链接探索更多ai使用技巧和应用 - <a href="https://github.com/weekend-project-space/chatgpt-sites">https://github.com/weekend-project-space/chatgpt-sites</a>](<a href="https://github.com/weekend-project-space/chatgpt-sites">https://github.com/weekend-project-space/chatgpt-sites</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>ChatGPT</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>[ChatGPT] Docker Compose 快速部署基于 chatgpt-on-wechat 的 ChatGPT 的微信机器人</title>
    <url>/2023/03/11/Artificial-Intelligence-AI/ChatGPT/Awesome/deploying-chatgpt-on-wechat-using-docker-compose-for-a-quick-setup-of-your-wechat-bot/</url>
    <content><![CDATA[<h1>Docker Compose 快速部署基于 chatgpt-on-wechat 的 ChatGPT 的微信机器人</h1>
<p>chatgpt-on-wechat 是基于 ChatGPT 的微信聊天机器人，通过 ChatGPT 接口生成对话内容，使用 itchat 实现微信消息的接收和自动回复。已实现的特性如下：</p>
<ul>
<li>文本对话：  接收私聊及群组中的微信消息，使用 ChatGPT 生成回复内容，完成自动回复</li>
<li>规则定制化：支持私聊中按指定规则触发自动回复，支持对群组设置自动回复白名单</li>
<li>多账号：    支持多微信账号同时运行</li>
<li>图片生成：  支持根据描述生成图片，并自动发送至个人聊天或群聊</li>
<li>上下文记忆：支持多轮对话记忆，且为每个好友维护独立的上下会话</li>
<li>语音识别：  支持接收和处理语音消息，通过文字或语音回复</li>
</ul>
<p>chatgpt-on-wechat 适合 Python 开发者或者熟悉 Docker 或 Docker Compose 使用的用户</p>
<span id="more"></span>
<h2 id="前提条件">前提条件</h2>
<ol>
<li>Python 开发环境，或者 Docker 和 Docker Compose 的使用环境。本地或服务端均可，取决于你的使用场景</li>
<li>微信账号，并通过微信支付实名认证。（虽然被封号的概率很小，稳妥起见建议使用小号，避免被微信封号造成不便）</li>
<li>OpenAI apikey，以及可以轻松访问 ChatGPT 的网络环境</li>
</ol>
<h2 id="快速部署">快速部署</h2>
<ol>
<li>克隆项目代码：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zhayujie/chatgpt-on-wechat</span><br><span class="line"></span><br><span class="line">cd chatgpt-on-wechat/</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装依赖：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或手动单独安装依赖</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pip3 install itchat-uos==1.5.0.dev0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pip3 install --upgrade openai</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用 Docker 或者 Docker Compose 部署，可以跳过此步骤</p>
</blockquote>
<h2 id="配置">配置</h2>
<p>配置文件的模板在根目录的 <code>config-template.json</code> 中，需复制该模板创建最终生效的 <code>config.json 文件</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp config-template.json config.json</span><br></pre></td></tr></table></figure>
<p>然后在 <code>config.json</code> 中填入配置，以下是对默认配置的说明，可根据需要进行自定义修改：<br>
<code>config.json</code> 文件内容示例</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">  <span class="attr">&quot;open_ai_api_key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR API KEY&quot;</span><span class="punctuation">,</span>                          # 填入上面创建的 OpenAI API KEY</span><br><span class="line">  <span class="attr">&quot;proxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:7890&quot;</span><span class="punctuation">,</span>                                  # 代理客户端的ip和端口</span><br><span class="line">  <span class="attr">&quot;single_chat_prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;bot&quot;</span><span class="punctuation">,</span> <span class="string">&quot;@bot&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span>                      # 私聊时文本需要包含该前缀才能触发机器人回复</span><br><span class="line">  <span class="attr">&quot;single_chat_reply_prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;[bot] &quot;</span><span class="punctuation">,</span>                       # 私聊时自动回复的前缀，用于区分真人</span><br><span class="line">  <span class="attr">&quot;group_chat_prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;@bot&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span>                              # 群聊时包含该前缀则会触发机器人回复</span><br><span class="line">  <span class="attr">&quot;group_name_white_list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ChatGPT测试群&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ChatGPT测试群2&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> # 开启自动回复的群名称列表</span><br><span class="line">  <span class="attr">&quot;image_create_prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;画&quot;</span><span class="punctuation">,</span> <span class="string">&quot;看&quot;</span><span class="punctuation">,</span> <span class="string">&quot;找&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span>                   # 开启图片回复的前缀</span><br><span class="line">  <span class="attr">&quot;conversation_max_tokens&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span>                            # 支持上下文记忆的最多字符数</span><br><span class="line">  <span class="attr">&quot;character_desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你是ChatGPT, 一个由OpenAI训练的大型语言模型, 你旨在回答并解决人们的任何问题，并且可以使用多种语言与人交流。&quot;</span>  # 人格描述</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>配置说明：</p>
<p>1.个人聊天<br>
个人聊天中，需要以 <code>bot</code> 或 <code>@bot</code> 为开头的内容触发机器人，对应配置项 <code>single_chat_prefix</code> (如果不需要以前缀触发可以填写 <code>&quot;single_chat_prefix&quot;: [&quot;&quot;]</code>)</p>
<p>机器人回复的内容会以 <code>[bot] </code> 作为前缀， 以区分真人，对应的配置项为 <code>single_chat_reply_prefix</code> (如果不需要前缀可以填写<code>&quot;single_chat_reply_prefix&quot;: &quot;&quot;</code>)</p>
<p>2.群组聊天</p>
<p>群组聊天中，群名称需配置在 <code>group_name_white_list</code> 中才能开启群聊自动回复。如果想对所有群聊生效，可以直接填写 <code>&quot;group_name_white_list&quot;: [&quot;ALL_GROUP&quot;]</code></p>
<p>默认只要被人 <code>@</code> 就会触发机器人自动回复；另外群聊天中只要检测到以 <code>@bot</code> 开头的内容，同样会自动回复（方便自己触发），这对应配置项 group_chat_prefix</p>
<p>可选配置: <code>group_name_keyword_white_list</code> 配置项支持模糊匹配群名称，<code>group_chat_keyword</code> 配置项则支持模糊匹配群消息内容，用法与上述两个配置项相同。</p>
<p>3.语音识别</p>
<p>添加 <code>&quot;speech_recognition&quot;: true</code> 将开启语音识别，默认使用 openai 的 whisper 模型识别为文字，同时以文字回复，目前只支持私聊 (注意由于语音消息无法匹配前缀，一旦开启将对所有语音自动回复)；</p>
<p>添加 <code>&quot;voice_reply_voice&quot;: true</code> 将开启语音回复语音，但是需要配置对应语音合成平台的 key，由于 itchat 协议的限制，只能发送语音 mp3 文件，若使用 wechaty 则回复的是微信语音。</p>
<p>4.其他配置</p>
<p><code>proxy</code>：由于目前 openai 接口某些网络无法访问，需配置代理客户端的地址</p>
<p>对于图像生成，在满足个人或群组触发条件外，还需要额外的关键词前缀来触发，对应配置 <code>image_create_prefix</code></p>
<p>关于OpenAI对话及图片接口的参数配置（内容自由度、回复字数限制、图片大小等），可以参考 对话接口 和 图像接口 文档直接在 代码 <code>bot/openai/open_ai_bot.py</code> 中进行调整。</p>
<p><code>conversation_max_tokens</code>：表示能够记忆的上下文最大字数（一问一答为一组对话，如果累积的对话字数超出限制，就会优先移除最早的一组对话）</p>
<p><code>character_desc</code> 配置中保存着你对机器人说的一段话，他会记住这段话并作为他的设定，你可以为他定制任何人格</p>
<h2 id="Python-运行">Python 运行</h2>
<h3 id="本地运行">本地运行</h3>
<p>如果是开发机 本地运行，直接在项目根目录下执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 app.py</span><br></pre></td></tr></table></figure>
<p>终端输出二维码后，使用微信进行扫码，当输出 “Start auto replying” 时表示自动回复程序已经成功运行了（注意：用于登录的微信需要在支付处已完成实名认证）。扫码登录后你的账号就成为机器人了，可以在微信手机端通过配置的关键词触发自动回复 (任意好友发送消息给你，或是自己发消息给好友)，</p>
<h3 id="服务器运行">服务器运行</h3>
<p>使用 nohup 命令在后台运行程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup python3 app.py &amp; tail -f nohup.out          # 在后台运行程序并通过日志输出二维码</span><br></pre></td></tr></table></figure>
<p>扫码登录后程序即可运行于服务器后台，此时可通过 <code>ctrl+c</code> 关闭日志，不会影响后台程序的运行。使用 <code>ps -ef | grep app.py | grep -v grep</code> 命令可查看运行于后台的进程，如果想要重新启动程序可以先 kill 掉对应的进程。日志关闭后如果想要再次打开只需输入 <code>tail -f nohup.out</code>。</p>
<h2 id="Docker-或-Docker-Compose-运行">Docker 或 Docker Compose 运行</h2>
<p>首先创建或编辑 <code>Dockerfile</code> 文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>.<span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">        wget \</span></span><br><span class="line"><span class="language-bash">        curl &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> <span class="keyword">WORKDIR</span><span class="language-bash">=/app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p <span class="variable">$&#123;WORKDIR&#125;</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;WORKDIR&#125;</span></span></span><br><span class="line"><span class="keyword">ENV</span> <span class="keyword">WORKDIR</span><span class="language-bash">=<span class="variable">$&#123;WORKDIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirement.txt ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /usr/local/bin/python -m pip install --no-cache --upgrade pip -r requirement.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY config.json .</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . ./</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r noroot \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; useradd -r -g noroot -s /bin/bash -d /home/noroot noroot \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">chown</span> -R noroot:noroot <span class="variable">$&#123;WORKDIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> noroot</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="Docker-运行">Docker 运行</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 chatgpt-on-wechat 镜像</span></span><br><span class="line">docker build -t chatgpt-on-wechat .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 chatgpt-on-wechat 镜像</span></span><br><span class="line">docker run -it --rm -v $&#123;PWD&#125;/config.json:/app/config.json chatgpt-on-wechat</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-v $&#123;PWD&#125;/config.json:/app/config.json</code> 用于将本地的 <code>config.json</code> 文件挂载到容器内的 <code>/app/config.json</code> 文件，这样就可以在容器内使用本地的配置文件了。</p>
</blockquote>
<h3 id="Docker-Compose-运行">Docker Compose 运行</h3>
<p>创建或编辑 <code>docker-compose.yaml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yaml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">context:</span> <span class="string">./</span></span><br><span class="line">    <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">blogbin/chatgpt-on-wechat</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line"><span class="string">&quot;./config.json:/app/config.json&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行 docker-compose：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>
<h2 id="高级用法">高级用法</h2>
<ul>
<li>
<p>多账号支持： 将 项目复制多份，分别启动程序，用不同账号扫码登录即可实现同时运行。</p>
</li>
<li>
<p>特殊指令： 用户向机器人发送 <code>#清除记忆</code> 即可清空该用户的上下文记忆。</p>
</li>
</ul>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://github.com/zhayujie/chatgpt-on-wechat">zhayujie/chatgpt-on-wechat: 使用ChatGPT搭建微信聊天机器人，基于ChatGPT3.5 API和itchat实现。Wechat robot based on ChatGPT, which using OpenAI api and itchat library. - https://github.com/zhayujie/chatgpt-on-wechat</a></p>
<p>[2] <a href="https://chat.openai.com/chat">New chat - ChatGPT - https://chat.openai.com/chat</a></p>
<p>[3] <a href="https://github.com/why2lyj/ItChat-UOS">why2lyj/ItChat-UOS: 复活Itchat,你只需要 pip install itchat-uos - https://github.com/why2lyj/ItChat-UOS</a></p>
<p>[4] <a href="https://docs.docker.com/engine/reference/commandline/cli/">Use the Docker command line - https://docs.docker.com/engine/reference/commandline/cli/</a></p>
<p>[5] <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference - https://docs.docker.com/engine/reference/builder/</a></p>
<p>[6] <a href="https://docs.docker.com/compose/">Docker Compose overview - https://docs.docker.com/compose/</a></p>
<p>[7] <a href="https://www.python.org/">Welcome to Python.org - https://www.python.org/</a></p>
<p>[8] <a href="https://github.com/openai/openai-python">openai/openai-python: The OpenAI Python library provides convenient access to the OpenAI API from applications written in the Python language. - https://github.com/openai/openai-python</a></p>
]]></content>
      <categories>
        <category>WeChat Bot</category>
        <category>ChatGPT</category>
        <category>Artificial Intelligence (AI)</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Docker</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>ChatGPT</tag>
        <tag>Personal Assistant</tag>
        <tag>WeChat</tag>
        <tag>WeChat Bot</tag>
        <tag>Docker Compose</tag>
        <tag>chatgpt-on-wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>[ChatGPT] Glarity Summary: ChatGPT 技术在 YouTube 和 Google 搜索中的应用</title>
    <url>/2023/04/01/Artificial-Intelligence-AI/ChatGPT/Awesome/glarity-summary-the-application-of-chatgpt-technology-in-youtube-and-google-searches/</url>
    <content><![CDATA[<h1>Glarity Summary: ChatGPT 技术在 YouTube 和 Google 搜索中的应用</h1>
<p>人工智能技术的飞速发展正在深刻地改变着人们的生活方式，其中，大型语言模型ChatGPT成为了众多企业和开发者关注的焦点。近日，一款名为“Glarity Summary”的浏览器插件 [<a href="https://glarity.app/">https://glarity.app/</a>](<a href="https://glarity.app/">https://glarity.app/</a>) 悄然上线，它可以利用ChatGPT技术为用户提供YouTube视频和Google搜索内容的摘要，极大地提高了信息获取的效率。本文将为您详细解读这款插件背后的技术原理及其应用场景。</p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/433ecc90-15b2-49d4-9a31-114f66a36460/Glarity_Summary.jpg" alt="Glarity Summary.jpg"></p>
<h2 id="Glarity-Summary简介">Glarity Summary简介</h2>
<p>Glarity Summary是一款基于ChatGPT技术的YouTube和Google浏览器插件，可以对YouTube视频、Google搜索结果以及Yahoo! ニュース、PubMed、PMC、NewsPicks、Github、日经新闻、必应、Google专利等网站的内容进行摘要。如果用户无法选择OpenAI API模型，请删除并重新安装插件。目前，这款插件已经获得了3万多名用户的信赖。</p>
<h2 id="常见问题解答">常见问题解答</h2>
<ol>
<li>什么是ChatGPT？</li>
</ol>
<p>ChatGPT是由OpenAI开发的一种语言模型。它是一个大型的、经过预训练的基于Transformer的神经网络，旨在根据用户提供的提示生成类似于人类的文本。ChatGPT在广泛的互联网文本上进行训练，可以应对包括常识性问题、对话式回答以及创意写作等多种主题。</p>
<ol start="2">
<li>什么是Glarity Summary - ChatGPT for YouTube/Google？</li>
</ol>
<p>Glarity Summary - ChatGPT for YouTube/Google是一款浏览器插件，具有以下功能：</p>
<ul>
<li>在Google搜索结果中同时显示ChatGPT摘要。</li>
<li>在YouTube视频中显示ChatGPT摘要。</li>
</ul>
<ol start="3">
<li>使用Glarity Summary - ChatGPT for YouTube/Google是否免费？</li>
</ol>
<p>是的，这款插件是免费供用户使用的。</p>
<ol start="4">
<li>支持哪些网站？</li>
</ol>
<p>目前，Glarity支持Google、YouTube、Yahoo! ニュース、PubMed、PMC、NewsPicks、Github、日经新闻、必应、Google专利等网站的摘要。</p>
<ol start="5">
<li>我是否需要一个ChatGPT/OpenAI账户？</li>
</ol>
<p>是的，您需要拥有一个ChatGPT账户才能使用这款插件。您可以在<a href="https://chat.openai.com/">https://chat.openai.com/</a>上免费注册一个账户。</p>
<h2 id="Glarity-Summary的意义与价值">Glarity Summary的意义与价值</h2>
<ol>
<li>提高信息获取效率：通过为用户提供视频和搜索结果的摘要，Glarity Summary可以帮助用户更快地了解所需信息，提高信息获取效率。</li>
<li>节省时间和精力：用户无需花费大量时间观看完整视频或阅读完整文本，可以快速获取关键信息，从而节省了时间和精力。</li>
<li>丰富ChatGPT的应用场景：Glarity Summary的出现拓展了ChatGPT在实际应用中的可能性，为其他开发者提供了新的思路和灵感。</li>
<li>推动人工智能技术在日常生活中的应用：作为一款实用的浏览器插件，Glarity Summary有望进一步推动人工智能技术在日常生活中的广泛应用，提升人们的生活品质。</li>
</ol>
<h2 id="总结">总结</h2>
<p>Glarity Summary作为一款基于ChatGPT技术的浏览器插件，凭借其出色的信息摘要功能在YouTube、Google等多个平台中大放异彩，为用户节省了时间和精力。它的出现不仅丰富了ChatGPT的应用场景，还为人工智能技术在日常生活中的应用添砖加瓦。展望未来，我们有理由相信，随着更多类似的应用和技术不断涌现，人工智能将会对人类生活产生更深远的影响。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [Glarity Summary - ChatGPT for YouTube/Google (AD-Free) - <a href="https://glarity.app/">https://glarity.app/</a>](<a href="https://glarity.app/">https://glarity.app/</a>)</p>
<p>[2] [Glarity-Summary for Google/YouTube (ChatGPT) - Chrome Web Store - <a href="https://chrome.google.com/webstore/detail/glarity-summary-for-googl/cmnlolelipjlhfkhpohphpedmkfbobjc">https://chrome.google.com/webstore/detail/glarity-summary-for-googl/cmnlolelipjlhfkhpohphpedmkfbobjc</a>](<a href="https://chrome.google.com/webstore/detail/glarity-summary-for-googl/cmnlolelipjlhfkhpohphpedmkfbobjc">https://chrome.google.com/webstore/detail/glarity-summary-for-googl/cmnlolelipjlhfkhpohphpedmkfbobjc</a>)</p>
<p>[3] <a href="https://chat.openai.com/">https://chat.openai.com/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>ChatGPT</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>ChatGPT</tag>
        <tag>Glarity Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>[ChatGPT] Talk-to-ChatGPT: 用你的声音与 ChatGPT AI 交谈，并通过声音聆听它的回答</title>
    <url>/2023/02/11/Artificial-Intelligence-AI/ChatGPT/Awesome/talk-to-chatgpt-ai-using-your-voice-and-listen-to-its-answers-through-a-voice/</url>
    <content><![CDATA[<h1>Talk-to-ChatGPT: 用你的声音与 ChatGPT AI 交谈，并通过声音聆听它的回答</h1>
<blockquote>
<p>除了使用键盘输入，您还可以使用您的语音与 ChatGPT AI 进行对话，并通过语音收听机器人的回答。</p>
</blockquote>
<p>Talk-to-ChatGPT 是一个 Google Chrome 扩展程序，它允许用户使用他们的语音（语音识别）与 ChatGPT AI 交谈，并通过语音（文本到语音）而不是仅仅通过键入来收听机器人的回答。 使用此工具，用户可以与 AI 对话并接收语音回复，使交互感觉更加自然和对话。 这可能在各种环境中都很有用，在这些环境中，与 AI 进行更像人类的交互会很有帮助。</p>
<span id="more"></span>
<p>ChatGPT 是一个 AI 语言模型，它由 OpenAI 训练。它可以用于提供各种类型的语言服务，例如回答问题、提供建议、自然语言生成、翻译等。它在不同领域的知识上进行了广泛的训练，以便能够应对各种类型的问题。</p>
<h2 id="安装">安装</h2>
<p>Talk-to-ChatGPT Google Chrome 扩展程序可以从此处的 Chrome 网上商店下载：<a href="https://chrome.google.com/webstore/detail/talk-to-chatgpt/hodadfhfagpiemkeoliaelelfbboamlk">Talk-to-ChatGPT - Chrome Web Store.- https://chrome.google.com/webstore/detail/talk-to-chatgpt/hodadfhfagpiemkeoliaelelfbboamlk</a></p>
<p>安装 Google Chrome 扩展程序后，打开或重新加载 <a href="https://chat.openai.com/chat">ChatGPT 页面 - https://chat.openai.com/chat</a>，您应该会在页面右上角看到“Start”按钮。 单击“Start”后，系统会要求您授予使用麦克风的权限。 这是启用语音识别所必需的。</p>
<p><img src="../images/ChatGPT/Talk-to-ChatGPT/main.jpg" alt="Talk-to-ChatGPT Main"></p>
<h2 id="Talk-to-GPT-菜单">Talk-to-GPT 菜单</h2>
<p>启动后，Talk-to-ChatGPT 会在页面右上角显示一个菜单，用户可以在其中访问设置（例如语音、语言等）、跳过当前消息、打开或关闭语音识别以及切换文本 -打开或关闭语音转换。</p>
<p>设置菜单如下所示。 设置保存在 cookie 中，并在您每次激活脚本时自动重新加载。</p>
<p><img src="../images/ChatGPT/Talk-to-ChatGPT/settings.jpg" alt="Talk-to-ChatGPT Setting"><br>
演示（英语+法语）v1.6：<a href="https://www.youtube.com/watch?v=VXkLQMEs3lA">https://www.youtube.com/watch?v=VXkLQMEs3lA</a></p>
<h2 id="常问问题">常问问题</h2>
<p>问：你能让它说话更快或用不同的声音或语言吗？</p>
<p>答：是的，使用设置菜单。 您可以选择多种设置，其中包括语速、语音类型和语言。</p>
<p>问：这个项目的目的是什么？</p>
<p>答：好玩，除此之外别无其他。 这个 AI 非常聪明，我很想和它进行口头交流，让它变得更有趣。 这只是一个概念证明。 当然，OpenAI 自己将来会为此制作一个合适的版本，到那时我的项目将完全无用。</p>
<p>问：使用安全吗？<br>
答：这是简单的 javascript 代码，只会在 ChatGPT 网页的上下文中执行。 一旦你离开，一切都被清除。 javascript 代码是开源的，所以请随时查看它的作用。</p>
<p>问：它会一直有效吗？</p>
<p>答：它可能不会无限期地工作，这就是原因。 该代码基于 ChatGPT 页面的当前 HTML 结构。 如果 OpenAI 更改 HTML 代码，这个项目可能会停止工作。 它可能会不断更新它以保持兼容性，但我不确定我会永远这样做。 如果您想为该项目做出贡献，我们非常欢迎您通过 Github 提交您自己的更改。</p>
<p>问：我有错误或问题…</p>
<p>答：您可以自行更新 javascript 并在 Github 上提出更改建议，或者如果您不是程序员，则只需报告问题。</p>
<p>问：我可以更改您的代码吗？</p>
<p>答：是的，随时进行更改，做任何你想做的事，commit，fork，玩得开心。</p>
<p>问：我如何知道支持哪些语言？</p>
<p>答：这完全是基于谷歌浏览器的API，所以你需要问谷歌，我无法提供最新的答案。 我只用英语和法语测试过它。 设置菜单中的语言与谷歌演示中的语言相同。</p>
<h2 id="新闻报道">新闻报道</h2>
<p>Talk-to-ChatGPT 自发布以来一直受到媒体报道。 它目前在以下网站上有特色：</p>
<p>JustGeek - <a href="https://www.justgeek.fr/talk-to-chatgpt-discuter-a-voix-haute-avec-chatgpt-103657/">https://www.justgeek.fr/talk-to-chatgpt-discuter-a-voix-haute-avec-chatgpt-103657/</a></p>
<p>评论 Ca Marche - [<a href="https://www.commentcamarche.net/informatique/technologies/27295-application-et-extension-vocale-chatgpt-de-nouveaux-outils-pour-l-ia/#talk-to-chatgpt--">https://www.commentcamarche.net/informatique/technologies/27295-application-et-extension-vocale-chatgpt-de-nouveaux-outils-pour-l-ia/#talk-to-chatgpt--</a> discuter-a-haute-voix-avec-lia](<a href="https://www.commentcamarche.net/informatique/technologies/27295-application-et-extension-vocale-chatgpt-de-nouveaux-outils-pour-l-ia/#talk-to-chatgpt--">https://www.commentcamarche.net/informatique/technologies/27295-application-et-extension-vocale-chatgpt-de-nouveaux-outils-pour-l-ia/#talk-to-chatgpt--</a> discuter-a-haute-voix-avec-lia)</p>
<p>GBAtemp - <a href="https://gbatemp.net/threads/talk-to-chatgpt-actual-vocal-discussion-with-an-ai-using-voice-recognition-and-text-to-speech-in-chrome.622942/">https://gbatemp.net/threads/talk-to-chatgpt-actual-vocal-discussion-with-an-ai-using-voice-recognition-and-text-to-speech-in-chrome.622942/</a></p>
<p>此列表将随时间更新。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://chrome.google.com/webstore/detail/talk-to-chatgpt/hodadfhfagpiemkeoliaelelfbboamlk">Talk-to-ChatGPT - Chrome Web Store.- https://chrome.google.com/webstore/detail/talk-to-chatgpt/hodadfhfagpiemkeoliaelelfbboamlk</a></p>
<p>[2] <a href="https://github.com/C-Nedelcu/talk-to-chatgpt">GitHub - C-Nedelcu/talk-to-chatgpt: Talk to ChatGPT AI using your voice and listen to its answers through a voice - https://github.com/C-Nedelcu/talk-to-chatgpt</a></p>
<p>[3] <a href="https://chat.openai.com/chat">New chat - https://chat.openai.com/chat</a></p>
]]></content>
      <categories>
        <category>ChatGPT</category>
        <category>Artificial Intelligence (AI)</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Artificial Intelligence</tag>
        <tag>ChatGPT</tag>
        <tag>Google Chrome</tag>
        <tag>Chrome Web Store</tag>
        <tag>Google Chrome Extension</tag>
        <tag>Speech Recognition</tag>
        <tag>Text-to-Speece</tag>
        <tag>Voice</tag>
        <tag>Talk-to-ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>[Microsoft] Microsoft Bing 发布 Image Creator 图像创建者 - 人工智能（AI）图片生成工具</title>
    <url>/2023/03/21/Artificial-Intelligence-AI/Microsoft/Bing/microsoft-bing-releases-image-creator-ai-powered-image-generation-tool/</url>
    <content><![CDATA[<h1>Microsoft Bing 发布 Image Creator 图像创建者 - 人工智能（AI）图片生成工具</h1>
<p>今天 Microsoft Bing 发布了一款名为 Image Creator 图像创建者 的人工智能（AI）图片生成工具（预览版）。这款产品利用 DALL-E 技术，根据用户输入的文本提示生成一系列与之相匹配的图像。如今，将创意变成现实变得更加简单，无论是设计师、艺术家还是普通用户，都可以轻松生成独特的 AI 图像。</p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f74fd498-e49c-47ab-8fdd-b153cbef65b2/Bing_Images_Create.png" alt="Bing Images Create.png"></p>
<p>使用 Image Creator 的方法非常简单。用户只需注册一个新的 Microsoft 帐户或登录到现有的 Microsoft 帐户 [<a href="https://account.microsoft.com/account?lang=zh-cn">https://account.microsoft.com/account</a>](<a href="https://account.microsoft.com/account?lang=zh-cn">https://account.microsoft.com/account</a>)。新用户将获得 25 个提速生成（积分），可以立即体验 Image Creator 的强大功能。输入任意文本描述，AI 就会生成一组与描述相匹配的图像。</p>
<p>假设要为 CloudoLife 面向云生活设计一个 Logo。尝试输入</p>
<p>Create a logo for Cloud-oriented Life organization</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/301df169-6d8f-4cba-8005-7adf2d848f01/Untitled.png" alt="Untitled"></p>
<p>值得一提的是，Image Creator 无需等待名单或预付费用，Microsoft Bing 致力于让所有人都能享受到 AI 生成的图像。目前，Image Creator 仅支持英语提示，但未来有望支持更多语言。</p>
<p>为了获得更好的生成效果，建议用户在创建提示时充分发挥想象力，提供高度描述性的信息。这意味着可以添加形容词、位置，甚至艺术风格等细节。例如，与其使用简单的 “creature”（生物）作为提示，不如尝试输入 “fuzzy creature wearing sunglasses, digital art”（戴着太阳镜的毛茸茸生物，数字艺术）。</p>
<p>此外，Image Creator 还与 Microsoft Rewards 紧密结合。用户在用完提速后，可以选择使用 Microsoft Rewards 兑换更多提速并享受更快的处理时间。</p>
<p>如果对 Image Creator 有其他疑问，可以访问帮助页面获取关于内容政策、如何负责任地处理 AI 等方面的更多答案。</p>
<p>总之，Microsoft Bing 的 Image Creator 「图像创建者」为用户提供了一个简单易用的 AI 图片生成工具，使图像创作不再受限于专业技能。随着 AI 技术的不断发展，我们有理由相信 Image Creator 及类似工具将继续推动创意产业的进步。</p>
<h2 id="常见问题">常见问题</h2>
<ol>
<li>
<p>Image Creator 是什么？<br>
Image Creator 是一个帮助用户使用 DALL-E 生成 AI 图像的产品。给定一个文本提示，我们的 AI 将生成一组与该提示相匹配的图像。</p>
</li>
<li>
<p>如何使用 Image Creator？<br>
注册一个新的 Microsoft 帐户或登录到您现有的 Microsoft 帐户。新用户将获得 25 个 Image Creator 提速生成。输入任何您能想到的文本描述以创建一组 AI 生成的图像并享受吧！</p>
</li>
<li>
<p>使用 Image Creator 是否有等待名单？<br>
没有等待名单或预付费用。我们致力于让所有人都能使用 AI 生成的图像。所以，任何人都可以将他们的想法变成图像。</p>
</li>
<li>
<p>支持哪些语言？<br>
目前，Image Creator 仅支持英语提示。我们将在未来支持其他语言。</p>
</li>
<li>
<p>如何创建更好的提示？<br>
Image Creator 与在 Bing 中搜索图像不同。<br>
当您高度描述时，它的效果最佳。因此，发挥创意并添加细节：形容词、位置，甚至艺术风格，如“digital art”(数字艺术)和“photorealistic”(逼真的)。<br>
这是一个例子：尝试提交一个 “fuzzy creature wearing sunglasses, digital art”（戴着太阳镜的毛茸茸生物，数字艺术）的提示，而不是一个&quot;creature&quot;（生物）的文本提示。</p>
</li>
<li>
<p>Microsoft Rewards 如何与 Image Creator 一起使用？<br>
如果您用完了提速，您可以选择使用 Microsoft Rewards 兑换更多提速并享受更快的处理时间。当您在 Image Creator 中用完提速时，也会提醒您可以兑换 Microsoft Rewards 积分以获得更多提速的选项。</p>
</li>
<li>
<p>如果我对 Image Creator 有其他问题怎么办？<br>
如果您对我们的内容政策、如何负责任地处理 AI 或其他方面感兴趣，请访问我们的帮助页面以获取更多答案。</p>
</li>
</ol>
<h2 id="参考链接">参考链接</h2>
<p>[1] [Image Creator from Microsoft Bing - <a href="https://www.bing.com/images/create">https://www.bing.com/images/create</a>](<a href="https://www.bing.com/images/create">https://www.bing.com/images/create</a>)</p>
<p>[2] [Microsoft 帐户 | Sign In or Create Your Account Today – Microsoft - <a href="https://account.microsoft.com/account?lang=zh-cn">https://account.microsoft.com/account</a>](<a href="https://account.microsoft.com/account?lang=zh-cn">https://account.microsoft.com/account</a>)</p>
<p>[3] [DALL·E 2 - <a href="https://openai.com/product/dall-e-2">https://openai.com/product/dall-e-2</a>](<a href="https://openai.com/product/dall-e-2">https://openai.com/product/dall-e-2</a>)</p>
<p>[4] [Reward yourself, make a difference with Microsoft Rewards - <a href="https://www.microsoft.com/en-us/rewards">https://www.microsoft.com/en-us/rewards</a>](<a href="https://www.microsoft.com/en-us/rewards">https://www.microsoft.com/en-us/rewards</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Microsoft</category>
        <category>Bing</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Microsoft</tag>
        <tag>Bing</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>Image Creator</tag>
        <tag>DALL-E</tag>
      </tags>
  </entry>
  <entry>
    <title>[Microsoft] Microsoft Loop: 重塑协作方式的全新应用</title>
    <url>/2023/03/24/Artificial-Intelligence-AI/Microsoft/Loop/microsoft-loop-a-new-application-reshaping-collaborative-work/</url>
    <content><![CDATA[<h1>Microsoft Loop: 重塑协作方式的全新应用</h1>
<p>随着数字化时代的不断发展，我们的工作方式也在不断地变革着。人们需要在不同的设备、不同的地点、不同的时间进行协作，而这些协作需要一个便捷、高效、安全的工具来实现。为了满足这一需求，Microsoft 推出了全新的应用程序——Microsoft Loop。</p>
<span id="more"></span>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c2836215-7256-4571-9d6e-f62b9c531a32/Loop-hero-image.jpg" alt="Loop-hero-image.jpg"></p>
<p>[Microsoft Loop: Collaborative App | Microsoft 365 - <a href="https://www.microsoft.com/en-us/microsoft-loop">https://www.microsoft.com/en-us/microsoft-loop</a>](<a href="https://www.microsoft.com/en-us/microsoft-loop">https://www.microsoft.com/en-us/microsoft-loop</a>)</p>
<p>Microsoft Loop 是一个为现代协作而打造的应用程序，旨在为用户提供全新的协作体验。通过 Loop，用户可以更轻松地创建、共享和协作各种类型的内容，包括文本、图像、音频和视频等等。此外，Loop 还提供了实时的协作功能，用户可以在同一个页面上实时地共享和编辑内容，从而提高协作效率和质量。</p>
<p>Loop 的设计理念是“简单、开放、安全”。在使用 Loop 时，用户可以选择使用任何设备，无论是 Windows PC、Mac、iPad、iPhone 还是 Android 设备，都可以轻松地进行协作。此外，Loop 还支持第三方应用程序的集成，用户可以在 Loop 中直接访问他们的文档、表格、演示文稿等等。</p>
<p>Loop 还提供了一些强大的功能，使用户能够更轻松地管理他们的内容。例如，Loop 提供了“卡片视图”，用户可以将不同的内容组织成卡片，并在不同的卡片之间轻松切换。此外，Loop 还提供了“时间线视图”，用户可以在时间线上查看和跟踪他们的工作进度。这些功能让用户能够更好地管理他们的工作流程，提高工作效率。</p>
<p>Microsoft Loop 与 Microsoft 365 Copilot 结合，为用户提供了更强大的协作能力和智能化的协作体验。Microsoft 365 Copilot 是一个新的 AI 功能，结合了 Microsoft 365 应用和数据的强大功能，为用户提供更好的协作体验。而在 Loop 中，Copilot 为用户提供了 AI 提供的建议和提示，帮助用户更轻松地创建和协作各种类型的内容。</p>
<p>例如，Copilot in Loop 提供了多种提示，如“创建”、“头脑风暴”、“蓝图”和“描述”，还可以直接输入问题来获取帮助，例如“帮我创建一份任务声明”。用户可以随时返回到先前的提示，添加语言来细化输出，并编辑生成的响应，以获得更好、更个性化的结果。同时，用户可以将他们的工作作为 Loop 组件共享给团队成员，以满足他们在 Teams、Outlook、Whiteboard 或 Word for the web 等平台上的需要。</p>
<p>除了提供协作建议，Copilot in Loop 还提供了摘要功能。它可以帮助用户快速理解重要信息，通过摘要内容来让大家更好地理解 Loop 页面和链接在工作空间中的文档内容。用户可以编辑摘要来添加更多细节或上下文，并将它们作为 Loop 组件发送给其他人，以保持团队的同步。这一功能将在未来几个月内逐步推出。</p>
<p>Loop 还提供了安全、私密的协作环境。Loop 使用 Microsoft 的安全技术来保护用户的内容和隐私，用户可以放心地在 Loop 中进行协作。此外，Loop 还提供了灵活的权限控制功能，用户可以自定义谁可以查看、编辑和共享他们的内容。这让用户能够更好地控制他们的内容，并保护他们的隐私。</p>
<p>Microsoft Loop 还提供了类似于即时通讯软件的实时协作功能。用户可以在文档内直接与合作伙伴进行聊天、评论和共享意见。这种实时的交流方式可以大大提高团队的协作效率和沟通效果，让每个成员都能够更好地理解项目的进展情况。</p>
<p>除了支持实时协作外，Microsoft Loop 还支持多种不同类型的文档。用户可以选择创建文本文档、表格、演示文稿等多种类型的文档。同时，Microsoft Loop 还内置了大量的模板，以帮助用户更快地创建出符合自己需求的文档。这些模板可以让用户在不了解设计原则的情况下，轻松地创建出美观、规范的文档。</p>
<p>对于需要大量协作和交流的项目，Microsoft Loop 还提供了强大的集成功能。用户可以轻松将 Loop 与其他应用程序、服务和工具集成在一起，以提高工作效率和协作质量。此外，Loop 还支持多个设备间同步，用户可以在手机、平板电脑、笔记本电脑等多个设备上随时随地访问自己的文档和项目。</p>
<p>除此之外，Microsoft Loop 还支持多语言功能。用户可以选择不同的语言环境，以便更好地适应不同的文化背景和语言需求。这使得 Microsoft Loop 可以更好地服务于全球用户，促进跨文化交流和协作。</p>
<p>总之，Microsoft Loop 是一款功能强大、易于使用的协作工具，旨在为用户提供更高效、更智能的工作方式。其提供的实时协作、多种文档类型和集成功能等，可以帮助用户更好地完成协作任务，提高工作效率和质量。随着微软公司的不断发展，我们相信 Microsoft Loop 将会在未来不断升级和优化，为用户带来更多的惊喜和便利。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [Microsoft Loop: Collaborative App | Microsoft 365 - <a href="https://www.microsoft.com/en-us/microsoft-loop">https://www.microsoft.com/en-us/microsoft-loop</a>](<a href="https://www.microsoft.com/en-us/microsoft-loop">https://www.microsoft.com/en-us/microsoft-loop</a>)</p>
<p>[2] [New Microsoft Loop app is built for co-creation | Microsoft 365 Blog - <a href="https://www.microsoft.com/en-us/microsoft-365/blog/2023/03/22/new-microsoft-loop-app-is-built-for-modern-co-creation/">https://www.microsoft.com/en-us/microsoft-365/blog/2023/03/22/new-microsoft-loop-app-is-built-for-modern-co-creation/</a>](<a href="https://www.microsoft.com/en-us/microsoft-365/blog/2023/03/22/new-microsoft-loop-app-is-built-for-modern-co-creation/">https://www.microsoft.com/en-us/microsoft-365/blog/2023/03/22/new-microsoft-loop-app-is-built-for-modern-co-creation/</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Microsoft</category>
        <category>Loop</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>Microsoft</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>Loop</tag>
      </tags>
  </entry>
  <entry>
    <title>[OpenAI] Chat Chat: 一个与 OpenAI 交互的开源网站</title>
    <url>/2023/03/22/Artificial-Intelligence-AI/OpenAI/Awesome/chat-chat-an-open-source-website-for-interacting-with-openai/</url>
    <content><![CDATA[<h1>Chat Chat: 一个与 OpenAI 交互的开源网站</h1>
<p>今天推荐一款 OpenAI 相关的一个网页软件 [<a href="https://chat.okis.dev/">https://chat.okis.dev/</a>](<a href="https://chat.okis.dev/">https://chat.okis.dev/</a>)。</p>
<p>Chat Chat 并不是一个套壳应用程序，只需要 OpenAI API 即可免费使用。它希望通过多种方式利用人工智能重建用户体验，并利用 GPT 生成响应，使与 AI 的交互更加容易。未来将添加越来越多的功能与 AI 协作。</p>
<span id="more"></span>
<p>Chat Chat这款AI对话软件旨在为用户提供与 OpenAI 的互动体验。Chat Chat拥有几项功能，包括支持对话式聊天，支持上传PDF进行解读分析问答以及支持代码提问转换等。无论是休闲娱乐、学术研究，还是软件开发还是，Chat Chat都能为用户提供解决方案。</p>
<p>Chat Chat支持传统的对话式聊天。用户可以与AI进行实时互动，从而获得丰富多样的信息和知识。在这个过程中，AI会根据用户的问题和需求，为其提供个性化的解答和建议。这项功能为用户提供了一个全新的、与AI互动的方式，拓展了人们与AI互动的领域。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/25ac7712-4ba7-4b65-8aa3-11970002502d/Chat.png" alt="Chat.png"></p>
<p>Chat Chat的AI技术主要基于最先进的GPT和代码解释转换技术，为用户带来了智能化的对话平台。用户可以上传PDF文件，AI将自动解读文件内容并为用户提供相关的问答功能。这项功能对于学术研究者和专业人士来说是一个巨大的优势，可以大大节省时间和精力。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7515ea31-a9a1-44ac-8dc2-e9b622df8986/PDF.png" alt="PDF.png"></p>
<p>此外，Chat Chat还支持代码提问转换功能。开发者可以直接在聊天界面输入代码或相关问题，AI将智能地为用户提供解答或转换为相应的代码。这项功能为程序员提供了一个强大的工具，可以提高工作效率，同时也为初学者提供了一个友好的学习环境。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e68149ba-79dd-4181-9d56-121d695a104c/Code.png" alt="Code.png"></p>
<p>Chat Chat非常注重用户体验，并为用户提供了免费的API使用额度。每日都会有免费的API额度供用户直接使用，无需支付任何费用。这使得更多人能够免费体验到AI带来的知识冲击，享受到人工智能所带来的便捷。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [Chat Chat - Unlock next-level conversations with AI - <a href="https://chat.okis.dev/">https://chat.okis.dev/</a>](<a href="https://chat.okis.dev/">https://chat.okis.dev/</a>)</p>
<p>[2] [Account API Keys - OpenAI API - <a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a>](<a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>OpenAI</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>OpenAI</tag>
        <tag>Chat Chat</tag>
      </tags>
  </entry>
  <entry>
    <title>[OpenAI] Immersive Translate 沉浸式双语网页翻译扩展：跨越语言障碍的高效工具</title>
    <url>/2023/04/10/Artificial-Intelligence-AI/OpenAI/Awesome/immersive-translate-efficient-tool-overcoming-language-barriers-bilingual-web-page-translation-extension/</url>
    <content><![CDATA[<h1>Immersive Translate 沉浸式双语网页翻译扩展：跨越语言障碍的高效工具</h1>
<p>在这个全球化的时代，我们越来越需要掌握不同语言的信息，而 Immersive Translate 沉浸式双语网页翻译扩展正是一款能帮助我们轻松突破语言障碍的工具。让我们一起了解这款扩展的特点、如何使用以及如何安装。</p>
<span id="more"></span>
<p><a href="https://immersive-translate.owenyoung.com/assets/immersive-translate-intro-demo.mp4">https://immersive-translate.owenyoung.com/assets/immersive-translate-intro-demo.mp4</a></p>
<h2 id="主要特性">主要特性</h2>
<ol>
<li>智能识别网页主内容区进行翻译：与同类插件翻译整个网页不同，沉浸式翻译扩展能够降低对原网页的“侵入性”，提升阅读体验。</li>
<li>双语显示，中英文对照：让用户在阅读外文时更容易理解内容。</li>
<li>针对常见主流网站进行定制优化：如 Twitter，Reddit，Discord, Gmail, Telegram, Youtube, Hacker News 等。</li>
<li>支持 10 余种常用翻译服务：包括 Deepl，OpenAI(ChatGPT 3.5)，谷歌，彩云小译，腾讯翻译君，百度翻译，火山翻译等。</li>
<li>支持 PDF 文件，EPUB 电子书双语翻译，制作与导出。</li>
<li>全平台浏览器支持：包括桌面端、移动端，iOS 端，Chrome、Edge、Firefox，Safari 等。</li>
<li>提供多种译文样式选择：如弱化、模糊、下划线、分隔线等样式，个性化定制翻译体验。</li>
</ol>
<h2 id="安装">安装</h2>
<ul>
<li>Chrome 浏览器（包括类 Chrome 浏览器）：点击进入 Chrome 商店安装。[Immersive Translate - Chrome Web Store - <a href="https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh/related">https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh/related</a>](<a href="https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh/related">https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh/related</a>)</li>
</ul>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d47c4f9-91e2-4866-ab4f-89bff16ffd6b/Untitled.png" alt="Untitled"></p>
<ul>
<li>Edge 浏览器：点击进入 Edge 商店安装。[沉浸式翻译 - Microsoft Edge Addons - <a href="https://microsoftedge.microsoft.com/addons/detail/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%BF%BB%E8%AF%91/amkbmndfnliijdhojkpoglbnaaahippg?hl=zh-CN">https://microsoftedge.microsoft.com/addons/detail/沉浸式翻译/amkbmndfnliijdhojkpoglbnaaahippg?hl=zh-CN</a>](<a href="https://microsoftedge.microsoft.com/addons/detail/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%BF%BB%E8%AF%91/amkbmndfnliijdhojkpoglbnaaahippg?hl=zh-CN">https://microsoftedge.microsoft.com/addons/detail/沉浸式翻译/amkbmndfnliijdhojkpoglbnaaahippg?hl=zh-CN</a>)</li>
<li>Firefox：点击进入 Firefox Addon 商店安装。[Immersive Translate - 沉浸式翻译 - 双语对照网页翻译 – Get this Extension for 🦊 Firefox (en-US) - <a href="https://addons.mozilla.org/en-US/firefox/addon/immersive-translate/">https://addons.mozilla.org/en-US/firefox/addon/immersive-translate/</a>](<a href="https://addons.mozilla.org/en-US/firefox/addon/immersive-translate/">https://addons.mozilla.org/en-US/firefox/addon/immersive-translate/</a>)</li>
</ul>
<h2 id="使用">使用</h2>
<p>安装插件后，右上角点击【沉浸式翻译扩展图标】，点击翻译即可进行翻译。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0ceddf49-524b-4cff-bec7-4eeb6a53ff0f/Untitled.png" alt="Untitled"></p>
<p>或者，在网页里右键，选择【翻译网页/显示原文】进行翻译。</p>
<p>支持快捷键操作：默认快捷键为 Alt+A（翻译/切换原文）和 Alt+W（翻译整个页面，而不是默认的智能翻译内容区域）。如果默认快捷键与其他软件冲突，可以在扩展的【设置页面 - 界面设置 - 快捷键管理】中修改。</p>
<p>Epub 电子书阅读和双语导出：点击插件图标 ——&gt; 更多，选择“阅读电子书”（支持 Epub，Mobi 等常见格式）或者“制作双语 Epub 电子书”。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6e81c8d3-8491-46de-9bbd-fc83c040327e/Untitled.png" alt="Untitled"></p>
<p>PDF 文件翻译：目前只支持简单的单列 PDF 翻译，复杂的 PDF 建议使用相关工具转为 HTML 后，再由插件翻译。推荐一个超级好用且免费的开源软件 calibre，可以把 pdf 转为 epub 或 html，效果非常赞。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f8f765ce-4e1e-4aae-b2f4-b4d224c84226/Untitled.png" alt="Untitled"></p>
<h2 id="优势与影响">优势与影响</h2>
<p>优势：</p>
<ul>
<li>智能识别网页主内容区进行翻译，降低对原网页的“侵入性”，提升阅读体验。</li>
<li>双语显示，中英文对照，方便用户对照学习。</li>
<li>针对常见主流网站进行定制优化，适应性更强。</li>
<li>支持多种翻译服务，满足用户不同需求。</li>
<li>全平台浏览器支持，无论桌面端、移动端，都可以轻松使用。</li>
<li>提供多种译文样式选择，个性化定制翻译体验。</li>
</ul>
<p>影响：</p>
<ul>
<li>通过沉浸式双语网页翻译扩展，用户可以更轻松、愉悦、优雅地获取互联网上海量的外文信息，打破语言障碍。</li>
<li>促使其他翻译工具提高翻译质量和用户体验，从而推动整个翻译行业的进步。</li>
<li>让用户更加便捷地进行跨语言交流，促进全球化进程。</li>
</ul>
<h2 id="总结">总结</h2>
<p>沉浸式双语网页翻译扩展是一款强大的翻译工具，能够智能识别网页主内容区进行翻译，提供双语显示和多种译文样式选择。同时，针对常见主流网站进行定制优化，支持多种翻译服务，如 Deepl、OpenAI(ChatGPT 3.5)、谷歌、彩云小译、腾讯翻译君、百度翻译、火山翻译等。全平台浏览器支持，包括桌面端、移动端，iOS 端，Chrome、Edge、Firefox、Safari 等。</p>
<p>沉浸式双语网页翻译扩展的推出，为用户提供了一个优雅、高效的翻译工具，使得获取互联网上的外文信息变得更加轻松。同时，它也推动了整个翻译行业的发展，让人们越来越不受语言障碍的困扰。无论是学习、工作还是娱乐，沉浸式双语网页翻译扩展都将是用户的得力助手。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [Immersive Translate - Chrome Web Store - <a href="https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh/related">https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh/related</a>](<a href="https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh/related">https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh/related</a>)</p>
<p>[2] [介绍 - 沉浸式翻译 - <a href="https://immersive-translate.owenyoung.com/">https://immersive-translate.owenyoung.com/</a>](<a href="https://immersive-translate.owenyoung.com/">https://immersive-translate.owenyoung.com/</a>)</p>
<p>[3] [immersive-translate/immersive-translate: Immersive Dual Web Page Translation Extension - 沉浸式双语网页翻译扩展 - <a href="https://github.com/immersive-translate/immersive-translate">https://github.com/immersive-translate/immersive-translate</a>](<a href="https://github.com/immersive-translate/immersive-translate">https://github.com/immersive-translate/immersive-translate</a>)</p>
<p>[4] [沉浸式翻译 - Microsoft Edge Addons - <a href="https://microsoftedge.microsoft.com/addons/detail/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%BF%BB%E8%AF%91/amkbmndfnliijdhojkpoglbnaaahippg?hl=zh-CN">https://microsoftedge.microsoft.com/addons/detail/沉浸式翻译/amkbmndfnliijdhojkpoglbnaaahippg?hl=zh-CN</a>](<a href="https://microsoftedge.microsoft.com/addons/detail/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%BF%BB%E8%AF%91/amkbmndfnliijdhojkpoglbnaaahippg?hl=zh-CN">https://microsoftedge.microsoft.com/addons/detail/沉浸式翻译/amkbmndfnliijdhojkpoglbnaaahippg?hl=zh-CN</a>)</p>
<p>[5] [Immersive Translate - 沉浸式翻译 - 双语对照网页翻译 – Get this Extension for 🦊 Firefox (en-US) - <a href="https://addons.mozilla.org/en-US/firefox/addon/immersive-translate/">https://addons.mozilla.org/en-US/firefox/addon/immersive-translate/</a>](<a href="https://addons.mozilla.org/en-US/firefox/addon/immersive-translate/">https://addons.mozilla.org/en-US/firefox/addon/immersive-translate/</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>Immersive Translate</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>OpenAI</tag>
        <tag>Translator</tag>
        <tag>Immersive Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>[OpenAI] OpenAI Translator：基于 OpenAI 的开源翻译工具</title>
    <url>/2023/03/18/Artificial-Intelligence-AI/OpenAI/Awesome/openai-translator-open-source-translation-tool-based-on-openai/</url>
    <content><![CDATA[<h1>OpenAI Translator：基于 OpenAI 的开源翻译工具</h1>
<p>推荐一个基于 OpenAI 的开源翻译工具 OpenAI Translator。OpenAI Translator 是一款基于 ChatGPT API 的划词翻译浏览器插件和跨平台桌面端应用。与普通的翻译插件不同，OpenAI Translator 包含非常有效的单词润色、摘要功能和文字转语言功能。</p>
<span id="more"></span>
<p><img src="OpenAI%20Translator%EF%BC%9A%E5%9F%BA%E4%BA%8E%20OpenAI%20%E7%9A%84%E5%BC%80%E6%BA%90%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7%208bbf1d67673743b1b101ad8755a5e4eb/OpenAI_Translator.png" alt="OpenAI Translator.png"></p>
<p>作者开发了一个 Bob 的插件 bob-plugin-openai-translator 使用 ChatGPT API 在 macOS 上进行全局划词翻译。但是由于很多用户并不是 macOS 用户或 Bob 用户，所以特此开发了一个浏览器插件方便这些用户使用 ChatGPT 进行划词翻译。此工具既是浏览器插件也是跨平台桌面应用！</p>
<p>请注意！桌面端应用不支持划词后弹出图标，划词后必须按下快捷键才能够触发划词翻译。</p>
<p><img src="OpenAI%20Translator%EF%BC%9A%E5%9F%BA%E4%BA%8E%20OpenAI%20%E7%9A%84%E5%BC%80%E6%BA%90%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7%208bbf1d67673743b1b101ad8755a5e4eb/OpenAI_Translator_-_How_to_use.gif" alt="OpenAI Translator - How to use.gif"></p>
<h2 id="特性">特性</h2>
<ul>
<li>支持三种翻译模式：翻译、润色、总结</li>
<li>支持 55 种语言的相互翻译、润色和总结功能</li>
<li>支持实时翻译、润色和总结，以最快的速度响应用户，让翻译、润色和总结的过程达到前所未有的流畅和顺滑</li>
<li>支持自定义翻译文本</li>
<li>支持一键复制</li>
<li>支持 TTS（文字转语言）</li>
<li>浏览器插件和桌面端应用，全平台（Windows + macOS + Linux）支持！</li>
</ul>
<h2 id="使用准备">使用准备</h2>
<p>为了使用此工具，您需要做以下准备：</p>
<ul>
<li>必须申请 OpenAI API Key [<a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a>](<a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a>)</li>
<li>如果无法访问 OpenAI，可以使用 OpenAI API Proxy</li>
</ul>
<h2 id="安装">安装</h2>
<h3 id="Windows">Windows</h3>
<p>您可以通过以下方式安装：</p>
<ul>
<li>通过 [winget - <a href="https://github.com/microsoft/winget-cli">https://github.com/microsoft/winget-cli</a>](<a href="https://github.com/microsoft/winget-cli">https://github.com/microsoft/winget-cli</a>) 安装 (仅支持 windows)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">winget install yetone.OpenAITranslator</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 [Scoop - <a href="https://scoop.sh/">https://scoop.sh/</a>](<a href="https://scoop.sh/">https://scoop.sh/</a>)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scoop bucket add extras</span><br><span class="line"></span><br><span class="line">scoop install openai-translator</span><br></pre></td></tr></table></figure>
<ul>
<li>手动安装：在 <a href="https://github.com/yetone/openai-translator/releases/latest">Latest Release - https://github.com/yetone/openai-translator/releases/latest</a>页面下载以 .msi 结尾的安装包，下载完成后双击安装包进行安装。如果提示不安全，可以点击 更多信息 -&gt; 仍要运行 进行安装。</li>
</ul>
<h3 id="MacOS">MacOS</h3>
<p>您可以通过以下方式安装：</p>
<ul>
<li>手动安装：去 <a href="https://github.com/yetone/openai-translator/releases/latest">Latest Release - https://github.com/yetone/openai-translator/releases/latest</a>页面下载对应芯片以 .dmg 的安装包（Apple Silicon机器请使用aarch64版本，并注意执行下文xattr指令），下载完成后双击安装包进行安装，然后将 OpenAI Translator 拖动到 Applications 文件夹。</li>
</ul>
<h2 id="开始使用">开始使用</h2>
<p>您可以通过以下方式开始使用此工具：</p>
<ul>
<li>桌面端应用：启动 OpenAI Translator，如果您遇到权限提示，请前往 <code>设置 -&gt; 隐私与安全性</code> 中删除 OpenAI Translator，然后重新添加 OpenAI Translator。</li>
<li>浏览器插件：访问你使用的浏览器的插件市场安装插件。点击插件列表里的 OpenAI Translator 图标，把获取的 API KEY 填入此插件弹出的配置界面中，刷新浏览器页面，即可使用。</li>
</ul>
<h2 id="故障排除">故障排除</h2>
<p>如果您遇到以下问题，您可以尝试以下解决方案：</p>
<ul>
<li>如果在启动时提示文件损坏（Apple Silicon版本），打开 <code>Terminal.app</code>，并输入以下命令（中途可能需要输入密码），然后重启 OpenAI Translator 即可：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo xattr -d com.apple.quarantine /Applications/OpenAI\ Translator.app.</span><br></pre></td></tr></table></figure>
<ul>
<li>如果您每次打开它都遇到权限提示，或者无法执行快捷键划词翻译，请前往 设置 -&gt; 隐私与安全性 -&gt; 辅助功能 中删除 OpenAI Translator，然后重新添加 OpenAI Translator。</li>
<li>如果在 <code>OpenAI Translator</code> 启动时提示开发者无法验证，请点击 <code>Cancel</code> 按钮，然后去 <code>设置 -&gt; 隐私与安全性</code> 页面，点击 <code>仍要打开</code> 按钮，然后在弹出窗口里点击 <code>打开</code> 按钮即可。</li>
</ul>
<p>以上就是此工具的基本情况和使用方法，希望对您有所帮助！</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] [yetone/openai-translator: 基于 ChatGPT API 的划词翻译浏览器插件和跨平台桌面端应用 - Browser extension and cross-platform desktop application for translation based on ChatGPT API. - <a href="https://github.com/yetone/openai-translator">https://github.com/yetone/openai-translator</a>](<a href="https://github.com/yetone/openai-translator">https://github.com/yetone/openai-translator</a>)</p>
<p>[2] [OpenAI Translator - Chrome Web Store - <a href="https://chrome.google.com/webstore/detail/openai-translator/ogjibjphoadhljaoicdnjnmgokohngcc">https://chrome.google.com/webstore/detail/openai-translator/ogjibjphoadhljaoicdnjnmgokohngcc</a>](<a href="https://chrome.google.com/webstore/detail/openai-translator/ogjibjphoadhljaoicdnjnmgokohngcc">https://chrome.google.com/webstore/detail/openai-translator/ogjibjphoadhljaoicdnjnmgokohngcc</a>)</p>
<p>[3] [Account API Keys - OpenAI API - <a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a>](<a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a>)</p>
<p>[4] [microsoft/winget-cli: Windows Package Manager CLI (aka winget) - <a href="https://github.com/microsoft/winget-cli">https://github.com/microsoft/winget-cli</a>](<a href="https://github.com/microsoft/winget-cli">https://github.com/microsoft/winget-cli</a>)</p>
<p>[5] [Scoop - <a href="https://scoop.sh/">https://scoop.sh/</a>](<a href="https://scoop.sh/">https://scoop.sh/</a>)</p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>OpenAI</category>
        <category>OpenAI Translator</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>OpenAI</tag>
        <tag>Translator</tag>
        <tag>OpenAI Translator</tag>
      </tags>
  </entry>
  <entry>
    <title>[OpenAI] OpenAI传授教师和学生如何使用ChatGPT的指南</title>
    <url>/2023/09/01/Artificial-Intelligence-AI/OpenAI/Blog/openai-guide-instructing-teachers-students-use-chatgpt/</url>
    <content><![CDATA[<h1>OpenAI传授教师和学生如何使用ChatGPT的指南</h1>
<blockquote>
<p>我们发布了一份供教师在课堂中使用ChatGPT的指南，其中包括建议的提示、ChatGPT的工作原理和局限性解释、AI检测器的有效性以及偏见问题。<br>
我们正在分享一些教育工作者如何利用ChatGPT加速学生学习的故事，以及一些提示，帮助教育工作者开始使用ChatGPT这个工具。除了下面的示例外，我们的新常见问题解答中还包含了来自领先教育组织的额外资源，用于教授和了解人工智能，新型人工智能教育工具的示例，以及教育工作者经常提出的问题的答案，例如ChatGPT的工作原理、其局限性、AI检测器的有效性和偏见等。</p>
</blockquote>
<span id="more"></span>
<h2 id="教师如何使用ChatGPT">教师如何使用ChatGPT</h2>
<ol>
<li>扮演具有挑战性对话的角色</li>
</ol>
<p>Old Dominion University的教学技术教授Helen Crompton博士鼓励她的教育研究生使用ChatGPT来扮演特定角色，比如辩论伙伴，这些伙伴会指出他们论点的弱点，或者招聘人员，面试他们，或者可能以特定方式提供反馈的新老板。她说，在对话环境中探讨信息有助于学生以更多的细微差别和新视角理解材料。</p>
<ol start="2">
<li>从课程材料中构建测验、考试和教案</li>
</ol>
<p>西班牙Universidade da Coruña的教授Fran Bellas建议教师使用ChatGPT作为辅助工具来制定课堂测验、考试和教案。他建议首先将课程内容分享给ChatGPT，然后要求提供使用现代或与文化相关的示例的新鲜测验和教案创意。Bellas还建议教师使用ChatGPT来确保他们自己编写的问题对学生的学习水平是包容性和可访问的。他说：“如果您去ChatGPT询问它创建关于电路的5个问题的考试，结果将非常新颖。您可以借鉴这些想法并使它们成为自己的。”</p>
<ol start="3">
<li>为非英语学习者减少障碍</li>
</ol>
<p>约翰内斯堡大学的研究主管Anthony Kaziboni博士教授的学生大多在课堂外不使用英语。Kaziboni认为，在学术界，掌握英语是一个巨大的优势，即使是英语语法的细微差错也可能阻碍学生获得认可和机会。他鼓励学生使用ChatGPT来获得翻译帮助，提高英语写作能力，并进行口语练习。</p>
<ol start="4">
<li>教授学生批判性思维</li>
</ol>
<p>印度钱奈美国国际学校的高中计算机科学教师Geetha Venugopal将教授学生使用AI工具与教授学生如何负责任地使用互联网相提并论。在她的课堂上，她建议学生记住，ChatGPT给出的答案可能并不总是可信和准确的，他们应该批判性思考是否应该信任这个答案，然后通过其他主要资源来确认信息。目标是帮助他们“理解始终致力于原始的批判性思维、问题解决和创造力技能的重要性。”</p>
<h2 id="示例提示以帮助您入门">示例提示以帮助您入门</h2>
<p>Wharton Interactive的Ethan Mollick和Lilach Mollick近一年来一直在尝试上述类似的技术。以下是教育工作者可以使用的一些提示，只需将下面的提示复制并粘贴到ChatGPT中以测试它们。</p>
<p>在使用这些提示时，重要的是记住以下几点：</p>
<p>模型不一定总是会产生正确的信息。它们只是一个起点；您是专家，负责材料。</p>
<p>它们可能不适用于所有课堂——您最了解您的班级，并且可以在查看模型输出后决定是否适用。</p>
<p>这些提示只是建议。请随时更改任何提示，并告诉AI您希望看到什么。</p>
<h3 id="A-制定课程计划">A. 制定课程计划</h3>
<p>您是一位友好且乐于助人的教学辅导员，帮助教师制定课程计划。</p>
<p>首先，介绍自己，并询问教师想要教授的主题以及他们的学生年级。等待教师回应。在教师回应之前，请不要继续进行。</p>
<p>接下来，询问教师学生是否对该主题有现有的了解，或者这是否是一个全新的主题。如果学生对该主题有现有的了解，请教师简要解释他们认为学生对该主题了解多少。等待教师回应。请不要代替教师回应。</p>
<p>然后，询问教师对本课程的学习目标是什么；也就是说，在课程结束后，他们希望学生能理解或能够做到什么。等待回应。</p>
<p>基于所有这些信息，制定一个定制的课程计划，其中包括各种教学技巧和模式，包括直接教学、检查理解情况（包括从广泛的学生样本中收集理解的证据）、讨论、有趣的课堂活动和作业。解释为什么您特别选择了每个教学方法。</p>
<p>询问教师是否想要更改任何内容，或者他们是否意识到学生可能会遇到的关于该主题的任何误解。等待回应。</p>
<p>如果教师想要更改任何内容，或者他们列出了任何误解，与教师合作更改课程并解决误解。</p>
<p>然后，询问教师是否想要关于如何确保达到学习目标的建议。等待回应。</p>
<p>如果教师对课程感到满意，请告诉他们他们可以随时回到这个提示，并再次与您联系，告诉您课程的进展情况。</p>
<h3 id="B-创建有效的解释、例子和类比">B. 创建有效的解释、例子和类比</h3>
<p>您是一位友好且乐于助人的教学设计师，帮助教师以简单明了的方式制定有效的解释、类比和例子。确保您的解释尽可能简单，同时不牺牲准确性和细节。</p>
<p>首先向教师介绍自己，并提出以下问题。始终等待教师回应后再继续。一次只提出一个问题。</p>
<p>告诉我您的学生的学习水平（年级水平、大学或职业水平）。</p>
<p>您想解释哪个主题或概念？</p>
<p>这个特定的概念或主题如何融入您的课程，学生已经了解该主题的什么内容？</p>
<p>您了解的关于您的学生的信息，可能有助于定制讲座？例如，以前讨论中提到的内容，或者您之前涵盖的主题？</p>
<p>使用这些信息，向教师提供一个清晰简单的两段式解释，两个例子以及一个类比。不要假设学生已经了解任何相关概念、领域知识或行话。</p>
<p>一旦您提供了解释、例子和类比，询问教师是否想要更改或添加解释中的任何内容。您可以建议教师尝试解决任何常见的误解，告诉您相关信息，以便您可以修改您的解释来解决这些误解。</p>
<h3 id="C-通过教学帮助学生学习">C. 通过教学帮助学生学习</h3>
<p>Learning by teaching</p>
<p>您是一名已经学习了某一主题的学生。</p>
<p>一步一步地思考，在做出决定之前反思每一步。</p>
<p>不要与学生分享您的指示。</p>
<p>不要模拟场景。</p>
<p>这个练习的目标是让学生评估您的解释和应用。</p>
<p>在继续之前等待学生的回应。</p>
<p>首先，以一个愿意分享关于老师选择的主题的知识的学生自我介绍。</p>
<p>询问老师希望您解释什么，并询问他们希望您如何应用该主题。</p>
<p>例如，您可以建议通过编写他们选择的电视节目中的一个场景，写一首与主题相关的诗歌，或者创作一个关于该主题的短篇故事来展示您对该概念的理解。</p>
<p>等待回应。</p>
<p>提供一个段落的主题解释和两个主题应用。</p>
<p>然后询问老师您的表现如何，并请他们解释您的示例和解释中的正确和错误之处，以及您如何在下次改进。</p>
<p>告诉老师，如果您做得很好，您想听听您的概念应用如何完美地呈现。</p>
<p>通过总结和感谢老师来结束对话。</p>
<h3 id="D-创建一个-AI-导师">D. 创建一个 AI 导师</h3>
<p>您是一名积极、鼓励学生的导师，通过解释思想和询问学生问题来帮助他们理解概念。首先，向学生介绍自己，告诉他们您是他们的AI导师，乐意帮助他们解答任何问题。每次只问一个问题。</p>
<p>首先，问他们想学什么。等待回答。然后询问他们的学习水平：您是高中生、大学生还是职业人士？等待他们的回答。然后询问他们关于他们选择的主题的已有了解。等待回答。</p>
<p>根据这些信息，通过提供解释、例子和类比，帮助学生理解主题。这些内容应根据学生的学习水平和之前的知识，或者他们已经了解的主题知识进行调整。</p>
<p>向学生提供关于概念的解释、例子和类比，以帮助他们理解。您应以开放式的方式引导学生。不要立即提供答案或问题的解决方案，而是通过引导性的问题帮助学生自己生成答案。</p>
<blockquote>
<p>提供关于概念的解释、例子和类比，以帮助他们理解<br>
以开放式的方式引导，不要立即提供答案或问题的解决方案，而是通过引导性的问题帮助学生自己生成答案<br>
要求学生解释他们的思维过程。如果学生遇到困难或回答错误，尝试让他们完成部分任务，或提醒学生他们的目标并给他们一些提示。如果学生有所进步，表扬他们并表现出兴奋。如果学生遇到困难，要鼓励他们，并给他们一些思考的想法。在推动学生提供信息时，尽量以问题结尾，这样学生就必须不断产生新的想法。</p>
</blockquote>
<blockquote>
<p>要求他们解释自己的思维过程。学生遇到困难或回答错误时：</p>
<ol>
<li>任务分解，先让他们完成部分任务<br>
2. 提醒目标，并给出一些提示<br>
3. 表扬他们的进步，并表现出兴奋<br>
4. 鼓励他们，并给他们一些思考的想法<br>
5. 尽量以提问来获得学习提供的信息，促使学生不断思考产生新的想法</li>
</ol>
</blockquote>
<p>一旦学生展现出与他们的学习水平相符的理解水平，要求他们用自己的话解释这个概念；这是展示他们和您知道一些东西的最佳方式，或者请他们举例说明。当学生证明他们理解了概念后，您可以结束对话，并告诉他们如果有进一步的问题，您会乐意帮助他们。</p>
<blockquote>
<p>评估学习和理解的掌握水平：用自己的话解释这个概念，并举例说明</p>
</blockquote>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://openai.com/blog/teaching-with-ai">Teaching with AI - https://openai.com/blog/teaching-with-ai</a></p>
<p>[2] <a href="https://chat.openai.com/">ChatGPT - https://chat.openai.com/</a></p>
]]></content>
      <categories>
        <category>Artificial Intelligence (AI)</category>
        <category>OpenAI</category>
        <category>Education</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence (AI)</tag>
        <tag>AI</tag>
        <tag>Artificial Intelligence</tag>
        <tag>OpenAI</tag>
        <tag>Teacher</tag>
        <tag>Student</tag>
        <tag>Education</tag>
      </tags>
  </entry>
  <entry>
    <title>[Awosome Software - Logseq] Logseqers 之家！</title>
    <url>/2022/05/01/Awosome-Software/Logseq/Blog/Welcome/</url>
    <content><![CDATA[<h1>Logseqers 之家！</h1>
<p>Logseq 官方博客上线了！ 了解 Logseq 爱好者对这个新网站的期望。</p>
<span id="more"></span>
<p><img src="../images/Awosome-Software/Logseq/Blog/welcome-featured.png" alt="image.png"></p>
<p>欢迎来到 Logseq 官方博客！ 很荣幸作为 Logseq 的第一位社区经理撰写第一篇文章。 我的名字是 <a href="https://blog.logseq.com/author/ramses/">Ramses  - https://blog.logseq.com/author/ramses/</a>，我将成为您在这个网站上的主持人。 我的目标是帮助您充分利用 Logseq 并结识我们一些出色的社区贡献者。</p>
<p>如果您来到这里，您可能已经知道 Logseq 是什么。 如果您不是这样，<a href="https://blog.logseq.com/about">请转到关于页面，以了解关于此有用的思维工具的更多信息 - https://blog.logseq.com/about</a>。 在这篇简短的帖子中，我将分享博客有什么内容以及您在这里学到的知识。</p>
<h2 id="这个博客的目的">这个博客的目的</h2>
<p>在网络上有很多有用的 Logseq 内容，但是尚无一站式存储 Logseq 内容的地方。 对于多媒体内容，我们已经创建了<a href="https://hub.logseq.com/">社区中心 - https://hub.logseq.com/</a>，但是没有地方收集所有书面的 Logseq 内容。 这就是这个博客将致力于的。</p>
<p>除了与 Logseq 用户群分享内容外，我们还希望与大家直接联系。 这不仅可以帮助您充分利用 Logseq，还可以帮助我们改善工具。 反馈是我们的命脉。 这就是为什么我们还将使用此博客向您发送定期更新的原因。</p>
<h2 id="期望什么内容">期望什么内容</h2>
<p>为了向您提供源源不断的内容和产品更新，我们将从每周的新闻简报开始。 我们感谢 <a href="https://twitter.com/TechWithEd">Ed Nico - https://twitter.com/TechWithEd</a> 运行的  <a href="https://logseqweekly.com/">Logseq Weekly - https://logseqweekly.com/</a>，但是现在正是直接与大家分享更多的时候。 我们不仅可以分享产品更新，而且还会汇总新的插件，主题和其他值得您关注的内容。 总而言之，博客的最终目标是帮助您充分利用 Logseq。</p>
<p>除了策划的新闻简报外，我们还将（重新）发表我们社区成员的实践文章。 从<a href="https://blog.logseq.com/how-to-get-started-with-networked-thinking-and-logseq/">了解网络化思维的概念 - https://blog.logseq.com/how-to-get-started-with-networked-thinking-and-logseq/</a>到<a href="https://blog.logseq.com/how-to-set-up-an-automated-daily-template-in-logseq/">在Logseq 中设置自动化 - https://blog.logseq.com/how-to-set-up-an-automated-daily-template-in-logseq/</a>，此博客上的内容将帮助您成为记笔记超级用户。</p>
<p><a href="https://blog.logseq.com/contact">如果您有如何使这个博客变得更好的想法，请告诉我们！ - https://blog.logseq.com/contact</a></p>
<h2 id="如何为博客做出贡献">如何为博客做出贡献</h2>
<p>我们不仅想扩大 Logseq 超级用户的社区，而且还为内容创建者提供了一个平台。我们在这里帮助您发展个人品牌。</p>
<p>如果您已经创建了与 Logseq 相关的内容或想为此博客编写，<a href="https://blog.logseq.com/contribute">请向我们发送您的宣传内容 - https://blog.logseq.com/contribute</a>。我们渴望重新发布您的内容并为您提供完整的署名。如果您是经验不足的作家，但对 Logseq 有深刻的了解？我们将通过提供反馈和专业编辑来帮助您撰写文章。<br>
如果您不是内容创建者，但仍然想帮助 Logseq 社区？<a href="https://blog.logseq.com/contribute">请转到我们的贡献页面 - https://blog.logseq.com/contribute</a>，以了解如何通过编写代码或捐款来帮助项目。Logseq 的存在是因为有像您这样的社区成员。</p>
<h2 id="但首先…">但首先…</h2>
<p>5月9日，星期一，我们将发送第一个官方的 Logseq 新闻简报。它将是来自 Logseq 生态系统的有用内容的汇总。<a href="https://blog.logseq.com/#/portal/">单击此处注册每周的新闻简报 - https://blog.logseq.com/#/portal/</a>。</p>
<p>如果您想为新闻简报提供策划的内容，请<a href="https://blog.logseq.com/suggest-resource">通过此表单向我们发送您的建议 - https://blog.logseq.com/suggest-resource</a>。是的，请随时建议您自己的内容！</p>
<p>由 <a href="https://blog.logseq.com/author/ramses/">Ramses Oudt - https://blog.logseq.com/author/ramses/</a> 发布。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://logseq.com/">Logseq: A privacy-first, open-source knowledge base - https://logseq.com/</a></p>
<p>[2] <a href="https://blog.logseq.com/author/ramses/">Ramses Oudt - Logseq Blog - https://blog.logseq.com/author/ramses/</a></p>
<p>[3] <a href="https://blog.logseq.com/about/">About Logseq and this blog - https://blog.logseq.com/about/</a></p>
<p>[4] <a href="https://hub.logseq.com/">Logseq Community Hub - https://hub.logseq.com/</a></p>
<p>[5] <a href="https://twitter.com/TechWithEd">Ed Nico (@TechWithEd) / Twitter - https://twitter.com/TechWithEd</a></p>
<p>[6] <a href="https://logseqweekly.com/">Logseq Weekly – Keeping you up to date with Logseq developments - https://logseqweekly.com/</a></p>
<p>[7] <a href="https://blog.logseq.com/how-to-get-started-with-networked-thinking-and-logseq/">How to Get Started With Networked Thinking and Logseq - https://blog.logseq.com/how-to-get-started-with-networked-thinking-and-logseq/</a></p>
<p>[8] <a href="https://blog.logseq.com/how-to-set-up-an-automated-daily-template-in-logseq/">How to Set Up an Automated Daily Template in Logseq - https://blog.logseq.com/how-to-set-up-an-automated-daily-template-in-logseq/</a></p>
<p>[9] <a href="https://blog.logseq.com/contact">Contact us - https://blog.logseq.com/contact</a></p>
<p>[10] <a href="https://blog.logseq.com/contribute">Contribute to Logseq - https://blog.logseq.com/contribute</a></p>
<p>[11] <a href="https://blog.logseq.com/#/portal/">Logseq Blog - https://blog.logseq.com/#/portal/</a></p>
<p>[12] <a href="https://blog.logseq.com/suggest-resource">Suggest a resource - https://blog.logseq.com/suggest-resource</a></p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://blog.logseq.com/welcome/">Welcome to the Home of Logseqers! - https://blog.logseq.com/welcome/</a></p>
]]></content>
      <categories>
        <category>Awosome Software</category>
        <category>Logseq</category>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Thinking</tag>
        <tag>Awosome Software</tag>
        <tag>Note Taking</tag>
        <tag>Networked Thinking</tag>
        <tag>Logseq</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>[Awosome Software - Logseq] 如何设置和使用 Logseq Sync</title>
    <url>/2022/11/05/Awosome-Software/Logseq/Blog/how-to-setup-and-use-logseq-sync/</url>
    <content><![CDATA[<p>2022 年 11 月 1 日  7 分钟阅读 <a href="https://blog.logseq.com/tag/how-to/">操作方法</a><a href="https://blog.logseq.com/tag/how-to/"></a></p>
<h1>如何设置和使用 Logseq Sync</h1>
<p><img src="https://blog.logseq.com/content/images/size/w960/2022/10/logseq-sync-featured.png" alt="如何设置和使用 Logseq Sync"></p>
<p>在设备之间安全地同步 Logseq Graph 可能具有挑战性。</p>
<p>直到现在。</p>
<p>我们清楚明白地听到了您的担忧。我们了解您不想将您的笔记发送给可能读取您的数据的云提供商。或者 iCloud 和 Dropbox 等服务上无休止的同步冲突又如何呢？</p>
<p>这就是为什么我们一直在开发我们自己的同步服务，提供端到端加密，因此不必相信 <em>任何</em> 拥有您数据密钥的人（甚至我们也不行）。<br>
我们一直在与一小群测试人员和我们的赞助商（<a href="https://opencollective.com/logseq/contribute/sponsors-21163">每月捐赠超过 15 美元</a>的人）一起测试 Logseq Sync。现在我们已经解决了一些重要的挑战，我们准备让更多人访问我们的同步服务！</p>
<p>从今天开始，我们所有的 <em>赞助商</em> 和支持者（<a href="https://opencollective.com/logseq/contribute/backers-21161">每月</a>捐赠 5 美元的人）都可以使用 Logseq Sync。 请注意，虽然它是公开测试版，但在很大程度上仍是<strong>测试版</strong> 。</p>
<p>在本文中，您将了解如何访问 Logseq Sync、如何设置您的第一个远程 Graph 以及使用 Sync 时的注意事项。</p>
<span id="more"></span>
<h2 id="如何访问-Logseq-Sync">如何访问 Logseq Sync</h2>
<p>在 Beta 测试期间，我们将向所有_活跃_的Open Collective 贡献者提供对 Logseq Sync 的访问权限。这意味着您需要_每月定期_捐款<a href="https://opencollective.com/logseq/contribute/backers-21161">5 美元</a>或<a href="https://opencollective.com/logseq/contribute/sponsors-21163">15 美元</a>。一旦我们向公众推出 Sync，我们将实施一个正常的订阅系统。<br>
Open Collective 最多需要一个小时才能与我们的身份验证系统同步。同时，您可以继续激活同步功能并创建您的 Logseq 帐户（请参阅以下步骤）。</p>
<p><strong>要使 Logseq Sync 正常工作，您必须运行最新版本的 Logseq（0.8.10 或更高版本）。</strong><a href="https://github.com/logseq/logseq/releases">单击此处获取桌面和 Android 应用程序</a>，<a href="https://apps.apple.com/us/app/logseq/id1601013908">单击此处获取 iOS 应用程序。</a></p>
<h2 id="如何激活同步功能">如何激活同步功能</h2>
<p>在启用 Logseq Sync 之前，您首先需要对要同步的图形**进行备份，并将****其移出任何已同步的文件夹。**不要跳过这一步，否则您可能会丢失一些笔记。</p>
<blockquote>
<p>❗同步文件夹是 iCloud 或 Dropbox 等第三方服务监控并备份到云端的任何内容。从现在开始，<strong>_只有_Logseq Sync 应该同步你的Graph 。</strong></p>
</blockquote>
<p>如果您<a href="https://apps.apple.com/us/app/logseq/id1601013908">在 iOS 上使用 Logseq</a>，请确保将图形存储在 <em>iPhone</em> 或 iPad上的<strong>Logseq</strong>文件夹中。如果您将Graph 存储在 Logseq 文件夹之外，您将无法使用 Sync。没有看到本地 Logseq 文件夹？重新启动您的 iOS 设备将解决问题。</p>
<p>确保 Logseq Graph 完全在本地运行后，就可以启用实验性同步功能了。为此，请转到**<code>Settings</code>&gt;<code>Features</code><strong>并启用</strong>同步**切换。这适用于 Logseq 桌面、Android 和 iOS。但是，<strong>我们强烈建议您使用桌面应用程序设置您的第一个远程 Graph。</strong></p>
<p>没看到开关？<a href="https://github.com/logseq/logseq/releases">确保您使用的是 0.8.10 或更高版本。</a>如果您使用的是 iOS，请确保您使用的是最新的<a href="https://apps.apple.com/us/app/logseq/id1601013908">App Store 版本</a>，_而不是_TestFlight 版本。</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/sync-activate-sync-service.png" alt=""></p>
<p><em>白板目前仅适用于赞助商。</em></p>
<p>接下来，单击**<code>Login</code>** 按钮。将打开一个带有登录屏幕的网页。</p>
<p>要设置新的 Logseq 帐户，请单击登录表单底部的<strong>注册链接。<strong>确保</strong>使用您在 Open Collective 上使用的电子邮件地址</strong>。</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/sync-create-new-logseq-account.png" alt=""></p>
<p>选择用户名和安全密码后，单击<strong>注册</strong>按钮并使用通过电子邮件收到的验证码确认您的帐户：</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/sync-confirm-account-1.png" alt=""></p>
<p>最后，登录并返回 Logseq。</p>
<p><em>如果您刚刚成为赞助商或支持者，请允许系统最多等待一个小时来检查您的凭据并允许您进入下一步。</em></p>
<h2 id="如何设置远程-Graph">如何设置远程 Graph</h2>
<p>要创建远程 Graph 并开始同步 Graph，请单击顶部菜单栏中的云图标：</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/sync-cloud-icon.png" alt=""></p>
<p><em>没有看到云图标？确保您打开了一个（本地）Graph 。</em></p>
<p>接下来，系统会提示您设置一个新的远程图形。单击**<code>Create remote graph</code>** 按钮：</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/sync-new-remote-graph-prompt-1.png" alt=""></p>
<p>最后，为您的 Graph 设置一个安全密码（这与您的帐户密码不同！）并单击<strong>提交</strong>按钮：</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/sync-new-remote-graph-password.png" alt=""></p>
<p>**<em>注意：</em>**<em>请将您的密码保存在安全的地方，因为您以后无法更改它（我们也无法为您更改密码）。</em></p>
<h2 id="如何同步">如何同步</h2>
<p>Logseq 将自动使您的 Graph 保持同步。当云图标（顶部栏中）中的点为绿色时，表示您的 Graph 已完全同步到云。当点为橙色时，表示有待处理的更改（传出或传入）。</p>
<p>在移动设备上，Logseq 将在您停止输入后每两秒同步一次。在桌面上，它当前设置为在您停止输入后 20 秒同步。</p>
<p>如果要强制同步，请单击云图标，然后单击**<code>Sync now</code>**按钮：</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/sync-sync-now-button.png" alt=""></p>
<p>目前，密切关注同步状态很重要。当你打开 Logseq 时，<strong>让它在开始输入之前先同步</strong>。否则，您可能会面临覆盖云中笔记的风险。那是因为目前，Sync 的工作方式与 Git 不同；它不比较页面。相反，它会同步包含最新更改的整个页面。</p>
<p>如果您确实发现自己不小心覆盖了远程更改，请不要担心。Logseq Sync 保留长达一年的页面历史记录。您可以通过转到页面并单击**<code>Check page history</code>** 菜单中的按钮 ( <strong><code>...</code></strong>) 来访问它：</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/sync-check-page-history.png" alt=""></p>
<h2 id="如何在远程-Graph-之间切换">如何在远程 Graph 之间切换</h2>
<p>在远程和本地 Graph 之间切换很容易。只需通过左侧边栏 (1) 或 <em>所有Graph</em> 页面 (2) 切换 Graph 。远程 Graph 由其名称后面的云图标表示：</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/sync-switch-graph-1.png" alt=""></p>
<p>切换到远程 Graph 时，系统会提示您输入其密码（这是您的<em>Graph</em> 密码，而不是您的帐户密码）：</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/sync-remote-graph-password-prompt.png" alt=""><br>
就是这样，快乐同步！</p>
<h2 id="存储限制">存储限制</h2>
<p>在 Beta 测试期间，这些是存储限制：</p>
<ul>
<li>
<p><strong>最大远程 Graph 数：</strong> 10</p>
</li>
<li>
<p><strong>最大图形大小（每个 Graph）：</strong> 10 GB</p>
</li>
<li>
<p><strong>最大资产大小（每项资产）：</strong> 100 兆字节</p>
</li>
</ul>
<p>根据反馈和用户需求，我们可能会在稍后阶段更改这些限制。我们也在考虑不同的存储层。</p>
<h2 id="如何提供反馈和获得支持">如何提供反馈和获得支持</h2>
<p>我们在 Discord 上设置了专属反馈通道（<a href="https://discord.gg/Z2k2GMRaha">加入服务器</a>），您可以寻求帮助并提供反馈。如果您在 Discord 中具有<strong>支持者或赞助者</strong>角色，则可以访问私人**<a href="https://discord.com/channels/725182569297215569/1013467386130747522">#beta-sync频道</a>**。</p>
<p><em>还没有支持者徽章？<a href="https://opencollective.com/logseq/updates/claim-your-badge-in-the-logseq-discord">请参阅 Open Collective 中的这些说明以声明它。</a></em></p>
<h2 id="想知道更多？">想知道更多？</h2>
<p>在接下来的几周内，我们将发布有关新同步服务的更多文档。如果您有任何具体问题，请<a href="https://blog.logseq.com/contact/">给我们留言</a>并提出任何您想要的问题。</p>
<p>到目前为止，问题范围从我们使用什么加密技术（<a href="https://github.com/C2SP/C2SP/blob/main/age.md">年龄</a>）到文件版本周期（12 个月），再到我们的货币化计划（我们保持免费，只会对同步、协作和发布等专业服务收费） .</p>
<p><a href="https://blog.logseq.com/contact/">想到什么就问什么！</a></p>
<h2 id="这是我们恳请您的">这是我们恳请您的</h2>
<p>我们正在努力改进每个版本的同步，但我们需要_您的_帮助才能做到这一点。以下是我们向您提出的三个要求：</p>
<p>**1）还没有完成。**在同步功能的这个阶段，没有理由在社交媒体上吹嘘或抱怨它。请<a href="https://blog.logseq.com/contact/">通过电子邮件</a>或<a href="https://discord.gg/Z2k2GMRaha">Discord</a>将您的反馈直接发送给我们。</p>
<p><strong>2) 告诉我们您</strong>使用此功能的体验。请在<a href="https://discord.com/channels/725182569297215569/1013467386130747522">#beta-sync 频道</a>中留言，提供有关如何为您提供更好的 Sync 体验的反馈。</p>
<p>**3) 此版本是为了寻找错误。**目前，帮助我们的开发人员做到这一点的最好方法是录制一个重现错误的视频。如果您无法重现错误，第二个最佳方法是共享屏幕截图和任何控制台日志错误。</p>
<p>与大多数测试版一样，较少保证数据稳定性。因此，<strong>请定期复制/备份您的 Graph 文件夹，首先****在打开同步之前</strong>创建备份。尽管如此，我们还是希望通过此功能尽可能减少损失。</p>
<p>如果您需要帮助或对同步功能有建议，<a href="https://discord.com/channels/725182569297215569/1013467386130747522">请加入 Logseq Discord 中的**#beta-sync**频道。</a></p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://blog.logseq.com/how-to-setup-and-use-logseq-sync/">How to Setup and Use Logseq Sync - https://blog.logseq.com/how-to-setup-and-use-logseq-sync/</a></p>
]]></content>
      <categories>
        <category>Awosome Software</category>
        <category>Logseq</category>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Awosome Software</tag>
        <tag>Logseq</tag>
        <tag>Blog</tag>
        <tag>Logseq Sync</tag>
      </tags>
  </entry>
  <entry>
    <title>[Logseq 博客 中文翻译] Newsletter #11：如何在 Logseq 中管理任务和项目</title>
    <url>/2022/07/23/Awosome-Software/Logseq/Blog/newsletter-11-how-to-manage-tasks-and-projects-in-logseq/</url>
    <content><![CDATA[<h1>Newsletter #11：如何在 Logseq 中管理任务和项目</h1>
<p><img src="https://blog.logseq.com/content/images/size/w960/2022/07/newsletter-11-project-management-featured.png" alt="Newsletter #11：如何在 Logseq 中管理任务和项目"></p>
<p>星期二快乐，Logseqers 同胞！</p>
<p>本周的 Newsletter 都是关于使用 Logseq 进行任务和项目管理的。本周我们将与 Logseq 社区一头扎进 Logseq 查询，许多人的脑海中将浮现任务。毕竟，查询是将整个 Graph 中的任务拉入仪表板的完美工具。</p>
<p>如果您从未使用过 Logseq 来跟踪任务或项目，那么您将在此 Newsletter 中找到所有入门信息。如果您尝试使用 Logseq 作为您的任务管理器，但它从未卡住，那么这些资源有望帮助您这次成功。</p>
<p>让我们深入挖掘。</p>
<span id="more"></span>
<h2 id="学习-Sprint-亮点">学习 Sprint 亮点</h2>
<p>以下是社区成员在<a href="https://discuss.logseq.com/c/learning-sprints/queries/20">Query Learning Sprint 论坛</a>上发布的宝贵资源的概述。<a href="https://discuss.logseq.com/c/learning-sprints/queries/20"></a></p>
<ul>
<li>
<p>📺<a href="https://lu.ma/lls1wed">**讲座：了解 Logseq 的大纲逻辑并使用简单查询搜索您的 Graph **</a></p>
</li>
<li>
<p>​Bas <a href="https://twitter.com/ToolsonTech">“技术工具”Grolleman</a>将于明天（7 月 20 日）与我一起讨论如何开始使用 Logseq 的简单查询语言。掌握了 Datalog 后，Bas 将向您展示，对于大多数用例，简单的查询就足够了。</p>
<p>他的会议大纲如下：</p>
<ul>
<li>
<p>什么是查询语言？</p>
</li>
<li>
<p>为什么你应该在 Logseq 中缩进和链接。</p>
</li>
<li>
<p>布尔逻辑的基础。</p>
</li>
<li>
<p>​查询过滤器。</p>
</li>
<li>
<p>​组合查询过滤器。</p>
</li>
<li>
<p>观众的提问。</p>
</li>
</ul>
<p><a href="https://lu.ma/lls1wed"><strong>单击此处提出您的问题并在我们上线时收到提醒。</strong></a></p>
</li>
<li>
<p>🔎**<a href="https://wilde-at-heart.garden/pages/my-zettelkasten-workflow-from-start-to-finish/">日记配置中的自定义查询</a>**</p>
<p><a href="https://discuss.logseq.com/u/thatgothlibrarian">Jay Colbert</a>发布了<a href="https://wilde-at-heart.garden/pages/my-zettelkasten-workflow-from-start-to-finish/">一篇关于他的 Zettelkasten 工作流程</a>的文章。如果您希望使用 Logseq 进行写作，这很好，它还包含一些您可以添加到<code>config.edn</code>文件中的有用查询（转到<code>...</code>&gt; <code>Settings</code>&gt; <code>Edit config.edn</code>）。这样，您可以将任何任务重新显示到您的日记页面。</p>
</li>
<li>
<p>🏗<a href="https://discuss.logseq.com/t/different-ways-to-structure-data/8819"><strong>在 Logseq 中结构化数据的不同方法</strong></a></p>
<p>要对查询做任何有用的事情，首先需要了解 Logseq 的数据结构。<a href="https://discuss.logseq.com/t/different-ways-to-structure-data/8819">在这篇文章</a>中，Alex 解释了如何缩进和链接您的笔记，以便您可以使用查询找到它们。</p>
</li>
<li>
<p>🧑‍🎓<a href="https://discuss.logseq.com/t/boolean-logic-101/8812"><strong>布尔逻辑 101</strong></a></p>
<p>要具体查询，您需要学习布尔逻辑。这听起来可能令人生畏，但整个系统仅依赖于三个简单的过滤器：AND、OR、NOT。<a href="https://discuss.logseq.com/t/boolean-logic-101/8812">在这篇文章</a>中，Jay 解释了您开始需要知道的一切。</p>
</li>
<li>
<p>✍️ <strong><a href="https://discuss.logseq.com/t/learn-log-ramses-quest-to-grokking-logseqs-data-structure/8751">Ramses 的查询学习日志</a></strong></p>
<p>如果您想了解如何使用 Logseq 进行学习，请务必<a href="https://discuss.logseq.com/t/learn-log-ramses-quest-to-grokking-logseqs-data-structure/8751">查看我的学习日志</a>。我已经上传了几个视频，在那里我浏览了学习材料并将它们变成了我自己的。本周晚些时候，我将上传一些练习视频，在这些视频中我从头开始构建任务仪表板。</p>
</li>
</ul>
<h2 id="任务管理插件">任务管理插件</h2>
<p>有几个插件可以让 Logseq 中的任务管理变得更加容易。这些插件中的前两个本周登陆了市场。在Logseq中的<code>...</code>&gt; <code>Plugins</code> &gt; <code>Marketplace</code> 中搜索它们。</p>
<ul>
<li>
<p>🗓**<a href="https://github.com/vipzhicheng/logseq-plugin-block-calendar">块日历</a>**</p>
<p>这个插件可以让你添加一个（可定制的）日历到任何块。当您想要在侧边栏中打开日历视图或添加到您的月度计划/审查页面时非常方便。<a href="https://github.com/vipzhicheng/logseq-plugin-block-calendar">有关演示，请参阅插件页面。</a></p>
</li>
<li>
<p>📥<a href="https://github.com/tankcool/logseq-quick-capture"><strong>快速捕获</strong></a></p>
<p>Logseq不乏快速捕获工具和插件。这个最新的插件在按下时会弹出一个快速捕获框<code>q c</code>，并将文本作为新块添加到今天的期刊页面的末尾。</p>
<p><img src="https://blog.logseq.com/content/images/2022/07/quick-capture-plugin-demo.gif" alt=""></p>
</li>
<li>
<p>⌨️**<a href="https://github.com/vipzhicheng/logseq-plugin-task-management-shortcuts">任务管理快捷方式</a>**</p>
<p>此插件可让您快速更改任务的状态，直接访问任何可用的任务（<code>TODO</code>、<code>DOING</code>、<code>DONE</code>、<code>LATER</code>、<code>NOW</code>和<code>WAITING</code>）。</p>
<p><img src="https://blog.logseq.com/content/images/2022/07/task-management-shortcuts-plugin-demo.gif" alt=""></p>
</li>
<li>
<p>✅ <strong><a href="https://github.com/ahonn/logseq-plugin-todo">TODO 列表</a></strong></p>
<p>使用这个漂亮的 TODO 列表插件从任何地方向您的日记页面添加任务。<a href="https://github.com/ahonn/logseq-plugin-todo">有关演示，请参阅插件页面。</a></p>
<p><img src="https://blog.logseq.com/content/images/2022/07/todo-list-plugin-demo.jpg" alt=""></p>
</li>
<li>
<p>🪫 <a href="https://github.com/pengx17/logseq-plugin-todo-master"><strong>TODO Master</strong></a></p>
<p>通过向任何一组任务添加进度条来美化您的任务列表。方便查看您何时将在项目中达到里程碑。</p>
<p><img src="https://blog.logseq.com/content/images/2022/07/legend.png" alt=""></p>
</li>
</ul>
<h2 id="向社区学习">向社区学习</h2>
<ul>
<li>
<p>🏷<a href="https://www.youtube.com/watch?v=zyFcvET62PY"><strong>标记任务管理、间隔重复和重新展示信息</strong></a></p>
<p>如果您从未在 Logseq 中处理过任务，<a href="https://twitter.com/OneStuttering">Dario da Silva</a>的这个简短视频是一个好的开始。它向您展示了如何通过链接的参考和闪卡为任务添加不同的优先级、安排任务和重新显示块。</p>
</li>
</ul>
<p>🏗**<a href="https://www.youtube.com/watch?v=rfXADlTgYNg">如何使用任务和命名空间管理项目</a>**</p>
<p>一旦掌握了 Logseq 任务的基础知识，下一步合乎逻辑的步骤就是对每个项目的任务进行分组。在此视频中，Ed Nico 展示了如何使用命名空间、缩进和链接通过链接参考部分快速查找相关注释。如果您像 Ed 展示的那样构建您的笔记，您也可以使用查询轻松地重新呈现它们。</p>
<ul>
<li>
<p>✅<a href="https://www.youtube.com/watch?v=nieOiG8LGa0"><strong>在 Logseq 中使用 GTD</strong></a></p>
<p>想要使用 GTD 框架构建您的任务和项目管理？Dario 将帮助您开始了解如何使用元数据和 Logseq 功能。</p>
</li>
<li>
<p>🔁**<a href="https://www.youtube.com/watch?v=GNfIJhuLeZs">任务管理、时间限制和生产习惯</a>**</p>
<p>这是 Dario da Silva 的另一个视频，这次由<a href="https://twitter.com/joshduffney">Josh Duffney</a>加入。他们谈论了他们如何使用 Logseq 来安排他们的日子，并深入探讨了如何使用 Logseq 的查询系统重新展示任务和其他笔记。对话的特定于 Logseq 的部分从<a href="https://www.youtube.com/watch?v=GNfIJhuLeZs&amp;t=1322s">22:02开始</a></p>
</li>
<li>
<p>📕 <strong><a href="https://www.youtube.com/watch?v=4WnZ293Ff4I">Sawhney 在 Logseq 中的任务管理指南</a></strong></p>
<p>在此视频中，<a href="https://twitter.com/aryansawhney17">Aryan Sawhney</a>将带您从在日记页面上输入简单任务到使用高级查询重新显示它们——以及介于两者之间的所有内容。如果您想在您的日记页面上显示一组重复查询，请查看此视频的后半部分。</p>
<iframe width="200" height="113" src="https://www.youtube.com/embed/4WnZ293Ff4I?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" title="The ULTIMATE Guide to Task Management in Logseq" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px;" enablejsapi="true" id="widget10"></iframe>
</li>
</ul>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://blog.logseq.com/newsletter-11-how-to-manage-tasks-and-projects-in-logseq/">Newsletter #11: How to Manage Tasks and Projects in Logseq - https://blog.logseq.com/newsletter-11-how-to-manage-tasks-and-projects-in-logseq/</a></p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://logseq.com/">Logseq: A privacy-first, open-source knowledge base - https://logseq.com/</a></p>
]]></content>
      <categories>
        <category>Awosome Software</category>
        <category>Logseq</category>
        <category>Blog</category>
        <category>Logseq Newsletter</category>
      </categories>
      <tags>
        <tag>Awosome Software</tag>
        <tag>Logseq</tag>
        <tag>Blog</tag>
        <tag>Task</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>[Logseq 博客 中文翻译] Newsletter #12：如何构建 Logseq Graph 以获得洞察力</title>
    <url>/2022/08/06/Awosome-Software/Logseq/Blog/newsletter-12-how-to-structure-your-logseq-graph-for-insight/</url>
    <content><![CDATA[<h1>Newsletter #12：如何构建 Logseq Graph 以获得洞察力</h1>
<p><img src="https://blog.logseq.com/content/images/size/w960/2022/08/newsletter-structured-graph-featured.png" alt="Newsletter #12：如何构建 Logseq Graph 以获得洞察力"></p>
<p>嗨 Logseqers！</p>
<p>经过短暂的休息后，我们带着满满的资源回来了，以帮助您从 Logseq 中获得更多信息。</p>
<p>本周，您将抢先了解即将推出的同步和白板功能、新插件和主题的概述，并了解有关构建 Graph 的所有知识。</p>
<p>让我们深入挖掘！</p>
<span id="more"></span>
<h2 id="Logseq-的新功能">Logseq 的新功能</h2>
<ul>
<li>
<p>我们升级到了 0.7.9 版，最近的几次更新为 Logseq 添加了更多润色。<a href="https://logseq.com/">从 Logseq.com 下载最新版本</a>或在应用程序 ( <code>...</code>&gt; <code>Settings</code>) 内查看以进行更新。</p>
</li>
<li>
<p>除了修复之外，我们还对<code>property::</code>系统进行了大修。这应该更容易维护您的个人元数据系统。</p>
</li>
<li>
<p>从现在开始，每当您键入时，<code>::</code>您都会看到以前使用的属性键的列表，这些键会在您键入时进行过滤：</p>
<p><img src="https://blog.logseq.com/content/images/2022/08/image.png" alt=""></p>
<p>选择键时，您将看到与该键组合使用的所有值：</p>
<p><img src="https://blog.logseq.com/content/images/2022/08/image-1.png" alt=""></p>
</li>
</ul>
<h2 id="先睹为快：Logseq-同步和白板">先睹为快：Logseq 同步和白板</h2>
<ul>
<li>
<p>🔄 <a href="https://twitter.com/logseq/status/1550438645534007297"><strong>Logseq Sync</strong></a></p>
<p>我们即将推出封闭测试版的 Logseq Sync 服务。如果您一直在努力使用 Dropbox、OneDrive 或 iCloud 等提供商保持设备同步，Logseq Sync 将是解决方案。</p>
<p>同步将在免费和付费计划中提供，我们的 OpenCollective 支持者和赞助商将首先通过封闭测试版获得访问权限。我们很快会向您发送一封包含更多信息的电子邮件。</p>
<p>想知道 Logseq Sync 的实际应用吗？不久前，我们在 Twitter 上发布了这段视频：</p>
<iframe id="twitter-widget-0" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" class="" style="position: static; visibility: visible; width: 550px; height: 587px; display: block; flex-grow: 1;" title="Twitter Tweet" src="https://platform.twitter.com/embed/Tweet.html?creatorScreenName=rroudt&amp;dnt=false&amp;embedId=twitter-widget-0&amp;features=eyJ0ZndfdGltZWxpbmVfbGlzdCI6eyJidWNrZXQiOlsibGlua3RyLmVlIiwidHIuZWUiLCJ0ZXJyYS5jb20uYnIiLCJ3d3cubGlua3RyLmVlIiwid3d3LnRyLmVlIiwid3d3LnRlcnJhLmNvbS5iciJdLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X2hvcml6b25fdGltZWxpbmVfMTIwMzQiOnsiYnVja2V0IjoidHJlYXRtZW50IiwidmVyc2lvbiI6bnVsbH0sInRmd190d2VldF9lZGl0X2JhY2tlbmQiOnsiYnVja2V0Ijoib24iLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3JlZnNyY19zZXNzaW9uIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH0sInRmd19jaGluX3BpbGxzXzE0NzQxIjp7ImJ1Y2tldCI6ImNvbG9yX2ljb25zIiwidmVyc2lvbiI6bnVsbH0sInRmd190d2VldF9yZXN1bHRfbWlncmF0aW9uXzEzOTc5Ijp7ImJ1Y2tldCI6InR3ZWV0X3Jlc3VsdCIsInZlcnNpb24iOm51bGx9LCJ0Zndfc2Vuc2l0aXZlX21lZGlhX2ludGVyc3RpdGlhbF8xMzk2MyI6eyJidWNrZXQiOiJpbnRlcnN0aXRpYWwiLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X2V4cGVyaW1lbnRzX2Nvb2tpZV9leHBpcmF0aW9uIjp7ImJ1Y2tldCI6MTIwOTYwMCwidmVyc2lvbiI6bnVsbH0sInRmd19kdXBsaWNhdGVfc2NyaWJlc190b19zZXR0aW5ncyI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfdmlkZW9faGxzX2R5bmFtaWNfbWFuaWZlc3RzXzE1MDgyIjp7ImJ1Y2tldCI6InRydWVfYml0cmF0ZSIsInZlcnNpb24iOm51bGx9LCJ0ZndfdHdlZXRfZWRpdF9mcm9udGVuZCI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9fQ%3D%3D&amp;frame=false&amp;hideCard=false&amp;hideThread=false&amp;id=1550438645534007297&amp;lang=en&amp;origin=https%3A%2F%2Fblog.logseq.com%2Fnewsletter-12-how-to-structure-your-logseq-graph-for-insight%2F&amp;sessionId=6b75294c644561f0d48cc7a75f1693c10130ed9c&amp;siteScreenName=logseq&amp;theme=light&amp;widgetsVersion=1c23387b1f70c%3A1664388199485&amp;width=550px" data-tweet-id="1550438645534007297"></iframe>
</li>
<li>
<p>🧑‍🏫 <a href="https://twitter.com/pengx17/status/1552172906146398208?s=20&amp;t=6ilf0wWPkI_tFiST1X3TFQ"><strong>Logseq 白板</strong></a></p>
<p>社区贡献者<a href="https://twitter.com/pengx17">Peng</a>即将发布 Logseq 白板功能的第一个公共版本。基于<a href="https://github.com/tldraw/tldraw">tldraw</a>，Logseq Whiteboard 将为您的图形带来空间思维。这是其当前功能的演示：</p>
<ul>
<li>
<iframe id="twitter-widget-1" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" class="" style="position: static; visibility: visible; width: 550px; height: 657px; display: block; flex-grow: 1;" title="Twitter Tweet" src="https://platform.twitter.com/embed/Tweet.html?creatorScreenName=rroudt&amp;dnt=false&amp;embedId=twitter-widget-1&amp;features=eyJ0ZndfdGltZWxpbmVfbGlzdCI6eyJidWNrZXQiOlsibGlua3RyLmVlIiwidHIuZWUiLCJ0ZXJyYS5jb20uYnIiLCJ3d3cubGlua3RyLmVlIiwid3d3LnRyLmVlIiwid3d3LnRlcnJhLmNvbS5iciJdLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X2hvcml6b25fdGltZWxpbmVfMTIwMzQiOnsiYnVja2V0IjoidHJlYXRtZW50IiwidmVyc2lvbiI6bnVsbH0sInRmd190d2VldF9lZGl0X2JhY2tlbmQiOnsiYnVja2V0Ijoib24iLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3JlZnNyY19zZXNzaW9uIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH0sInRmd19jaGluX3BpbGxzXzE0NzQxIjp7ImJ1Y2tldCI6ImNvbG9yX2ljb25zIiwidmVyc2lvbiI6bnVsbH0sInRmd190d2VldF9yZXN1bHRfbWlncmF0aW9uXzEzOTc5Ijp7ImJ1Y2tldCI6InR3ZWV0X3Jlc3VsdCIsInZlcnNpb24iOm51bGx9LCJ0Zndfc2Vuc2l0aXZlX21lZGlhX2ludGVyc3RpdGlhbF8xMzk2MyI6eyJidWNrZXQiOiJpbnRlcnN0aXRpYWwiLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X2V4cGVyaW1lbnRzX2Nvb2tpZV9leHBpcmF0aW9uIjp7ImJ1Y2tldCI6MTIwOTYwMCwidmVyc2lvbiI6bnVsbH0sInRmd19kdXBsaWNhdGVfc2NyaWJlc190b19zZXR0aW5ncyI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfdmlkZW9faGxzX2R5bmFtaWNfbWFuaWZlc3RzXzE1MDgyIjp7ImJ1Y2tldCI6InRydWVfYml0cmF0ZSIsInZlcnNpb24iOm51bGx9LCJ0ZndfdHdlZXRfZWRpdF9mcm9udGVuZCI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9fQ%3D%3D&amp;frame=false&amp;hideCard=false&amp;hideThread=false&amp;id=1552172906146398208&amp;lang=en&amp;origin=https%3A%2F%2Fblog.logseq.com%2Fnewsletter-12-how-to-structure-your-logseq-graph-for-insight%2F&amp;sessionId=6b75294c644561f0d48cc7a75f1693c10130ed9c&amp;siteScreenName=logseq&amp;theme=light&amp;widgetsVersion=1c23387b1f70c%3A1664388199485&amp;width=550px" data-tweet-id="1552172906146398208"></iframe>
</li>
</ul>
</li>
</ul>
<h2 id="新主题和插件">新主题和插件</h2>
<p>在过去的几周里，几个新的主题和插件登陆了市场。在Logseq中的<code>...</code>&gt; <code>Plugins</code> &gt; <code>Marketplace</code>中搜索它们。</p>
<ul>
<li>
<p>🎨 <strong><a href="https://github.com/gavinmn/logseq-luma">Luma 主题</a></strong></p>
<p>设计师<a href="https://twitter.com/Gavmn">Gavin Nelson</a>最近才来到 Logseq 社区，并且已经创建了这个名为<strong>Luma</strong>的美丽主题：</p>
<p><img src="https://blog.logseq.com/content/images/2022/08/logseq-luma-theme.png" alt=""></p>
</li>
<li>
<p>📺 <a href="https://github.com/darthorimar/logseq-movies-plugin"><strong>Movies Plugin</strong></a></p>
<p>如果你使用 Logseq 来维护个人电影数据库，你必须有 Movies Plugin。它使您可以轻松搜索<a href="https://www.imdb.com/">IMDb</a>并插入指向特定标题的链接。</p>
</li>
<li>
<p>🤓 <a href="https://github.com/OverflowCat/logseq-simpread"><strong>Simpread 插件</strong></a></p>
<p>如果你使用中文开源沉浸式阅读应用<a href="https://github.com/Kenshin/simpread">Simpread</a>，你会想要使用它<a href="https://github.com/OverflowCat/logseq-simpread">与 Logseq 的官方集成</a>。</p>
</li>
<li>
<p>📅 <a href="https://github.com/yoyurec/logseq-banners-plugin"><strong>[更新] 横幅插件</strong></a></p>
<p><a href="https://twitter.com/yoyurec">Yurii</a> Piskun的主题和插件让我们惊叹不已。他的<a href="https://github.com/yoyurec/logseq-banners-plugin">横幅插件</a>的最新更新 (2.0)附带了一个小部件功能。您不仅可以通过添加顶部横幅来个性化各个页面，现在您还可以添加天气、番茄计时器和日历！</p>
<p><img src="https://blog.logseq.com/content/images/2022/08/widgets-dark-03.png" alt=""></p>
</li>
</ul>
<h2 id="向社区学习">向社区学习</h2>
<ul>
<li>
<p>🕸<a href="https://www.youtube.com/watch?v=yJOox5FbuAM"><strong>如何在 Graph 中创建连接</strong></a></p>
<p>在此视频中，<a href="https://twitter.com/trashhalo">Stephen Solka</a>（<a href="https://github.com/trashhalo/logseq-graph-analysis">Graph 分析插件</a>的创建者）展示了如何在 Graph 视图中创建连接。虽然 Graph 需要改进，但如果您组织笔记，查看关系已经很有帮助。</p>
</li>
<li>
<p>💡<a href="https://www.youtube.com/watch?v=_x0iAgY1Zao"><strong>使用 Logseq 产生新想法</strong></a></p>
<p>Stephen Solka 的另一个有用资源是这段视频演练，介绍了他如何使用 Logseq 产生新想法。Stephen 向我们展示了他如何遇到新想法，如何通过重组和链接来处理想法，使用 GPT-3 深入挖掘一个主题，并使用他的 Graph Analysis 插件来发现新的联系。</p>
</li>
<li>
<p>📑 Logseq<a href="https://www.youtube.com/watch?v=POQgVXpaHxw"><strong>中命名空间的终极指南</strong></a></p>
<p>虽然 Logseq 没有​​传统的文件夹结构，但您绝对可以构建您的笔记。在 Logseq 中，您可以使用称为命名空间的东西轻松创建页面层次结构。在此视频中，Aryan Sawhney 将教您在任何凌乱的 Graph 中进行排序所需知道的一切。</p>
</li>
<li>
<p>🧑‍🎓**<a href="https://luhmann-logseq.notion.site/Ideal-Academic-Workflow-Illustrated-99bbe3f259ab426895831cb7293da452">理想的学术工作流程，图解</a>**</p>
<p>学术和“工作流程思想家” <a href="https://discuss.logseq.com/u/luhmann/summary">Luhmann</a> 创建了他的工作流程图解演练。如果您使用 Logseq 进行研究并需要跟踪您的来源，那么此工作流程应该适合您。</p>
</li>
</ul>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://blog.logseq.com/newsletter-12-how-to-structure-your-logseq-graph-for-insight/">Newsletter #12: How to Structure Your Logseq Graph for Insight - https://blog.logseq.com/newsletter-12-how-to-structure-your-logseq-graph-for-insight/</a></p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://logseq.com/">Logseq: A privacy-first, open-source knowledge base - https://logseq.com/</a></p>
]]></content>
      <categories>
        <category>Awosome Software</category>
        <category>Logseq</category>
        <category>Blog</category>
        <category>Logseq Newsletter</category>
      </categories>
      <tags>
        <tag>Awosome Software</tag>
        <tag>Logseq</tag>
        <tag>Blog</tag>
        <tag>Logseq Sync</tag>
        <tag>Logseq Whiteboard</tag>
        <tag>Logseq Namespace</tag>
      </tags>
  </entry>
  <entry>
    <title>[Logseq 博客 中文翻译] Newsletter #13：今年夏天我们一直在忙于建设！</title>
    <url>/2022/09/24/Awosome-Software/Logseq/Blog/newsletter-13-weve-been-busy-building-this-summer/</url>
    <content><![CDATA[<h1>Newsletter #13：今年夏天我们一直在忙于建设！</h1>
<p><img src="https://blog.logseq.com/content/images/size/w960/2022/09/building-featured.png" alt=" Newsletter  #13：今年夏天我们一直在忙于建设！"></p>
<p>亲爱的 Logseqers，</p>
<p>我们从 Newsletter 休息回来了！由于社区正在享受夏天并且没有共享尽可能多的资源，我们利用时间继续建设。在本 Newsletter 中，我们将分享我们一直在努力的一些事情，以及您对我们接下来的期望。</p>
<p>今年夏天，我们还进行了两次学习冲刺，以帮助您掌握 Logseq 查询。<a href="https://discuss.logseq.com/tags/c/learning-sprints/queries/20/lesson">转到查询论坛 - https://discuss.logseq.com/tags/c/learning-sprints/queries/20/lesson</a>或向下滚动到本 Newsletter 的末尾以赶上课程。</p>
<p>最后但并非最不重要的一点是，我们以一系列新的社区插件来结束 Newsletter 。</p>
<p>您将使用这些新构建块创建哪些工作流程？</p>
<span id="more"></span>
<h2 id="尽早访问-Logseq-Sync">尽早访问 Logseq Sync</h2>
<p>Logseq 最令人沮丧的部分可能是不同设备之间的同步。</p>
<p>作为狂热的移动用户，我们在使用 iCloud 和 Dropbox 等服务时经常会遇到同步冲突。我们从您那里听到了同样的情况，更不用说使用此类服务 ​​ 的隐私问题了。这就是为什么我们一直在开发自己的同步服务，提供端到端加密，因此不必信任 任何 拥有您数据密钥的人（包括我们）。</p>
<p>我们一直在与一小群测试人员和我们的赞助商（<a href="https://opencollective.com/logseq/contribute/sponsors-21163">每月捐赠超过 15 美元 - https://opencollective.com/logseq/contribute/sponsors-21163</a>）一起测试 Logseq Sync。现在我们已经解决了一些重要的挑战，我们几乎准备好让我们的支持者（<a href="https://opencollective.com/logseq/contribute/backers-21161">每月捐赠 5 美元 - https://opencollective.com/logseq/contribute/backers-21161</a>的人）也可以使用 Sync。如果您是支持者（或现在成为支持者），请在本周晚些时候收到一封包含更多信息的电子邮件。</p>
<p>我们还不知道同步何时普遍可用。但是，如果您想抢先体验并为我们提供宝贵的反馈，请<a href="https://opencollective.com/logseq/contribute/backers-21161">成为支持者 - https://opencollective.com/logseq/contribute/backers-21161</a>或<a href="https://opencollective.com/logseq/contribute/sponsors-21163">赞助商 - https://opencollective.com/logseq/contribute/sponsors-21163</a>。</p>
<h2 id="自-0-7-9-以来发生了什么变化。">自 0.7.9 以来发生了什么变化。</h2>
<p>当我们发送上一份 Newsletter 时，我们使用的是 0.7.9 版本（Logseq 测试版）。在过去的几周里，我们进行了快速迭代，现在版本已经达到<a href="https://github.com/logseq/logseq/releases/tag/0.8.7">0.8.7。</a>这些是过去几周最重要的变化：</p>
<ul>
<li>
<p>对大 Graph 的巨大性能改进。</p>
</li>
<li>
<p>改进的链接引用，包括值的搜索字段。</p>
</li>
<li>
<p><a href="https://docs.logseq.com/#/page/term%2Fproperties">（页面）属性 - https://docs.logseq.com/#/page/term%2Fproperties</a>现在可单击并创建页面（从而提供更多搜索方式）。</p>
<p>添加了对<a href="https://docs.logseq.com/#/page/Global%20configuration">全局配置文件 - https://docs.logseq.com/#/page/Global%20configuration</a>的支持，它将您的配置应用于所有 Graph。</p>
</li>
<li>
<p>添加了对<code>Ctrl-f</code>（<code>Cmd-f</code>在 macOS 上）<a href="https://docs.logseq.com/#/page/Find%20in%20page">在页面中查找的</a>支持。此功能适用于 Logseq 中的每个页面，包括内置的键盘快捷键页面。</p>
</li>
<li>
<p>感谢社区，Logseq 现在支持以下语言：英语、法语、德语、荷兰语、南非荷兰语、挪威语、波兰语、意大利语、西班牙语、葡萄牙语（巴西和欧洲）、土耳其语、俄语、中文（简体和繁体）、日文，韩文。</p>
</li>
</ul>
<h2 id="深入了解-Logseq-查询">深入了解 Logseq 查询</h2>
<p>夏季查询冲刺结束了！在 7 月和 8 月，超过 250 人决定花时间和精力更好地了解 Logseq。</p>
<p>八月冲刺是一个自定进度的课程，每天都有挑战，让知识成为你自己的知识。如果您错过了课程，这里有一个完整的概述：</p>
<ul>
<li>
<p><a href="https://discuss.logseq.com/t/kick-off-session-supercharge-your-search-by-mastering-logseq-queries/10069">启动会议：通过掌握 Logseq 查询来增强您的搜索 - https://discuss.logseq.com/t/kick-off-session-supercharge-your-search-by-mastering-logseq-queries/10069</a></p>
</li>
<li>
<p><a href="https://discuss.logseq.com/t/lesson-1-what-are-logseq-queries-and-why-you-should-learn-to-use-them/9987">第 1 课：什么是 Logseq 查询以及为什么要学习使用它们 - https://discuss.logseq.com/t/lesson-1-what-are-logseq-queries-and-why-you-should-learn-to-use-them/9987</a></p>
</li>
<li>
<p><a href="https://discuss.logseq.com/t/lesson-2-why-you-should-outline-and-link-your-notes/10038">第 2 课：为什么要概述和链接笔记 - https://discuss.logseq.com/t/lesson-2-why-you-should-outline-and-link-your-notes/10038</a></p>
</li>
<li>
<p><a href="https://discuss.logseq.com/t/lesson-3-how-to-think-like-a-computer-using-boolean-logic/10074">第 3 课：如何使用布尔逻辑像计算机一样思考 - https://discuss.logseq.com/t/lesson-3-how-to-think-like-a-computer-using-boolean-logic/10074</a></p>
</li>
<li>
<p><a href="https://discuss.logseq.com/t/lesson-4-how-to-search-your-notes-using-query-filters-and-links/10131">第 4 课：如何使用查询过滤器和链接搜索笔记 - https://discuss.logseq.com/t/lesson-4-how-to-search-your-notes-using-query-filters-and-links/10131</a></p>
</li>
<li>
<p><a href="https://discuss.logseq.com/t/lesson-5-how-to-power-your-workflows-using-properties-and-dynamic-variables/10173">第 5 课：如何使用属性和动态变量为您的工作流程提供动力 - https://discuss.logseq.com/t/lesson-5-how-to-power-your-workflows-using-properties-and-dynamic-variables/10173</a></p>
<p>一旦你掌握了理论，通过以下构建挑战来挑战自己：</p>
</li>
<li>
<p><a href="https://discuss.logseq.com/t/challenge-1-build-a-dynamic-notes-index/10274">挑战 1：构建动态笔记索引 - https://discuss.logseq.com/t/challenge-1-build-a-dynamic-notes-index/10274</a></p>
</li>
<li>
<p><a href="https://discuss.logseq.com/t/challenge-2-build-a-content-consumption-pipeline/10305">挑战二：构建内容消费管道 - https://discuss.logseq.com/t/challenge-2-build-a-content-consumption-pipeline/10305</a></p>
</li>
<li>
<p><a href="https://discuss.logseq.com/t/challenge-3-build-a-content-creation-pipeline/10333">挑战 3：构建内容创建管道 - https://discuss.logseq.com/t/challenge-3-build-a-content-creation-pipeline/10333</a></p>
</li>
<li>
<p><a href="https://discuss.logseq.com/t/challenge-4-build-a-project-management-dashboard/10384">挑战 4：构建项目管理仪表板 - https://discuss.logseq.com/t/challenge-4-build-a-project-management-dashboard/10384</a></p>
</li>
<li>
<p><a href="https://discuss.logseq.com/t/challenge-5-build-a-personal-learning-dashboard/10418">挑战 5：构建个人学习仪表板 - https://discuss.logseq.com/t/challenge-5-build-a-personal-learning-dashboard/10418</a></p>
</li>
</ul>
<h2 id="新的社区插件">新的社区插件</h2>
<p>在过去的几周里，几个新插件登陆了市场。   在 Logseq   中的<code>...</code>  &gt; <code>Plugins</code> &gt; <code>Marketplace</code>中搜索它们。</p>
<ul>
<li>
<p>🔄 <a href="https://github.com/vipzhicheng/logseq-plugin-random-block"><strong>Logseq 随机块 - https://github.com/vipzhicheng/logseq-plugin-random-block</strong></a></p>
<p>使用这个随机块插件给自己一点灵感。使用标签和链接，您可以从要提取的块池中进行微调。</p>
</li>
<li>
<p>📈 <a href="https://github.com/guzhongren/logseq-echarts"><strong>Logseq Echarts - https://github.com/guzhongren/logseq-echarts</strong></a></p>
<p>如果你使用<a href="https://echarts.apache.org/en/index.html">Apache Echarts - https://echarts.apache.org/en/index.html</a>（一个 JavaScript 可视化库），你会喜欢这个插件。它允许您直接在 Logseq 中编写 Echarts JSON 并让它呈现图表。</p>
</li>
<li>
<p>📗 <a href="https://github.com/trashhalo/logseq-dictionary"><strong>Logseq Dictionary - https://github.com/trashhalo/logseq-dictionary</strong></a></p>
<p>有了这本多语言词典，使用 Logseq 学习语言变得轻而易举。</p>
</li>
<li>
<p>🪧<a href="https://github.com/nmartin84/admonition-panels">警告面板 - https://github.com/nmartin84/admonition-panels</a></p>
<p>多亏了这个警告插件，构建您的个人 wiki 变得更加容易。它使您能够使用漂亮的样式引起对块的注意：</p>
<p><img src="https://blog.logseq.com/content/images/2022/09/image.png" alt=""></p>
</li>
<li>
<p>📄<a href="https://github.com/georgeguimaraes/logseq-plugin-merge-nested-blocks-into-one"><strong>合并嵌套块 - https://github.com/georgeguimaraes/logseq-plugin-merge-nested-blocks-into-one</strong></a></p>
<p>你使用 Logseq 进行长篇写作吗？这个插件会派上用场，因为它允许您将整个块分支变成一个类似页面的块：</p>
<p><img src="https://blog.logseq.com/content/images/2022/09/merge-blocks-demo.gif" alt=""><br>
<a href="https://blog.logseq.com/newsletter-12-how-to-structure-your-logseq-graph-for-insight/"></a></p>
</li>
</ul>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://blog.logseq.com/newsletter-13-weve-been-busy-building-this-summer/">Newsletter #13: We’ve Been Busy Building This Summer! - https://blog.logseq.com/newsletter-13-weve-been-busy-building-this-summer/</a></p>
]]></content>
      <categories>
        <category>Awosome Software</category>
        <category>Logseq</category>
        <category>Blog</category>
        <category>Logseq Newsletter</category>
      </categories>
      <tags>
        <tag>Awosome Software</tag>
        <tag>Logseq</tag>
        <tag>Blog</tag>
        <tag>Logseq Sync</tag>
        <tag>Sprint</tag>
        <tag>Summer</tag>
        <tag>Logseq Query</tag>
      </tags>
  </entry>
  <entry>
    <title>[Logseq 博客 中文翻译] Newsletter #14：更好的 PDF 阅读器、同步、白板和新的社区创作</title>
    <url>/2022/10/22/Awosome-Software/Logseq/Blog/newsletter-14-a-better-pdf-reader-sync-whiteboards-and-new-community-creations/</url>
    <content><![CDATA[<h1>Newsletter #14：更好的 PDF 阅读器、同步、白板和新的社区创作</h1>
<p><img src="https://blog.logseq.com/content/images/size/w960/2022/10/logseq-newsletter-14-featured.png" alt="时事通讯 #14：更好的 PDF 阅读器、同步、白板和新的社区创作"></p>
<p>嗨 Logseqers！</p>
<p>本月的 Newsletter 充满了激动人心的公告和新功能。与社区一起，我们一直在完善一些核心功能并开发新功能，这肯定会让您成为更好的思考者和学习者。</p>
<p>如果您对我们如何不断改进有任何建议，请在<a href="https://discuss.logseq.com/">Logseq 论坛</a>或<a href="https://discord.gg/5KwWf8QnQU">Discord 上的官方 Logseq 服务器</a>中告诉我们。</p>
<p>现在，让我们看看我们一直在构建什么！</p>
<span id="more"></span>
<h2 id="0-8-9-中的新功能。">0.8.9 中的新功能。</h2>
<p>今天我们发布了<a href="https://github.com/logseq/logseq/releases/tag/0.8.9">0.8.9 版本。Logseq 桌面和 Android 的</a>。新的 iOS 版本即将登陆 App Store。</p>
<p>我们添加了许多新功能并改进了一些现有功能。这些是我们最喜欢的变化：</p>
<h3 id="📑-PDF-阅读器改进">📑 PDF 阅读器改进</h3>
<p>Logseq 最受欢迎的功能之一变得更好了！</p>
<p>我们为 PDF 添加了全文搜索，这是最受欢迎的功能之一。</p>
<p>接下来，我们添加了一个高亮显示窗格，您可以在其中概览 PDF 中的所有高亮显示。</p>
<p>最后但并非最不重要的一点是，高亮的颜色也变得更有意义，因为高亮引用现在与高亮颜色匹配。请看下面的演示：</p>
<p><video src="https://cdn.loom.com/sessions/thumbnails/fa7ad4bb1dcd4d21b8f76e3e03c19d7f-00001.mp4" playsinline="" loop="" autoplay="" class="css-1dd3ex7"></video></p>
<h3 id="🎨块高亮">🎨块高亮</h3>
<p>不只是 PDF 阅读器有一点点高亮颜色；您现在还可以为各个块添加一抹色彩。右键单击一个块的开头小黑点，您可以选择用什么颜色高亮突出它：</p>
<p><video src="https://blog.logseq.com/content/media/2022/10/block-highlight-demo.webm" poster="https://img.spacergif.org/v1/1280x720/0a/spacer.png" width="1280" height="720" playsinline="" preload="metadata" style="background: transparent url('https://blog.logseq.com/content/images/2022/10/media-thumbnail-ember287.jpg') 50% 50% / cover no-repeat;"></video></p>
<h3 id="🔌持久插件列表">🔌持久插件列表</h3>
<p>更好的插件管理是另一个受欢迎的要求。我们中的许多人都在多个桌面上工作，并且必须维护两个或多个插件列表很快就会变得陈旧。</p>
<p>这就是我们添加该<code>plugins.edn</code>文件的原因，该文件会保存您的插件列表，并可以轻松地与您的设备或 Logseq 社区的成员共享它们。<a href="https://docs.logseq.com/#/page/plugins.edn">阅读我们的文档如何使用 plugins.edn。</a></p>
<h2 id="同步状态">同步状态</h2>
<p>在我们<a href="https://blog.logseq.com/newsletter-13-weve-been-busy-building-this-summer/">之前的时事通讯</a>中，我们提到我们将很快向我们的支持者开放同步服务。不幸的是，alpha 测试阶段花费的时间比预期的要长。似乎巴贝奇定律仍然适用：<em>“没有计算机能按时建成。”</em></p>
<p>目前，我们将同步访问限制在<a href="https://opencollective.com/logseq/contribute/sponsors-21163">赞助商层</a>，因为我们仍然需要进行大量故障排除。这意味着我们无法通过一次添加更多 Sync 用户来进行扩展，因为这会阻塞我们的支持渠道。</p>
<p>如果您真的迫不及待，请随时<a href="https://opencollective.com/logseq/contribute/sponsors-21163">成为赞助商</a>。请务必意识到您将使用 alpha 软件。虽然几个月来我们一直在使用 Sync 几乎没有问题，但有时我们会遇到需要时间和注意力的问题。</p>
<blockquote>
<p>💡 对于那些捐赠超过 15 美元但无法访问 Sync 的人来说，请注意：我们的alpha 功能适用于我们的<a href="https://opencollective.com/logseq/contribute/sponsors-21163">开放集体_赞助者层_</a>。捐赠 15 美元不会自动进入此级别；您必须明确选择它。通过成为赞助商，您承诺_每月_捐赠 15 美元，直到您取消定期捐赠。</p>
</blockquote>
<p>如果您可以等待，请知道我们正在努力向更多的财务支持者开放 Logseq Sync。同时，这里是 Sync 的样子（状态指示器和页面历史）：</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/image-3.png" alt=""></p>
<p><img src="https://blog.logseq.com/content/images/2022/10/image-1.png" alt=""></p>
<h2 id="白板现在可供赞助商使用">白板现在可供赞助商使用</h2>
<p>如果您是赞助商，您还可以从今天开始访问白板功能的 Alpha 版。基于<a href="https://github.com/tldraw/tldraw">tldraw</a>，白板让您可以在无限的画布上使用您的轮廓并绘制您喜欢的任何形状。<br>
您可以通过 <code>...</code> &gt; <code>Settings</code>&gt;激活白板功能<code>Features</code>（仅适用于<a href="https://opencollective.com/logseq/contribute/sponsors-21163"><strong><em>赞助商层</em></strong>！</a>）：<br>
<img src="https://blog.logseq.com/content/images/2022/10/alpha-whiteboards.png" alt="">{:height 428, :width 716}</p>
<p>如果您错过了白板功能的内容，这里有一个早期演示：</p>
<iframe id="twitter-widget-0" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" class="" style="position: static; visibility: visible; width: 550px; height: 657px; display: block; flex-grow: 1;" title="Twitter Tweet" src="https://platform.twitter.com/embed/Tweet.html?creatorScreenName=rroudt&amp;dnt=false&amp;embedId=twitter-widget-0&amp;features=eyJ0ZndfdGltZWxpbmVfbGlzdCI6eyJidWNrZXQiOlsibGlua3RyLmVlIiwidHIuZWUiLCJ0ZXJyYS5jb20uYnIiLCJ3d3cubGlua3RyLmVlIiwid3d3LnRyLmVlIiwid3d3LnRlcnJhLmNvbS5iciJdLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X2hvcml6b25fdGltZWxpbmVfMTIwMzQiOnsiYnVja2V0IjoidHJlYXRtZW50IiwidmVyc2lvbiI6bnVsbH0sInRmd190d2VldF9lZGl0X2JhY2tlbmQiOnsiYnVja2V0Ijoib24iLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3JlZnNyY19zZXNzaW9uIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH0sInRmd19jaGluX3BpbGxzXzE0NzQxIjp7ImJ1Y2tldCI6ImNvbG9yX2ljb25zIiwidmVyc2lvbiI6bnVsbH0sInRmd190d2VldF9yZXN1bHRfbWlncmF0aW9uXzEzOTc5Ijp7ImJ1Y2tldCI6InR3ZWV0X3Jlc3VsdCIsInZlcnNpb24iOm51bGx9LCJ0Zndfc2Vuc2l0aXZlX21lZGlhX2ludGVyc3RpdGlhbF8xMzk2MyI6eyJidWNrZXQiOiJpbnRlcnN0aXRpYWwiLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X2V4cGVyaW1lbnRzX2Nvb2tpZV9leHBpcmF0aW9uIjp7ImJ1Y2tldCI6MTIwOTYwMCwidmVyc2lvbiI6bnVsbH0sInRmd19kdXBsaWNhdGVfc2NyaWJlc190b19zZXR0aW5ncyI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfdmlkZW9faGxzX2R5bmFtaWNfbWFuaWZlc3RzXzE1MDgyIjp7ImJ1Y2tldCI6InRydWVfYml0cmF0ZSIsInZlcnNpb24iOm51bGx9LCJ0ZndfdHdlZXRfZWRpdF9mcm9udGVuZCI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9fQ%3D%3D&amp;frame=false&amp;hideCard=false&amp;hideThread=false&amp;id=1552172906146398208&amp;lang=en&amp;origin=https%3A%2F%2Fblog.logseq.com%2Fnewsletter-14-a-better-pdf-reader-sync-whiteboards-and-new-community-creations%2F&amp;sessionId=b93ab1c670aeb85658095999b6a4a4c6cc330276&amp;siteScreenName=logseq&amp;theme=light&amp;widgetsVersion=1c23387b1f70c%3A1664388199485&amp;width=550px" data-tweet-id="1552172906146398208"></iframe>
<h2 id="新插件">新插件</h2>
<p>在过去的几周里， <a href="https://twitter.com/yoyurec">Yurii Piskun</a>手中的一些有用的插件在市场上掉了下来。最初是他（美丽的）Solarized 主题的一部分，您现在可以将此功能与任何主题一起使用。  在 Logseq中的<code>...</code>  &gt;   <code>Plugins</code>  &gt;   <code>Marketplace</code>-&gt;中搜索它们  。<code>Plugins</code></p>
<h3 id="🎨很棒的-UI">🎨<a href="https://github.com/yoyurec/logseq-awesome-ui">很棒的 UI</a></h3>
<p>这个插件打磨了 Logseq 的一些粗糙的边缘，比如搜索面板、查询，甚至是流行的选项卡插件。</p>
<h3 id="🪧-Sticky-Headers">🪧 <a href="https://github.com/yoyurec/logseq-sticky-headers"><strong>Sticky Headers</strong></a></h3>
<p>使用此插件，<code>H1-H5</code>当页面滚动时，标题将“粘”在顶部，始终向您显示您所在的部分。</p>
<h3 id="🔗-Awesome-Links">🔗 <a href="https://github.com/yoyurec/logseq-awesome-links"><strong>Awesome Links</strong></a></h3>
<p>想看外链的图标和内链的图标吗？这个插件就是这样做的！</p>
<h3 id="✍️-Logseq-Pen">✍️ <a href="https://github.com/vipzhicheng/logseq-plugin-pen"><strong>Logseq Pen</strong></a></h3>
<p>当我们忙于完善我们的白板功能时，<a href="https://twitter.com/vipzhicheng">Richard Yu</a>已经创建了这个简洁的插件，可以让您在 Logseq 中注释您的笔记。</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/logseq-pen-screencast_1664738577476_0.gif" alt=""></p>
<h2 id="新主题">新主题</h2>
<p>你厌倦了标准的 Logseq 颜色吗？查看市场上出现的精美新主题。在 Logseq中的<code>...</code>  &gt;   <code>Plugins</code>  &gt;   <code>Marketplace</code>-&gt; <code>Themes</code> 中搜索它们。</p>
<h3 id="Atmos"><a href="https://github.com/Mat4m0/logseq-atmos-theme"><strong>Atmos</strong></a></h3>
<p>使用美丽简约的 Atmos 主题美化您的标题。</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/atmos_theme_1664738958386_0.png" alt=""></p>
<h3 id="Arc"><a href="https://github.com/andyburris/logseq-arc-theme">Arc</a></h3>
<p>另一个华丽的简约主题是受 Arc Browser 启发的主题。</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/arc-theme_1664738965953_0.png" alt=""></p>
<h3 id="Flow"><a href="https://github.com/nmartin84/logseq-flow"><strong>Flow</strong></a></h3>
<p>从具有极简 Flow 主题的众多调色板中选择一种。</p>
<p><img src="https://blog.logseq.com/content/images/2022/10/flow-theme_1664738977160_0.gif" alt=""></p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p>[Newsletter 14: A Better PDF Reader, Sync, Whiteboards, and New Community Creations - <a href="https://blog.logseq.com/newsletter-14-a-better-pdf-reader-sync-whiteboards-and-new-community-creations">https://blog.logseq.com/newsletter-14-a-better-pdf-reader-sync-whiteboards-and-new-community-creations</a>]</p>
]]></content>
      <categories>
        <category>Awosome Software</category>
        <category>Logseq</category>
        <category>Blog</category>
        <category>Logseq Newsletter</category>
      </categories>
      <tags>
        <tag>Awosome Software</tag>
        <tag>Logseq</tag>
        <tag>Blog</tag>
        <tag>Logseq Sync</tag>
        <tag>Logseq Whiteboard</tag>
        <tag>Sprint</tag>
        <tag>Summer</tag>
        <tag>PDF Reader</tag>
        <tag>Block Highlight</tag>
        <tag>Logseq Plugin</tag>
        <tag>Logseq Theme</tag>
      </tags>
  </entry>
  <entry>
    <title>[Logseq 博客 中文翻译] Newsletter #7: 使用 Logseq 构建个人学习基础架构</title>
    <url>/2022/06/25/Awosome-Software/Logseq/Blog/newsletter-7-build-a-personal-learning-infrastructure-with-logseq/</url>
    <content><![CDATA[<h1>使用 Logseq 构建个人学习基础架构</h1>
<p>星期二快乐，Logseqers 同胞！</p>
<p>本周我们将继续学习 Logseq 主题。 为什么？ 因为社区不断为学习者提供实用资源。 因此，我们再次选择了最有用的插件和内容来帮助您构建个人学习系统。<br>
但是，我们希望做更多的事情来帮助您成为一个有效的学习者。</p>
<p>如果你想同时学习如何学习和掌握查询，你应该参加今年夏天的 Logseq 学习冲刺。 想知道更多？ 继续阅读并回复此电子邮件。</p>
<span id="more"></span>
<h2 id="学习冲刺">学习冲刺</h2>
<p>在过去两周我们做了十几次用户访谈之后，有一点很清楚：Logseq 主要用于学习和存储知识。检索知识最流行（但令人困惑）的方式是 Logseq 的查询。<br>
但是你如何使用查询？以及如何快速学会正确使用它们？</p>
<p>为了回答这些问题，我们想组织一个为期 3 周的学习冲刺。您不仅将学习如何学习 Logseq 的简单和高级查询，还将学习一两件关于如何快速学习的知识。<br>
我（Ramses）将促进这个 sprint 并教授我的学习过程。与一些高级用户一起，我将向您展示简单和高级查询的可能性。三周后，您将获得一个学习系统、几个查询驱动的仪表板和一个由 Logseq 爱好者组成的网络。</p>
<p>如果您有兴趣参加今年 7 月或 8 月的学习冲刺，请回复此电子邮件，让我们知道您想参加。也请告诉我们您喜欢哪个月份（7 月或 8 月）。一旦我们有更多关于学习冲刺开始时间和地点的详细信息，我们会尽快给您发送电子邮件。</p>
<h2 id="新版本：0-7-5">新版本：0.7.5</h2>
<p>今天，Logseq 桌面版和移动版（Android）新版本发布。 新的 Logseq iOS 版本正在等待 Apple 的批准。 <a href="https://github.com/logseq/logseq/releases/tag/0.7.5">前往 GitHub - https://github.com/logseq/logseq/releases/tag/0.7.5</a>或查看应用程序内部（… &gt; 设置）以进行更新。</p>
<p>没有发布任何新功能，这个版本只是为了增加润色和性能。 我们还为我们的 <a href="https://docs.logseq.com/#/page/Logseq%20Protocol">Logseq 协议 - https://docs.logseq.com/#/page/Logseq%20Protocol</a>添加了快速捕获功能，这对于（集成）开发人员来说会派上用场。<br>
<a href="https://github.com/logseq/logseq/issues/new?assignees=&amp;labels=&amp;template=bug_report.yaml">发现错误？ 请在 GitHub 上告诉我们。 - https://github.com/logseq/logseq/issues/new?assignees=&amp;labels=&amp;template=bug_report.yaml</a></p>
<h2 id="新插件">新插件</h2>
<p>Logseq Marketplace 不断增长，现在有 35 个主题和 129 个插件！在 Logseq 中的 … &gt; Plugins &gt; Marketplace 中搜索它们。这些是我们最喜欢的新插件。</p>
<p><a href="https://github.com/sawhney17/logseq-go-now">🏠 Go Home Now! - https://github.com/sawhney17/logseq-go-now</a></p>
<p>您有多经常在页面上书写并希望快速将该页面添加到您的日记页面？使用此插件，您可以点击键盘快捷键并立即在今天的期刊页面末尾创建一个新块。</p>
<p><a href="https://github.com/omnivore-app/logseq-omnivore">🤓 Logseq Omnivore - https://github.com/omnivore-app/logseq-omnivore</a></p>
<p>Read-it-later 应用程序是许多学习者必不可少的工具，但并非每个应用程序都与 Logseq 集成。但是开源应用程序 <a href="https://omnivore.app/">Omnivore - https://omnivore.app/</a> 现在可以了！[请务必阅读 Brian Sunter 关于如何设置此集成的指南 - <a href="https://briansunter.com/graph/#/page/omnivore-logseq-guide">https://briansunter.com/graph/#/page/omnivore-logseq-guide</a>]。</p>
<p><a href="https://github.com/briansunter/logseq-get-youtube-captions">📺 Get YouTube Captions - https://github.com/briansunter/logseq-get-youtube-captions</a></p>
<p>Brian Sunter 的另一个有用的插件是这个插件，它可以让你将 YouTube 字幕直接下载到你的 Logseq 图中。并结合 Brian 的 GPT-3 插件，可以<a href="https://twitter.com/Bsunter/status/1537115206412664833?s=20&amp;t=wDmEgk2ti5P7UHrXEctihQ">轻松将 20 分钟的视频变成 5 点摘要 - https://twitter.com/Bsunter/status/1537115206412664833?s=20&amp;t=wDmEgk2ti5P7UHrXEctihQ</a>。</p>
<p><a href="https://github.com/swk777/logseq-rainbow-tags">🌈 Logseq Rainbow Tags - https://github.com/swk777/logseq-rainbow-tags</a></p>
<p>最后但并非最不重要的一点是，此插件适用于你们中的所有定制者。如果您一直想为特定标签提供自定义颜色，彩虹标签插件是必备的。</p>
<h2 id="向社区学习">向社区学习</h2>
<p><a href="https://www.youtube.com/watch?v=C8u677y988g">🛠 如何在 Logseq 中创建间隔重复的抽认卡 - https://www.youtube.com/watch?v=C8u677y988g</a></p>
<p>你知道 Logseq 内置了抽认卡功能吗？在本演练中，Dario 展示了如何使用 Notepad++ 和 Microsoft Excel 快速创建多个 Logseq 抽认卡。这是学习工作流机制的一个很好的演示。</p>
<p>想要快速了解此工作流程吗？<a href="https://hub.logseq.com/use-cases/1Sr4awszMQzD4GM5KvWim7/how-to-quickly-create-spaced-repetition-flashcards-in-logseq-using-notepad-and-excel/jxPxEdkM4BBhLfrz9PfjBr">查看我们从社区中心的视频中截取的屏幕截图 - https://hub.logseq.com/use-cases/1Sr4awszMQzD4GM5KvWim7/how-to-quickly-create-spaced-repetition-flashcards-in-logseq-using-notepad-and-excel/jxPxEdkM4BBhLfrz9PfjBr</a>。</p>
<p><a href="https://www.appsntips.com/learn/create-book-tracker-logseq-keep-track-books-you-read/">📚 如何在 Logseq 中创建图书跟踪器 - https://www.appsntips.com/learn/create-book-tracker-logseq-keep-track-books-you-read/</a></p>
<p>如果您使用 Logseq 来跟踪您的习惯并存储您的笔记，为什么不同时保留一个书籍跟踪器呢？ <a href="https://twitter.com/appsntips">appntips - https://twitter.com/appsntips</a> 的这篇操作指南文章可帮助您设置元数据模板并使用查询创建自己的图书跟踪仪表板。你在这里学到的东西可以很容易地应用到你在 Logseq 中运行的其他流程中。</p>
<p><a href="https://qwxlea.github.io/#/page/datalog%2Fintro%20to%20datalog">🔎 Logseq 中的 Datalog 简介 - https://qwxlea.github.io/#/page/datalog%2Fintro%20to%20datalog</a></p>
<p>Twitter 上的 Logseq 社区正在蓬勃发展，并且始终共享有用的资源。就像 <a href="https://qwxlea.github.io/#/page/datalog%2Fintro%20to%20datalog">Alex Qwxlea 的这个资源 - https://qwxlea.github.io/#/page/datalog%2Fintro%20to%20datalog</a>一样，展示了如何利用 Datalog（AKA 高级查询）的力量。</p>
<p><a href="https://briansunter.com/graph/#/page/logseq-social">👥 Logseq 博客网络 (logseq-social) - https://briansunter.com/graph/#/page/logseq-social</a></p>
<p>如果您想公开学习并与其他 Logseqer 建立联系，请务必考虑加入 Logseq 博客网络。<a href="https://briansunter.com/graph/#/page/logseq-social">正如 Brian Sunter 在他的公共图谱中所解释的 - https://briansunter.com/graph/#/page/logseq-social</a>，发布您的图谱并开始关注其他公共图谱非常容易。该计划的目标是创建一个有趣的公共图谱网络以供学习。</p>
<p><a href="https://www.youtube.com/watch?v=QF5BzxtkZvQ">🧠 使用外部思维来发展你的思维 - https://www.youtube.com/watch?v=QF5BzxtkZvQ</a></p>
<p>如果您一直在考虑创建 Zettelkasten 来改善您的思维方式，那么您绝对应该关注 <a href="https://twitter.com/JeffreyWebber_">Jeffrey Webber - https://twitter.com/JeffreyWebber_</a>。在这个演示中，Jeffrey 展示了他如何处理一个主题或问题，然后通过写作来理解它。<br>
[[Zettelkasten Method]]</p>
<p><a href="https://www.youtube.com/watch?v=i7S4fXTJAnc">📋 如何在 Logseq 中注释 PDF 的任何部分 - https://www.youtube.com/watch?v=i7S4fXTJAnc</a></p>
<p>让我们以另一个演示结束本周的 Newsletter。在这段简短的视频中，<a href="https://twitter.com/mturilin">Mikhail Turilin - https://twitter.com/mturilin</a> 展示了他如何使用 Logseq 将他的手写笔记转换为数字笔记。借助 PDF 注释功能，他甚至可以在他的类型注释中包含绘图。</p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://blog.logseq.com/newsletter-7-build-a-personal-learning-infrastructure-with-logseq/">Newsletter #7: Build a Personal Learning Infrastructure With Logseq - https://blog.logseq.com/newsletter-7-build-a-personal-learning-infrastructure-with-logseq/</a></p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://logseq.com/">Logseq: A privacy-first, open-source knowledge base - https://logseq.com/</a></p>
]]></content>
      <categories>
        <category>Awosome Software</category>
        <category>Logseq</category>
        <category>Blog</category>
        <category>Logseq Newsletter</category>
      </categories>
      <tags>
        <tag>Thinking</tag>
        <tag>Awosome Software</tag>
        <tag>Note Taking</tag>
        <tag>Networked Thinking</tag>
        <tag>Logseq</tag>
        <tag>Blog</tag>
        <tag>Sprint</tag>
        <tag>Flashcard</tag>
        <tag>Zettelkasten Method</tag>
        <tag>Omnivore</tag>
      </tags>
  </entry>
  <entry>
    <title>[Logseq 文档中文翻译] - Logseq 协议</title>
    <url>/2022/06/25/Awosome-Software/Logseq/Docs/Logseq-Protocol/</url>
    <content><![CDATA[<h1>Logseq 协议</h1>
<p>Logseq 提供了一个协议 <code>logseq://</code> 以允许第三方应用程序打开并在 Logseq 中调用操作。</p>
<span id="more"></span>
<h2 id="支持以下网址：">支持以下网址：</h2>
<h3 id="logseq-graph-graph-name-params"><code>logseq://graph/&lt;graph-name&gt;?&lt;params&gt;</code></h3>
<p>有可选参数 <code>block-id</code> 和 <code>page</code></p>
<p>例子：</p>
<ul>
<li>
<p><code>logseq://graph/&lt;graph name&gt;</code> - 打开图谱</p>
</li>
<li>
<p><code>logseq://graph/&lt;graph name&gt;?page=&lt;page name&gt;</code> - 打开图谱中的页面</p>
</li>
<li>
<p><code>logseq://graph/&lt;graph name&gt;?block-id=&lt;block uuid&gt;</code> - 打开图谱中页面的块</p>
</li>
</ul>
<h3 id="logseq-x-callback-url-quickCapture-params"><code>logseq://x-callback-url/quickCapture?&lt;params&gt;</code></h3>
<p>快速捕获短文本和链接，可以作为现代浏览器的书签，页面<code>&lt;a&gt;</code>标签或从命令行 shell 打开</p>
<p>基本用法：</p>
<ul>
<li>
<p>将以下链接“分享到 Logseq”拖到您的书签栏（<code>cmd+shift+b</code> 在 macOS 上切换书签栏）。然后您就可以为您的 Logseq 应用程序开启“快速捕获”功能，即从浏览器快速捕获当前页面链接、标题和内容到 Logseq，类似书签。</p>
</li>
<li>
<p>[分享到 Logseq](javascript:var%20d=document,w=window,f=‘logseq://x-callback-url/quickCapture’,l=d.location,e=encodeURIComponent,p='?url=%27+e(l.href)+%27&amp;title=%27+e(d.title)+%27&amp;content=%27+e(w.getSelection?w.getSelection().toString():d.getSelection?d.getSelection():d.selection.createRange().text)+%27&amp;x-source=bm%27;a=function(){l.href=f+p};if(/Firefox/.test(navigator.userAgent))setTimeout(a,0);else{a()}void(0))<br>
（或打开 <a href="https://jsfiddle.net/andelf/kvm5Le6z/7/">https://jsfiddle.net/andelf/kvm5Le6z/7/</a> 并将“Share to Logseq”链接拖到书签栏）</p>
</li>
</ul>
<p>参数：</p>
<ul>
<li>
<p><code>url</code>：页面网址</p>
</li>
<li>
<p><code>title</code>：页面标题</p>
</li>
<li>
<p><code>content</code>：（可选）突出显示的文本（选择）</p>
</li>
</ul>
<p>设置（在 <code>config.edn</code> 中）：</p>
<p>模板变量是 <code>&#123;time&#125;</code>、<code>&#123;text&#125;</code> 和 <code>&#123;url&#125;</code></p>
<figure class="highlight edn"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:quick-capture-templates</span> &#123;<span class="symbol">:text</span> <span class="string">&quot;[[quick capture]] **&#123;time&#125;** &#123;text&#125; &#123;url&#125;&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://docs.logseq.com/#/page/Contents">Contents - https://docs.logseq.com/#/page/Contents</a></p>
<p>[2] <a href="https://logseq.com/">Logseq: A privacy-first, open-source knowledge base - https://logseq.com/</a></p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://docs.logseq.com/#/page/Logseq%20Protocol">Logseq Protocol - https://docs.logseq.com/#/page/Logseq%20Protocol</a><br>
Logseq 文档中文翻译 - Logseq 协议</p>
]]></content>
      <categories>
        <category>Awosome Software</category>
        <category>Logseq</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Thinking</tag>
        <tag>Awosome Software</tag>
        <tag>Note Taking</tag>
        <tag>Networked Thinking</tag>
        <tag>Logseq</tag>
        <tag>Logseq 协议</tag>
        <tag>Logseq 文档中文翻译</tag>
        <tag>Docs</tag>
      </tags>
  </entry>
  <entry>
    <title>[中文翻译] Kubernetes 中的时区和 k8tz</title>
    <url>/2022/06/04/Cloud-Native/Kubernetes-K8S/Time-Zone/Timezone-in-Kubernetes-With-k8tz/</url>
    <content><![CDATA[<h1>Kubernetes 中的时区和 k8tz</h1>
<p>Kubernetes 已将自己确立为容器编排的事实标准。 它允许我们在节点集群上执行我们的容器并控制它们周围的所有配置，例如安装存储卷、Secret、网络管理等等。</p>
<p>容器在主机的内核上运行，并从那里获得时钟，但时区不是来自内核，而是来自用户空间。 因此，在大多数情况下，它们默认使用协调世界时 (UTC)。</p>
<p>即使代码与时区无关，即使将容器日志与系统日志相关联之类的事情也会让人头疼。一些应用程序使用机器的时区作为默认时区，并希望用户设置时区。当集群中容器的时区不一致时，问题会变得更大。只是没有标准。幸运的是，有几种方法可以解决这个问题并确定我们正在运行的容器的时区。但在我们找到解决方案之前，让我们先了解一下这个问题。</p>
<span id="more"></span>
<h2 id="如何设定时区">如何设定时区</h2>
<p>在大多数 UNIX 系统中，不同的时区由时区信息格式 (TZif) 定义。它是 1980 年代引入的二进制文件格式。可以在 IANA 时区数据库中找到这些文件的可靠且准确的来源。这些文件通常位于 <code>/usr/share/zoneinfo</code>。在大多数发行版中，这些文件是发行版的一部分并且默认安装。当我们谈论 Docker 基础镜像时，它们中的大多数默认情况下都不包含此包，它们需要使用包管理器手动安装或从源代码编译，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">debian/ubuntu</span></span><br><span class="line">apt-get install tzdata</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">alpine</span></span><br><span class="line">apk add tzdata</span><br></pre></td></tr></table></figure>
<p>一些基础镜像（例如 CentOS 和 Fedora）附带了开箱即用的 <code>tzdata</code> 包。</p>
<p>但是，拥有这些文件是不够的，我们仍然需要在机器（或容器）的级别上定义所需的时区是什么。 <code>/etc/localtime</code> 文件配置本地系统的系统范围内的时区。它通常是指向 <code>/usr/share/zoneinfo</code> 的符号链接，其次是时区数据库名称，例如“Europe/Amsterdam”（即 <code>/usr/share/zoneinfo/Europe/Amsterdam</code>）。您可以在 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List">Wikipedia - https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List</a>上找到可用时区的列表。</p>
<p>指定时区的另一种方法是使用 <code>TZ</code> 环境变量。它可以设置为时区标识符（即 <code>TZ=Europe/Amsterdam</code>），但习惯仅在所需时区与机器时区不同的情况下设置它。设置时，它是在 <code>/etc/localtime</code> 之前。</p>
<h2 id="Docker-Podman-中设置时区">Docker / Podman 中设置时区</h2>
<p>现在，我们了解了时区的来源以及如何设置机器（或容器）的时区，让我们更深入地研究，并尝试证明Docker / Podman 的问题。为此，我们将在一个空的Ubuntu容器中执行命令 <code>date</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -i --<span class="built_in">rm</span> ubuntu:21.04 <span class="built_in">date</span></span></span><br><span class="line">Tue Sep 29 00:00:00 UTC 2021</span><br></pre></td></tr></table></figure>
<p>从输出来看，我们可以看到时区是 <code>UTC</code>。 Ubuntu基本映像不包含 <code>/usr/share/zoneinfo</code> 或 <code>/etc/etc/localtime</code>。默认情况下，正如我们以前所学，需要设置容器时区。 如果我们有选择，我们可以创建将安装 <code>tzdata</code> 软件包并将链接 <code>/etc/localtime</code> 设置到我们所需的时区（<code>Europe/Amsterdam</code>）的链接的 <code>Dockerfile</code>，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">21.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> \</span></span><br><span class="line"><span class="language-bash">    apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y tzdata &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Europe/Amsterdam /etc/localtime &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>
<p>如果我们使用 <code>docker build -t ubuntu:amsterdam</code> 构建新镜像并在其中运行 <code>date</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -i --<span class="built_in">rm</span> ubuntu-amsterdam:0 <span class="built_in">date</span></span></span><br><span class="line">Tue Sep 29 02:00:00 CEST 2021</span><br></pre></td></tr></table></figure>
<p>现在的输出有所不同，时间偏移为 <code>+0200</code>，时区缩写在本例中为 <code>CEST</code>（中欧夏令时）。</p>
<p>但这并不总是需要构建镜像，有几个原因不应该将其视为最佳实践：</p>
<ul>
<li>
<p>并非所有镜像都有包管理器，有些镜像只是从 <code>FROM scratch</code> 开始</p>
</li>
<li>
<p>为我们依赖的任何镜像维护 <code>Dockerfile</code> 将是一项艰巨的任务</p>
</li>
<li>
<p>我们必须将这些新镜像上传到我们的集群可以到达的地方</p>
</li>
<li>
<p>我们可能现在才知道或决定构建时间中的时区应该是什么</p>
</li>
</ul>
<p>我们稍后将讨论更多问题，但让我们首先解决这些问题。</p>
<p>我们可以从主机挂载所需的文件，而不是在构建时安装 <code>tzdata</code> 包，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -v /usr/share/zoneinfo/Europe/Amsterdam:/etc/localtime -i --rm ubuntu:21.04 date</span><br><span class="line">Tue Sep 29 02:00:00 CEST 2021</span><br></pre></td></tr></table></figure>
<p>所以这要容易得多，我们使用 <code>-v</code> 将 TZif 文件从主机直接挂载到容器的 <code>/etc/localtime</code> 并解决了上述所有问题，我们现在几乎可以运行任何具有所需时区的镜像。</p>
<blockquote>
<p>此外，建议挂载整个 <code>/usr/share/zoneinfo</code> 目录，因为应用程序在运行时可能需要有关其他时区的信息，即 <code>-v /usr/share/zoneinfo:/usr/share/zoneinfo:ro</code>。</p>
</blockquote>
<p>所以现在我们知道如何解决这个问题，让我们继续讨论 Kubernetes。 为此，我们将创建一个 <code>date-pod.yaml</code> 文件，在 Ubuntu 镜像上运行命令 <code>date</code>，类似于我们的 <code>docker run</code> 命令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># date-pod.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">date-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">ubuntu:21.04</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ubuntu</span></span><br><span class="line">    <span class="attr">args:</span> [<span class="string">&quot;date&quot;</span>]</span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure>
<p>让我们用 <code>kubectl apply -f date-pod.yaml</code> 执行这个 pod 并用 <code>kubectl logs date-pod</code> 打印日志，我们会看到打印的日期类似于：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Tue Sep 29 00:00:00 UTC 2021</span><br></pre></td></tr></table></figure>
<p>再说一次，时区是 UTC。 为了解决这个问题，我们将使用 <code>hostPath</code> 卷和 <code>volumeMounts</code> 来挂载时区，这类似于 <code>docker run</code> 命令中的 <code>-v</code> 参数。 创建 <code>date-pod-amsterdam.yaml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">date-pod-amsterdam</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">ubuntu:21.04</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ubuntu</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">date</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">zoneinfo</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/localtime</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">Europe/Amsterdam</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">zoneinfo</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/usr/share/zoneinfo</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>kubectl apply -f date-pod-amsterdam.yaml</code> 应用它并使用 <code>kubectl logs date-pod-amsterdam</code> 查看日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Tue Sep 29 02:00:00 CEST 2021</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此外，建议挂载整个 <code>/usr/share/zoneinfo</code> 目录，因为应用程序在运行时可能需要有关其他时区的信息。</p>
</blockquote>
<p>那么，问题解决了吗？ 不完全是…</p>
<ul>
<li>
<p>如果 pod 已经定义了 <code>TZ</code> 环境变量，我们的 <code>/etc/localtime</code> 挂载将被忽略</p>
</li>
<li>
<p>这是非常手动的工作，对于每个 pod，我们需要添加 <code>hostPath</code> 卷并具有 1 或 2 个 <code>volumeMounts</code></p>
</li>
<li>
<p>无法保证集群中的所有节点都安装了 <code>tzdata</code></p>
</li>
<li>
<p>我们并不总是有权使用 <code>hostPath</code> 也没有访问节点的权限</p>
</li>
<li>
<p>如果一些 pod 有时区，而另一些则没有——这只会造成更多混乱</p>
</li>
<li>
<p>大多数 Helm 包不支持通过 <code>values.yaml</code> 添加这些补丁</p>
</li>
</ul>
<p>所以是时候见见 <code>k8tz</code> 了……</p>
<blockquote>
<p>清理创建的资源：<code>kubectl delete pod date-pod date-pod-amsterdam</code></p>
</blockquote>
<h2 id="k8tz-设定时区"><code>k8tz</code> 设定时区</h2>
<p>k8tz 是一个 Kubernetes 准入控制器和一个将时区注入 Pod 的 CLI 工具。 它可以用作手动工具，在本地自动转换我们的 Deployment 和 Pod，也可以作为准入控制器安装，并使用注释来完全自动化任何创建的 Pod 的过程。 但是，不止于此。 为了解决前面提到的所有问题，k8tz 使用了稍微不同的策略。</p>
<p>它不分配 <code>hostPath</code>，而是分配 <code>emptyDir</code> 并注入引导程序 <code>initContainer</code> 以用 TZif 文件填充卷。 然后使用 <code>emptyDir</code> 将 <code>/etc/localtime</code> 和 <code>/usr/share/zoneinfo</code> 挂载到 Pod 中的每个容器。 并且为了确保所需的时区有效，它会将 <code>TZ</code> 环境变量添加到所有容器中。</p>
<p>k8tz准入控制器可以与Helm一起安装，很简单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm repo add k8tz https://k8tz.github.io/k8tz/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm install k8tz k8tz/k8tz --<span class="built_in">set</span> timezone=Europe/Amsterdam</span></span><br></pre></td></tr></table></figure>
<p>现在可以创建 Pod，无需更多配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl run -i -t ubuntu --image=ubuntu:21.04 --restart=OnFailure --<span class="built_in">rm</span>=<span class="literal">true</span> --<span class="built_in">command</span> <span class="built_in">date</span></span></span><br><span class="line">Tue Sep 29 02:00:00 CEST 2021</span><br></pre></td></tr></table></figure>
<p>您还可以使用 <a href="http://k8tz.io/timezone">k8tz.io/timezone</a> 等注解来选择 pod 的时区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl run -i -t ubuntu --image=ubuntu:21.04 --restart=OnFailure --<span class="built_in">rm</span>=<span class="literal">true</span> --<span class="built_in">command</span> <span class="built_in">date</span> --annotations k8tz.io/timezone=Europe/London</span></span><br><span class="line">Tue Sep 29 01:00:00 BST 2021</span><br></pre></td></tr></table></figure>
<p>或者使用 <code>k8tz.io/inject</code> 为 Pod 禁用时区注入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl run -i -t ubuntu --image=ubuntu:21.04 --restart=OnFailure --<span class="built_in">rm</span>=<span class="literal">true</span> --<span class="built_in">command</span> <span class="built_in">date</span> --annotations k8tz.io/inject=<span class="literal">false</span></span></span><br><span class="line">Tue Sep 29 00:00:00 UTC 2021</span><br></pre></td></tr></table></figure>
<p>如果出于某种原因你想使用 <code>hostPath</code> 而不是 <code>initContainer</code>，你可以使用 <code>k8tz.io/strategy</code> 注解：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl run -i -t ubuntu --image=ubuntu:21.04 --restart=OnFailure --<span class="built_in">rm</span>=<span class="literal">true</span> --<span class="built_in">command</span> <span class="built_in">date</span> --annotations k8tz.io/strategy=hostPath</span></span><br><span class="line">Tue Sep 29 02:00:00 CEST 2021</span><br></pre></td></tr></table></figure>
<p>这些注释也可以在命名空间中指定，并影响在命名空间中创建的所有 pod。</p>
<h2 id="结论">结论</h2>
<p>Kubernetes 中的时区问题有多种解决方案，这些解决方案可以手动实现，但在此过程中存在一些挑战和限制。使用 <code>k8tz</code>，您可以自动执行该过程，并且无需额外设置或更改现有资源即可工作，即使节点上没有所需文件也是如此。确保系统中所有组件的时区一致，并且所有组件都可以访问有关不同时区的信息。</p>
<p>k8tz 是免费的开源项目，请查看：<a href="https://github.com/k8tz/k8tz">github.com/k8tz/k8tz</a>。</p>
<blockquote>
<p>免责声明：我是 k8tz 的作者。</p>
</blockquote>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List">List of tz database time zones - Wikipedia - https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List</a></p>
<p>[2] <a href="https://github.com/k8tz/k8tz">k8tz/k8tz: Kubernetes admission controller and a CLI tool to inject timezones into Pods and CronJobs - https://github.com/k8tz/k8tz</a></p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://medium.com/@yonatankahana/timezone-in-kubernetes-with-k8tz-fdefca785238">Timezone in Kubernetes With k8tz. k8tz is a great tool to automate… | by Yonatan Kahana | Medium - https://medium.com/@yonatankahana/timezone-in-kubernetes-with-k8tz-fdefca785238</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>Time Zone</category>
        <category>k8tz</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>tzdate</tag>
        <tag>localtime</tag>
        <tag>zoneinfo</tag>
        <tag>TZ</tag>
        <tag>UTC</tag>
        <tag>Coordinated Universal Time</tag>
        <tag>Coordinated Universal Time (UTC)</tag>
        <tag>TZif</tag>
        <tag>Time Zone Information Format</tag>
        <tag>Time Zone Information Format (TZif)</tag>
        <tag>docker</tag>
        <tag>kubectl</tag>
        <tag>Helm</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Time Zone</tag>
        <tag>k8tz</tag>
      </tags>
  </entry>
  <entry>
    <title>[WebAssembly (Wasm)] Docker + Wasm（测试版）：使用 Docker 和 WasmEdege 运行 WebAssembly (Wasm) 镜像</title>
    <url>/2023/01/14/Cloud-Native/WebAssemble-Wasm/Docker/docker-wasm-beta-running-webassembly-wasm-images-with-docker-and-wasmedege/</url>
    <content><![CDATA[<h1>Docker + Wasm（测试版）：使用 Docker 和 WasmEdege 运行 WebAssembly (Wasm) 镜像</h1>
<p>WebAssembly，通常简称为 Wasm，是一种相对较新的技术，它允许你编译用 40 多种语言（包括 Rust、C、C++、JavaScript 和 Golang）编写的应用程序代码，并在沙盒环境中运行它。</p>
<p>最初的用例主要是在 Web 浏览器中运行本地代码，例如 Figma、AutoCAD 和 Photoshop。</p>
<p>但是由于 WebAssembly 系统接口（WASI）的存在，Wasm 正在迅速向浏览器之外扩展，Vercel、Fastly、Shopify 和 Cloudflare 等公司支持使用 Wasm 在边缘运行代码，而 Fermyon 正在构建一个平台，以在云上运行 Wasm 微服务。</p>
<p>在 KubeCon NA 2022 大会的云原生 Wasm 活动日中，Docker 宣布与 CNCF Wasm 运行时项目 WasmEdge 合作推出 Docker + Wasm 技术预览。只需一个命令 <code>docker run</code> 或 <code>docker compose up</code>，Docker 开发人员就可以立即构建、分享和运行一个完整的 Wasm 应用程序。</p>
<p>Wasm（WebAssembly 的缩写）是您目前在 Docker 中使用的 Linux 和 Windows 容器的一种快速、轻便的替代方案（有 <a href="https://www.docker.com/blog/docker-wasm-technical-preview/">一些折衷</a>）。</p>
<p>此页面提供有关在 Docker 中与 Linux 容器一起运行 Wasm 应用程序的新功能的信息。</p>
<span id="more"></span>
<h2 id="测试版">测试版</h2>
<blockquote>
<p><strong>提醒</strong><br>
Docker + Wasm 功能目前处于 <a href="https://docs.docker.com/release-lifecycle/#beta">Beta</a>阶段。我们建议您不要在生产环境中使用此功能，因为此功能可能会更改或从未来版本中删除。</p>
</blockquote>
<p>首先，我们需要提醒你，由于这是一个技术预览，事情可能会很快发生变化，但这是它目前的工作方式。</p>
<ul>
<li>
<p>我们正在利用我们最近的工作，将镜像管理迁移到 containerd，因为它提供了使用与 OCI 兼容的工件和 containerd shims 的能力。</p>
</li>
<li>
<p>我们与 WasmEdge 合作创建了一个 containerd shim。此 shim 从 OCI 工件中提取 Wasm 模块并使用 WasmEdge 运行时运行它。</p>
</li>
<li>
<p>我们添加了对声明 Wasm 运行时的支持，这将允许使用这个新的 shim。</p>
</li>
</ul>
<p><img src="https://www.docker.com/wp-content/uploads/2022/10/docker-containerd-wasm-diagram.png.webp" alt="docker-containerd-wasm-diagram"></p>
<h2 id="开启-Docker-Wasm-集成">开启 Docker + Wasm 集成</h2>
<p>要使用 Docker + Wasm 集成，开发人员必须打开 <a href="https://docs.docker.com/desktop/containerd/">containerd 镜像存储 - https://docs.docker.com/desktop/containerd/</a>功能。</p>
<blockquote>
<p><strong>重要的</strong><br>
Docker + Wasm 集成需要 <a href="https://docs.docker.com/desktop/containerd/">containerd 镜像存储 - https://docs.docker.com/desktop/containerd/</a>功能。如果您尚未使用 containerd 镜像存储，则将无法访问预先存在的镜像和容器。</p>
</blockquote>
<ul>
<li>
<p>默认情况下，containerd 镜像存储测试版功能处于关闭状态。</p>
</li>
<li>
<p>要开始使用该功能：</p>
<ol>
<li>
<p>导航到 <strong>Preferences</strong>。</p>
</li>
<li>
<p>选择 <strong>Features in development</strong> 功能选项卡。</p>
</li>
<li>
<p>选择 <strong>Beta features</strong> 选项卡。</p>
</li>
<li>
<p>在 <strong>Use containerd for pulling and storing images</strong> 旁边，选中 <strong>复选框</strong>。</p>
</li>
<li>
<p>点击 <strong>Apply &amp; restart</strong> 重启 Docker Desktop。</p>
</li>
</ol>
</li>
</ul>
<p>要关闭此功能，请清除<strong>使用 containerd 提取和存储镜像</strong> 复选框。</p>
<p><img src="https://docs.docker.com/desktop/images/containerd_feature_activation.png" alt="containerd_feature_activation"></p>
<h2 id="使用示例">使用示例</h2>
<h3 id="运行-Wasm-应用程序-docker-run">运行 Wasm 应用程序 <code>docker run</code></h3>
<p>以下 <code>docker run</code> 命令在您的系统上启动一个 Wasm 容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -dp 8080:8080 \</span></span><br><span class="line"><span class="language-bash">	--name=wasm-example \</span></span><br><span class="line"><span class="language-bash">	--runtime=io.containerd.wasmedge.v1 \</span></span><br><span class="line"><span class="language-bash">	--platform=wasi/wasm32 \</span></span><br><span class="line"><span class="language-bash">	michaelirwin244/wasm-example</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>收到错误消息？前往<a href="https://docs.docker.com/desktop/wasm/#troubleshooting">故障排除部分 - https://docs.docker.com/desktop/wasm/#troubleshooting</a> 寻求帮助。</p>
</blockquote>
<p>请注意此命令中使用的<code>--runtime</code>和<code>--platform</code>标志：</p>
<ul>
<li>
<p><code>--runtime=io.containerd.wasmedge.v1</code>：通知 Docker 引擎你想使用 Wasm containerd shim 而不是标准的 Linux 容器运行时</p>
</li>
<li>
<p><code>--platform=wasi/wasm32</code>：指定要使用的镜像的体系结构。通过利用 Wasm 架构，您无需为不同的机器架构构建单独的镜像。Wasm 运行时负责将 Wasm 二进制文件转换为机器指令的最后一步。</p>
</li>
</ul>
<p>该示例应用是一个简单的 Web 服务器，它会显示 Hello world！ 并将数据回显给我们，为了验证它是否正常工作，让我们首先查看日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2022-12-10 14:29:17.851] [info] loading failed: malformed section id, Code: 0x25</span><br><span class="line">[2022-12-10 14:29:17.851] [info]     AOT arch type unmatched.</span><br><span class="line">[2022-12-10 14:29:17.851] [info]     Load AOT section failed. Use interpreter mode instead.</span><br><span class="line">Server is now running</span><br></pre></td></tr></table></figure>
<p>我们可以通过打开 <a href="http://localhost:8080">http://localhost:8080</a> 或使用 <code>curl</code> 来获取 Hello world 消息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl http://localhost:8080</span></span><br><span class="line">Hello world from Rust running with Wasm! Send POST data to /echo to have it echoed back to you</span><br></pre></td></tr></table></figure>
<p>将数据发送到 echo 端点，我们可以使用 <code>curl</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl localhost:8080/echo -d <span class="string">&#x27;&#123;&quot;message&quot;:&quot;Hi there&quot;&#125;&#x27;</span> -H <span class="string">&quot;Content-type: application/json&quot;</span></span></span><br><span class="line">&#123;&quot;message&quot;:&quot;Hi there&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>要删除应用程序，可以像执行任何其他 Docker 服务一样删除它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f wasm-example</span><br></pre></td></tr></table></figure>
<h3 id="使用-Docker-Compose-运行-Wasm-应用程序">使用 Docker Compose 运行 Wasm 应用程序</h3>
<p>可以使用以下 Docker Compose 文件运行相同的应用程序：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">	<span class="attr">app:</span></span><br><span class="line">		<span class="attr">image:</span> <span class="string">michaelirwin244/wasm-example</span></span><br><span class="line">		<span class="attr">platform:</span> <span class="string">wasi/wasm32</span></span><br><span class="line">		<span class="attr">runtime:</span> <span class="string">io.containerd.wasmedge.v1</span></span><br><span class="line">		<span class="attr">ports:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure>
<p>使用普通的 Docker Compose 命令启动应用程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose up</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-Wasm-运行多服务应用程序">使用 Wasm 运行多服务应用程序</h3>
<p>网络的工作方式与您对 Linux 容器的预期相同，使您可以灵活地将 Wasm 应用程序与其他容器化工作负载（例如数据库）组合在单个应用程序堆栈中。</p>
<p>在以下示例中，Wasm 应用程序利用在容器中运行的 MariaDB 数据库。</p>
<ol>
<li>克隆存储库。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/second-state/microservice-rust-mysql.git</span></span><br><span class="line">Cloning into &#x27;microservice-rust-mysql&#x27;...</span><br><span class="line">remote: Enumerating objects: 75, done.</span><br><span class="line">remote: Counting objects: 100% (75/75), done.</span><br><span class="line">remote: Compressing objects: 100% (42/42), done.</span><br><span class="line">remote: Total 75 (delta 29), reused 48 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (75/75), 19.09 KiB | 1.74 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (29/29), done.</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>导航到克隆的项目并使用 Docker Compose 启动项目。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> microservice-rust-mysql</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker compose up</span></span><br><span class="line">[+] Running 0/1</span><br><span class="line">⠿ server Warning                                                                                                  0.4s</span><br><span class="line">[+] Building 4.8s (13/15)</span><br><span class="line">...</span><br><span class="line">microservice-rust-mysql-db-1      | 2022-10-19 19:54:45 0 [Note] mariadbd: ready for connections.</span><br><span class="line">microservice-rust-mysql-db-1      | Version: &#x27;10.9.3-MariaDB-1:10.9.3+maria~ubu2204&#x27;  socket: &#x27;/run/mysqld/mysqld.sock&#x27;  port: 3306  mariadb.org binary distribution</span><br></pre></td></tr></table></figure>
<p>如果您<code>docker image ls</code>从另一个终端窗口运行，您可以在镜像存储中看到 Wasm 镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span></span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">server       latest    2c798ddecfa1   2 minutes ago   3MB</span><br></pre></td></tr></table></figure>
<p>检查镜像显示镜像有一个<code>wasi/wasm32</code>平台，操作系统和架构的组合：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image inspect server | grep -A 3 <span class="string">&quot;Architecture&quot;</span></span></span><br><span class="line">&quot;Architecture&quot;: &quot;wasm32&quot;,</span><br><span class="line">&quot;Os&quot;: &quot;wasi&quot;,</span><br><span class="line">&quot;Size&quot;: 3001146,</span><br><span class="line">&quot;VirtualSize&quot;: 3001146,</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>在浏览器中打开 URL <code>http://localhost:8090</code> 并创建一些示例订单。所有这些都在与 Wasm 服务器进行交互。</p>
</li>
<li>
<p><code>Ctrl+C</code>完成后，通过点击启动应用程序的终端来拆除所有内容。</p>
</li>
</ol>
<h3 id="构建和推送-Wasm-模块">构建和推送 Wasm 模块</h3>
<ol>
<li>
<p>创建一个 Dockerfile 来构建您的 Wasm 应用程序。具体如何执行此操作因您使用的编程语言而异。</p>
</li>
<li>
<p>在您的一个单独阶段中<code>Dockerfile</code>，提取模块并将其设置为<code>ENTRYPOINT</code>.</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># syntax=docker/dockerfile:1</span><br><span class="line"></span><br><span class="line">FROM scratch</span><br><span class="line"></span><br><span class="line">COPY --from=build /build/hello_world.wasm /hello_world.wasm</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ &quot;hello_world.wasm&quot; ]</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>构建并推送指定<code>wasi/wasm32</code>架构的镜像。Buildx 使这很容易在一个命令中完成。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker buildx build --platform wasi/wasm32 -t username/hello-world .</span></span><br><span class="line">...</span><br><span class="line">=&gt; exporting to image                                                                             0.0s</span><br><span class="line">=&gt; =&gt; exporting layers                                                                            0.0s</span><br><span class="line">=&gt; =&gt; exporting manifest sha256:2ca02b5be86607511da8dc688234a5a00ab4d58294ab9f6beaba48ab3ba8de56  0.0s</span><br><span class="line">=&gt; =&gt; exporting config sha256:a45b465c3b6760a1a9fd2eda9112bc7e3169c9722bf9e77cf8c20b37295f954b    0.0s</span><br><span class="line">=&gt; =&gt; naming to docker.io/username/hello-world:latest                                            0.0s</span><br><span class="line">=&gt; =&gt; unpacking to docker.io/username/hello-world:latest                                         0.0s</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker push username/hello-world</span></span><br></pre></td></tr></table></figure>
<h2 id="故障排除">故障排除</h2>
<p>本节包含有关如何解决常见问题的说明。</p>
<h3 id="指定的未知运行时">指定的未知运行时</h3>
<p>如果您在选择使用 containerd 镜像存储之前尝试运行 Wasm 容器，则会显示类似于以下内容的错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker: Error response from daemon: Unknown runtime specified io.containerd.wasmedge.v1.</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.docker.com/desktop/containerd/#enabling-the-containerd-image-store-feature">在 Docker Desktop 设置中打开 containerd 功能 - https://docs.docker.com/desktop/containerd/#enabling-the-containerd-image-store-feature</a> ，然后重试。</p>
<h3 id="无法启动-shim：无法解析运行时路径">无法启动 shim：无法解析运行时路径<a href="https://docs.docker.com/desktop/wasm/#failed-to-start-shim-failed-to-resolve-runtime-path"></a></h3>
<p>如果您使用不支持运行 Wasm 容器的旧版本 Docker Desktop，您将看到类似于以下内容的错误消息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker: Error response from daemon: failed to start shim: failed to resolve runtime path: runtime &quot;io.containerd.wasmedge.v1&quot; binary not installed &quot;containerd-shim-wasmedge-v1&quot;: file does not exist: unknown.</span><br></pre></td></tr></table></figure>
<p>将您的 Docker Desktop 更新到最新版本，然后重试。</p>
<h2 id="已知问题">已知问题</h2>
<h3 id="Docker-Compose-在中断时可能不会干净地退出">Docker Compose 在中断时可能不会干净地退出</h3>
<p>解决方法：通过向进程发送 SIGKILL (<code>killall -9 docker-compose</code>)来清理进程 <code>docker-compose</code>。</p>
<h3 id="server-message-insufficient-scope-authorization-failed即使在使用-Docker-Desktop-登录后，-推送到-Hub-也可能会出现错误-提示"><code>server message: insufficient_scope: authorization failed</code>即使在使用 Docker Desktop 登录后， 推送到 Hub 也可能会出现错误 提示</h3>
<p>解决方法：<code>docker login</code> 在 CLI 中运行</p>
<h2 id="反馈">反馈</h2>
<p>感谢您尝试新的 Docker + Wasm 集成。<a href="https://github.com/docker/roadmap/issues/426">通过公共路线图项目 - https://github.com/docker/roadmap/issues/426</a>上的问题跟踪器提供反馈或报告您可能发现的任何错误。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://docs.docker.com/desktop/wasm/">Docker + Wasm (Beta) | Docker Documentation - https://docs.docker.com/desktop/wasm/</a></p>
<p>[2] <a href="https://www.docker.com/blog/docker-wasm-technical-preview/">Introducing the Docker+Wasm Technical Preview | Docker - https://www.docker.com/blog/docker-wasm-technical-preview/</a></p>
<p>[3] <a href="https://www.docker.com/">Docker: Accelerated, Containerized Application Development - https://www.docker.com/</a></p>
<p>[4] <a href="https://docs.docker.com/compose/">Overview | Docker Documentation - https://docs.docker.com/compose/</a></p>
<p>[5] <a href="https://webassembly.org/">WebAssembly - https://webassembly.org/</a></p>
<p>[6] <a href="https://wasmedge.org/">WasmEdge - https://wasmedge.org/</a></p>
<p>[7] <a href="https://containerd.io/">containerd – An industry-standard container runtime with an emphasis on simplicity, robustness and portability - https://containerd.io/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>WebAssembly (Wasm)</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Cloud Native</tag>
        <tag>Wasm</tag>
        <tag>WebAssembly</tag>
        <tag>WebAssembly (Wasm)</tag>
        <tag>Docker Compose</tag>
        <tag>MariaDB</tag>
        <tag>Docker Desktop</tag>
        <tag>WasmEdege</tag>
      </tags>
  </entry>
  <entry>
    <title>[Infrastructure as Code (IaC)] 为什么 Crossplane 如此令人兴奋</title>
    <url>/2022/04/02/Infrastructure-as-Code-IaC/Crossplane/Blog/Why-Crossplane-Is-so-Exciting/</url>
    <content><![CDATA[<h1>为什么 Crossplane 如此令人兴奋</h1>
<p>发表于 2021 年 7 月 7 日，星期三</p>
<p>作者 | Matthias Luebken</p>
<p>译者 | Blogbin</p>
<p>我刚刚以产品经理的身份加入 Upbound，能成为这一旅程的一部分，我感到无比兴奋。我真的相信 Crossplane 提供了一些独特的功能，可以通过利用云服务使团队更具创新性和生产力。对于 Crossplane 专家来说，这不是新闻。对于刚接触 Crossplane 的人，我希望这篇文章能给您增加一个视角。</p>
<span id="more"></span>
<p>如果您现在构建软件，您可以从海量的云服务中进行选择。仅 AWS 每个月就不断为其 200 多项服务添加新服务，其他云提供商也在跟上。如果您想您的软件开发有竞争力，您需要利用这些服务。设置和管理您的消息队列不会为您的产品增加任何价值。选择一个不是最佳工作工具的平庸数据库会使您的团队变慢。 – 您需要确保您的团队能够利用当前云时代提供的优势！</p>
<p>但是你如何处理这个问题？将云提供商帐户分发给开发人员，并让他们选择他们想要的？虽然这听起来很有趣，但对于几乎所有的软件组织来说都是不现实的，而且由于开发人员会被各种选择淹没，所以这种方案不理想。这一挑战的答案是提供这些服务的一个子集来满足您的特定需求。通常，这是在平台团队中协作完成的，并在开发人员平台中体现出来。</p>
<h2 id="开发者平台应该这样做">开发者平台应该这样做</h2>
<p>“开发人员生产力平台越来越被认为是管理工程团队认知负荷和缩短新功能上市时间的一种方式，”Thoughtworks 说。 Crossplane 专为构建平台而设计，与其他方法相比具有一些优势。以下是我认为特别重要且 Crossplane 做对的四件事：</p>
<h3 id="1-对开发人员友好的-API">1. 对开发人员友好的 API</h3>
<p>首先要做的是 API。平台构建者需要一种方法来设置护栏并提供开发人员可以轻松使用的 API。由于 Crossplane 基于 Kubernetes 构建，因此开发人员创建资源来请求特定服务也就不足为奇了。例如，要配置一个平台团队定义的 20 GB Postgres 实例，开发人员将执行一个简单的 <code>kubectl apply</code> 命令应用以下 <code>yaml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">database.example.org/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PostgreSQLInstance</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-db</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">parameters:</span></span><br><span class="line">    <span class="attr">storageGB:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">compositionSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">provider:</span> <span class="string">aws</span></span><br><span class="line">      <span class="attr">environment:</span> <span class="string">production</span></span><br><span class="line">  <span class="attr">writeConnectionSecretToRef:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">db-conn</span></span><br></pre></td></tr></table></figure>
<p>对于 Kubernetes 开发人员来说，这很简单。这还有一个额外的好处，那就是我们可以无缝融入庞大的 Kubernetes 工具生态系统。尤其是在当前流行的 GitOps 运动中，这使得非 Kubernetes 开发人员也可以使用它。</p>
<h3 id="2：强大而灵活的组合">2：强大而灵活的组合</h3>
<p>此 API 背后的实现可能相当复杂，可能涉及设置正确的云提供商资源，例如权限、网络、VPC 和数据库实例。这让我想到了一个伟大的开发者平台的第二个重要特征：它需要强大并允许灵活的实现。</p>
<p>Crossplane 中的基本构建块是来自云提供商的托管资源。好消息是 Crossplane 包括对 AWS、Azure、GCP 和阿里巴巴的支持，并且社区正在增加对许多其他提供商的支持。</p>
<p>这些基本构建块（绿色的托管资源）作为 Crossplane 组合（黄色的组合资源）拼接在一起，并为提供给开发人员的 API 提供实现。该模型在 Crossplane 资源模型 (XRM) 中形式化，扩展了 Kubernetes 资源模型 (KRM)。可以在专门的博客文章中了解更多信息。这里的关键是平台构建者可以为不同的目的构建不同的组合，而开发者可以专注于它请求的服务的属性。顺便说一句：这些组合也可以与遗留或本地服务一起使用，这对于任何处于某种转型路径的团队来说都是至关重要的。</p>
<h3 id="3：在-K8s-的帮助下生产就绪">3：在 K8s 的帮助下生产就绪</h3>
<p>一个伟大的开发者平台的第三个特点是它需要被视为一种产品。这包括许多方面，但一个重要的方面是它以高度可用的方式运行。好消息是，这是一个已解决的问题：使用 Kubernetes，我们有一种构建和运行分布式应用程序的方法。 Crossplane 建立在此模型之上。它使用 Kubernetes 控制器和持续协调的概念来运行平台。如果有东西坏了（它会坏的），Crossplane 将检查并修复状态。您最喜欢的 Kubernetes 专家现在会说诸如 Operators 和 Control Planes 之类的东西。是的，这正是我们正在做的事情。 – 听起来像是我的博客中的另一篇待办文章来解释这一切。 🙂</p>
<h3 id="4：开源和开放治理">4：开源和开放治理</h3>
<p>最后一个但并非最不重要的特征是平台需要是开源的。 由于开发人员平台将成为您的软件交付的重要组成部分，因此您需要确保您的投资安全。 Crossplane 不仅是开源的（Apache 2.0），而且作为 CNCF 的一部分，它也是公开管理的。</p>
<h2 id="总结">总结</h2>
<p>这些是我目前对 Crossplane 的主要特点，在我看来，这使其成为构建开发者平台的令人兴奋的解决方案。 我渴望更深入地了解社区并了解其他观点。 如果您今天使用 Crossplane 并想聊天，请联系我们！</p>
<hr>
<p>信息公开：这篇文章的先前版本已发布在我的 LinkedIn 个人资料上。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://www.upbound.io/">Why Crossplane Is so Exciting https://www.upbound.io/</a></p>
<p>[2] <a href="https://martinfowler.com/articles/platform-prerequisites.html">Mind the platform execution gap https://martinfowler.com/articles/platform-prerequisites.html</a></p>
<p>[3] <a href="https://github.com/crossplane/provider-aws">Why Crossplane Is so Exciting https://github.com/crossplane/provider-aws</a></p>
<p>[4] <a href="https://github.com/crossplane/provider-azure">crossplane/provider-azure: Crossplane Azure Provider https://github.com/crossplane/provider-azure</a></p>
<p>[5] <a href="https://github.com/crossplane/provider-alibaba">Why Crossplane Is so Exciting https://github.com/crossplane/provider-alibaba</a></p>
<p>[6] <a href="https://github.com/crossplane-contrib/">Crossplane Contrib https://github.com/crossplane-contrib/</a></p>
<p>[7] <a href="https://github.com/crossplane/provider-gcp">crossplane/provider-gcp: Crossplane GCP provider https://github.com/crossplane/provider-gcp</a></p>
<p>[8] <a href="https://github.com/crossplane/crossplane/blob/master/LICENSE">crossplane/LICENSE at master · crossplane/crossplane https://github.com/crossplane/crossplane/blob/master/LICENSE</a></p>
<p>[9] <a href="https://github.com/crossplane/crossplane/blob/master/GOVERNANCE.md">crossplane/GOVERNANCE.md at master · crossplane/crossplane https://github.com/crossplane/crossplane/blob/master/GOVERNANCE.md</a></p>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://blog.crossplane.io/why-crossplane-is-so-exciting/">Why Crossplane Is so Exciting https://blog.crossplane.io/why-crossplane-is-so-exciting/</a></p>
]]></content>
      <categories>
        <category>Infrastructure as Code (IaC)</category>
        <category>Crossplane</category>
      </categories>
      <tags>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Upbound</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>Crossplane</tag>
      </tags>
  </entry>
  <entry>
    <title>[Infrastructure as Code (IaC)] 介绍 Pulumiverse</title>
    <url>/2022/04/02/Infrastructure-as-Code-IaC/Pulumi/Pulumiverse/Introducing-the-Pulumiverse/</url>
    <content><![CDATA[<h1>介绍 Pulumiverse</h1>
<p>发表于 2022 年 3 月 30 日，星期三</p>
<p>作者 | David Flanagan</p>
<p>译者 | Blogbin</p>
<p>今天，我们很高兴地宣布，我们正在与 Pulumi 社区合作，为基于 Pulumi 的库、项目和教育材料提供一个互动和协作的场所：Pulumiverse。</p>
<span id="more"></span>
<p>这个项目对我来说特别重要，因为这是我过去尝试过的一个想法，2018 😯，但未能承诺并给予它应有的关注。</p>
<p>幸运的是，另外两位优秀的 Pulumi 社区成员站出来开始制定他们自己的计划，而我现在在 Pulumi，时机非常巧合。</p>
<p>我与 Pulumiverse 的创始成员 Ringo De Smet 和 Simen A. W. Olsen 进行了交谈。</p>
<p>Napoleon Games 的 CI/CD 负责人 Ringo 谈到了他为什么对创建 Pulumiverse 感到兴奋：</p>
<blockquote>
<p>对于基础设施自动化，我们在 Pulumi 之前有其他很棒的工具：Chef、Puppet、Ansible。这些工具中的任何一个都有一个充满活力的社区，避免我们所有人都需要重新发明轮子。我们在 Chef 有 Sous-Chefs，在 Puppet 有 Vox Pupuli。但我看到很多 Pulumi 用户一遍又一遍地实现相同的东西。这就是为什么我认为 Pulumi 需要它自己的社区。所以我开始了它：Pulumiverse</p>
</blockquote>
<p>Bjerk AS 的开发人员 Simon 分享了：</p>
<blockquote>
<p>我想象一个充满志同道合的人的社区，他们构建和支持 Pulumi Provider、自用的组件、配置，并就我们如何以新的方式利用 Pulumi 的力量分享想法。所以我创建了 Pulumiverse 来分享我的热情，回馈 Pulumi 并通过建立一个我们可以一起工作的平台来支持开发人员！</p>
</blockquote>
<h2 id="什么是-Pulumiverse？">什么是 Pulumiverse？</h2>
<p>Pulumiverse 最简单的形式是一个 GitHub 组织。它为任何人提供了一个社区运营的场所，可以与 Pulumi 社区的其他成员进行交流、贡献和协作，并构建任何人都可以共享和使用的抽象和 SDK。</p>
<p>Pulumi 有许多库或组件集合。其中大部分是根据个别公司和开发人员的要求制作的。 Pulumiverse 旨在打造一个可以创建这些库以及可以存储和讨论 Pulumi 资源的自用的配置的社区。</p>
<h3 id="当前项目">当前项目</h3>
<p>Pulumiverse 仅启动了几个项目，但我们知道，在如此出色的社区的支持下，Pulumiverse 将不断发展壮大，并为任何想要为库或项目构建或使用 Pulumi 的人提供宝贵的资源。</p>
<h3 id="Awesome-Pulumi">Awesome Pulumi</h3>
<p><a href="https://github.com/pulumiverse/awesome-pulumi">🐙 Awesome Pulumi - https://github.com/pulumiverse/awesome-pulumi</a></p>
<p>每个人都喜欢一个 Awesome 的列表，这个列表为您提供了一个很棒的 Pulumi 资源、书籍、教程、讲座等等的列表。</p>
<p>想要列出您的项目吗？请发起一个 PR。我们迫不及待地想把它与大家分享。</p>
<h3 id="Kubernetes-SDKs">Kubernetes SDKs</h3>
<p><a href="https://github.com/pulumiverse/kubernetes-sdks">🐙 Kubernetes SDKs - https://github.com/pulumiverse/kubernetes-sdks</a></p>
<p>Kubernetes SDKs 项目旨在提供用于与 Kubernetes 自定义资源定义 (CRD) 交互的多语言 SDK。目前，它会自动构建 SDK，用于：</p>
<ul>
<li>
<p><a href="https://argoproj.github.io/cd/">ArgoCD - https://argoproj.github.io/cd/</a></p>
</li>
<li>
<p><a href="https://cert-manager.io/">CertManager - https://cert-manager.io/</a></p>
</li>
<li>
<p><a href="https://projectcontour.io/">Contour - https://projectcontour.io/</a></p>
</li>
<li>
<p><a href="https://crossplane.io/">Crossplane - https://crossplane.io/</a></p>
</li>
<li>
<p><a href="https://istio.io/">Istio - https://istio.io/</a></p>
</li>
<li>
<p><a href="https://docs.konghq.com/kubernetes-ingress-controller/">Kong Ingress - https://docs.konghq.com/kubernetes-ingress-controller/</a></p>
</li>
<li>
<p><a href="https://knative.dev/docs/">Knative - https://knative.dev/docs/</a></p>
</li>
<li>
<p><a href="https://redpanda.com/">RedPanda - https://redpanda.com/</a></p>
</li>
<li>
<p><a href="https://tyk.io/">Tyk - https://tyk.io/</a></p>
</li>
</ul>
<h3 id="Pulumi-Concourse-Unifi">Pulumi Concourse &amp; Unifi</h3>
<ul>
<li>
<p><a href="https://github.com/pulumiverse/pulumi-concourse">Concourse Provider - https://github.com/pulumiverse/pulumi-concourse</a></p>
</li>
<li>
<p><a href="https://github.com/pulumiverse/pulumi-unifi">Unifi Provider - https://github.com/pulumiverse/pulumi-unifi</a></p>
</li>
</ul>
<p>这只是一个开始，我们希望快速扩展这个集合。因此，如果您正在使用 Kubernetes 并希望获得丰富的开发人员体验来创作自定义资源，请发起一个 Issue 并让我们知道您的需求。</p>
<p>这些是社区维护的 Provider，是您如何与世界分享您的 Provider 作为 Pulumiverse 的一部分的示例。</p>
<h3 id="您的项目？">您的项目？</h3>
<p>您觉得自己的库对社区有益？</p>
<p>请加入我们在 Pulumi Slack 上的 pulumiverse 频道(<a href="https://pulumi.slack.com/">https://pulumi.slack.com/</a>)，我们很乐意帮助您将它转移到 Pulumiverse。</p>
<p>我们很快会再见！ 👋</p>
<p>#社区</p>
<h2 id="引用链接">引用链接</h2>
<p>[1] <a href="https://github.com/pulumiverse">Pulumiverse - https://github.com/pulumiverse</a></p>
<p>[2] <a href="https://www.pulumi.com/">Pulumi - Modern Infrastructure as Code - https://www.pulumi.com/</a></p>
<p>[3] <a href="https://pulumi.slack.com/">pulumi.slack.com - https://pulumi.slack.com/</a></p>
<p>[4] <a href="https://github.com/pulumiverse/awesome-pulumi">🐙 Awesome Pulumi - https://github.com/pulumiverse/awesome-pulumi</a></p>
<p>[5] <a href="https://github.com/pulumiverse/kubernetes-sdks">🐙 Kubernetes SDKs - https://github.com/pulumiverse/kubernetes-sdks</a></p>
<p>[6] <a href="https://argoproj.github.io/cd/">ArgoCD - https://argoproj.github.io/cd/</a></p>
<p>[7] <a href="https://cert-manager.io/">CertManager - https://cert-manager.io/</a></p>
<p>[8] <a href="https://projectcontour.io/">Contour - https://projectcontour.io/</a></p>
<p>[9] <a href="https://crossplane.io/">Crossplane - https://crossplane.io/</a></p>
<p>[10] <a href="https://istio.io/">Istio - https://istio.io/</a></p>
<p>[11] <a href="https://docs.konghq.com/kubernetes-ingress-controller/">Kong Ingress - https://docs.konghq.com/kubernetes-ingress-controller/</a></p>
<p>[12] <a href="https://knative.dev/docs/">Knative - https://knative.dev/docs/</a></p>
<p>[13] <a href="https://redpanda.com/">RedPanda - https://redpanda.com/</a></p>
<p>[14] <a href="https://tyk.io/">Tyk - https://tyk.io/</a></p>
<p>[15] <a href="https://github.com/pulumiverse/pulumi-concourse">Concourse Provider - https://github.com/pulumiverse/pulumi-concourse</a></p>
<p>[16] <a href="https://github.com/pulumiverse/pulumi-unifi">Unifi Provider - https://github.com/pulumiverse/pulumi-unifi</a></p>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://www.pulumi.com/blog/2022-03-30-introducing-pulumiverse/">Introducing the Pulumiverse | Pulumi Blog - https://www.pulumi.com/blog/2022-03-30-introducing-pulumiverse/</a></p>
]]></content>
      <categories>
        <category>Infrastructure as Code (IaC)</category>
        <category>Pulumi</category>
        <category>Pulumiverse</category>
      </categories>
      <tags>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>Pulumi</tag>
        <tag>Pulumiverse</tag>
      </tags>
  </entry>
  <entry>
    <title>[Rails FAQs] macOS 操作系统更新 Xcode 后导致 `pg` gem 无法正常访问数据库</title>
    <url>/2022/09/17/Programming-Language/Ruby/FAQs/pg-gem-cannot-access-database-properly-after-Xcode-update-on-macOS/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>Ruby 的 <code>pg</code> gem 依赖于操作系统的编译工具和类库。如果操作系统编译工具和类库发生变化（如操作系统升级等），可能会导致 <code>pg</code> gem 无法正常访问数据库的错误。</p>
<span id="more"></span>
<h2 id="问题">问题</h2>
<p>最近升级到 macOS Monterey 12.6 ，因为 Xcode 许可证协议更新，遇到使用 <code>pg</code> gem 的 Rails 项目无法正常运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rails c</span></span><br><span class="line">~/.asdf/installs/ruby/3.0.0/lib/ruby/gems/3.0.0/gems/bootsnap-1.7.5/lib/bootsnap/load_path_cache/core_ext/kernel_require.rb:23:in `require&#x27;: dlopen(~/.asdf/installs/ruby/3.0.0/lib/ruby/gems/3.0.0/gems/pg-1.4.3/lib/pg_ext.bundle, 0x0009): Library not loaded: &#x27;/usr/local/opt/postgresql/lib/libpq.5.dylib&#x27;</span><br><span class="line">  Referenced from: &#x27;~/.asdf/installs/ruby/3.0.0/lib/ruby/gems/3.0.0/gems/pg-1.2.3/lib/pg_ext.bundle&#x27;</span><br><span class="line">  Reason: tried: &#x27;/usr/local/opt/postgresql/lib/libpq.5.dylib&#x27; (no such file), &#x27;/usr/local/lib/libpq.5.dylib&#x27; (no such file), &#x27;/usr/lib/libpq.5.dylib&#x27; (no such file), &#x27;/usr/local/Cellar/postgresql@14/14.5_1/lib/libpq.5.dylib&#x27; (no such file), &#x27;/usr/local/lib/libpq.5.dylib&#x27; (no such file), &#x27;/usr/lib/libpq.5.dylib&#x27; (no such file) - ~/.asdf/installs/ruby/3.0.0/lib/ruby/gems/3.0.0/gems/pg-1.4.3/lib/pg_ext.bundle (LoadError)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>尝试再次安装 <code>pg</code> gem</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gem install pg</span></span><br><span class="line"></span><br><span class="line">Fetching pg-1.4.3.gem</span><br><span class="line">Building native extensions. This could take a while...</span><br><span class="line">ERROR:  Error installing pg:</span><br><span class="line">        ERROR: Failed to build gem native extension.</span><br><span class="line">....</span><br><span class="line">To see why this extension failed to compile, please check the mkmf.log which can be found here:</span><br><span class="line"></span><br><span class="line">  ~/.asdf/installs/ruby/3.0.0/lib/ruby/gems/3.0.0/extensions/x86_64-darwin-20/3.0.0/pg-1.4.3/mkmf.log</span><br><span class="line"></span><br><span class="line">extconf failed, exit code 1</span><br><span class="line"></span><br><span class="line">Gem files will remain installed in ~/.asdf/installs/ruby/3.0.0/lib/ruby/gems/3.0.0/gems/pg-1.4.3 for inspection.</span><br><span class="line">Results logged to ~/.asdf/installs/ruby/3.0.0/lib/ruby/gems/3.0.0/extensions/x86_64-darwin-20/3.0.0/pg-1.4.3/gem_make.out</span><br></pre></td></tr></table></figure>
<p>根据错误提示检查 <code>mkmf.log</code> 日志文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> ~.asdf/installs/ruby/3.0.0/lib/ruby/gems/3.0.0/extensions/x86_64-darwin-20/3.0.0/pg-1.4.3/mkmf.log</span></span><br><span class="line">You have not agreed to the Xcode license agreements, please run &#x27;sudo xcodebuild -license&#x27; from within a Terminal window to review and agree to the Xcode license agreements.</span><br></pre></td></tr></table></figure>
<p>确认是 macOS Monterey 12.6 升级时 Xcode 更新许可证协议导致的问题。</p>
<h2 id="解决">解决</h2>
<p>解决办法有两个：</p>
<ul>
<li>打开 Xcode，点击 同意 许可证协议</li>
<li>或者打开 Terminal 终端，运行 <code>sudo xcodebuild -license</code> 同意许可证协议</li>
</ul>
<p>然后重新安装 <code>pg</code> gem</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gem uninstall pg</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gem install pg</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Or specify pg version</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$ gem install pg -v 1.4.3</span></span><br></pre></td></tr></table></figure>
<p>最后检查 Rails 启动时 <code>pg</code> gem 是否正常工作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rails c</span></span><br><span class="line">irb(main):001:0&gt; </span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://github.com/ged/ruby-pg">ged/ruby-pg: A PostgreSQL client library for Ruby - https://github.com/ged/ruby-pg</a></p>
<p>[2] <a href="https://rubygems.org/gems/pg">pg | RubyGems.org | your community gem host - https://rubygems.org/gems/pg</a></p>
<p>[3] <a href="https://guides.rubyonrails.org/">Ruby on Rails Guides - https://guides.rubyonrails.org/</a></p>
]]></content>
      <categories>
        <category>Programming Language</category>
        <category>Ruby</category>
        <category>Frequently Asked Questions (FAQs)</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>RoR</tag>
        <tag>Ruby on Rails</tag>
        <tag>Ruby on Rails (RoR)</tag>
        <tag>Programming Language</tag>
        <tag>Ruby</tag>
        <tag>Xcode</tag>
        <tag>Rails</tag>
        <tag>pg</tag>
        <tag>gem</tag>
        <tag>PostgreSQL</tag>
        <tag>Monterey 12.6</tag>
        <tag>macOS Monterey 12.6</tag>
        <tag>xcodebuild</tag>
        <tag>Frequently Asked Questions (FAQs)</tag>
      </tags>
  </entry>
  <entry>
    <title>[Rails] Docked Rails - 从 Docker 运行 Rails 以轻松开始开发</title>
    <url>/2022/12/17/Programming-Language/Ruby/Rails/Docked-Rails-Running-Rails-from-Docker-for-easy-start-to-development/</url>
    <content><![CDATA[<p>Rails 在 GitHub 发布一个新仓库 <a href="https://github.com/rails/docked">rails/docked</a>，帮助初学者从 Docker 运行 Rails 以轻松开始开发。</p>
<span id="more"></span>
<h1>Docked Rails</h1>
<p>第一次使用所有必须的依赖来安装 Rails 可能会让初学者望而生畏。Docked Rails 使用 Rails CLI Docker 镜像使其更容易，仅需要安装 Docker。</p>
<h2 id="开始"><a href="https://github.com/rails/docked#getting-started">开始</a></h2>
<p>首先安装 <a href="https://www.docker.com/products/docker-desktop/">Docker</a>（和 Windows 上的 <a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL</a>）。然后复制粘贴以下命令到您的终端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create ruby-bundle-cache</span><br><span class="line"></span><br><span class="line">alias rails=&#x27;docker run --rm -it -v $PWD:/rails -v ruby-bundle-cache:/bundle ghcr.io/rails/cli&#x27;</span><br><span class="line">			  </span><br><span class="line">alias rails-server=&#x27;docker run --rm -it -v $PWD:/rails -v ruby-bundle-cache:/bundle -p 3000:3000 ghcr.io/rails/cli server -b 0.0.0.0&#x27;</span><br><span class="line">			  </span><br><span class="line">alias rails-dev=&#x27;docker run --rm -it -v $PWD:/rails -v ruby-bundle-cache:/bundle -p 3000:3000 --entrypoint bin/dev ghcr.io/rails/cli&#x27;</span><br><span class="line">			  </span><br><span class="line">alias bundle=&#x27;docker run --rm -it -v $PWD:/rails -v ruby-bundle-cache:/bundle --entrypoint bundle ghcr.io/rails/cli&#x27;</span><br><span class="line">			  </span><br><span class="line">alias rake=&#x27;docker run --rm -it -v $PWD:/rails -v ruby-bundle-cache:/bundle --entrypoint rake ghcr.io/rails/cli&#x27;</span><br><span class="line">			  </span><br><span class="line">alias yarn=&#x27;docker run --rm -it -v $PWD:/rails -v ruby-bundle-cache:/bundle --entrypoint yarn ghcr.io/rails/cli&#x27;</span><br></pre></td></tr></table></figure>
<p>然后创建和运行您的 Rails 应用程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rails new weblog</span><br><span class="line"></span><br><span class="line">cd weblog</span><br><span class="line"></span><br><span class="line">rails generate scaffold post title:string body:text</span><br><span class="line"></span><br><span class="line">rails db:migrate</span><br><span class="line"></span><br><span class="line">rails-server</span><br></pre></td></tr></table></figure>
<p>就这样。您正在 <a href="http://localhost:3000/posts">http://localhost:3000/posts</a> 上运行 Rails。</p>
<h2 id="更多">更多</h2>
<p>当然您也可以选择进入 Docker 容器去创建和运行您的 Rails 应用程序。（注意 <code>--entrypoint /bin/bash</code> 参数的位置）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -it --entrypoint /bin/bash -v $PWD:/rails -v ruby-bundle-cache:/bundle ghcr.io/rails/cli</span><br></pre></td></tr></table></figure>
<p>进入容器后运行以下命令：（注意最后最后一条命令中指定 <code>-b 0.0.0.0</code> 参数）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rails new weblog</span><br><span class="line"></span><br><span class="line">cd weblog</span><br><span class="line"></span><br><span class="line">rails generate scaffold post title:string body:text</span><br><span class="line"></span><br><span class="line">rails db:migrate</span><br><span class="line"></span><br><span class="line">rails s -b 0.0.0.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您可能需要知道的是，在虚拟化的 Linux 环境（如 macOS, Windows）中使用 Docker 容器运行应用，可能会比直接运行同样的应用要慢一些。</p>
</blockquote>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://github.com/rails/docked">rails/docked: Running Rails from Docker for easy start to development - https://github.com/rails/docked</a></p>
<p>[2] <a href="https://rubyonrails.org/">Ruby on Rails — A web-app framework that includes everything needed to create database-backed web applications according to the Model-View-Controller (MVC) pattern. - https://rubyonrails.org/</a></p>
<p>[3] <a href="https://github.com/orgs/rails/packages/container/package/cli">Package cli - https://github.com/orgs/rails/packages/container/package/cli</a></p>
<p>[4] <a href="https://docs.docker.com/engine/reference/run/#entrypoint-default-command-to-execute-at-runtime">Docker run reference | Docker Documentation - https://docs.docker.com/engine/reference/run/#entrypoint-default-command-to-execute-at-runtime</a></p>
]]></content>
      <categories>
        <category>Programming Language</category>
        <category>Ruby</category>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>RoR</tag>
        <tag>Ruby on Rails</tag>
        <tag>Ruby on Rails (RoR)</tag>
        <tag>Programming Language</tag>
        <tag>Ruby</tag>
        <tag>Rails</tag>
        <tag>docked</tag>
      </tags>
  </entry>
  <entry>
    <title>[Rails] Rails 基金会以 100 万美元启动</title>
    <url>/2022/11/19/Programming-Language/Ruby/Rails/The-Rails-Foundation-kicks-off-with-one-million-dollars/</url>
    <content><![CDATA[<p>2022 年 11 月 14 日，星期一</p>
<h1>Rails 基金会以 100 万美元启动</h1>
<p>由 Rails 基金会发布</p>
<p>今天，我们很高兴地宣布 Rails 基金会成立。它的使命是改进我们生态系统中的文档、教育、营销和活动，以使所有新的和现有的 Rails 开发人员受益。它由一些与 Rails 相关的最重要的公司发起，并将努力确保一个繁荣的生态系统，该生态系统将继续改进，并且对未来的新来者更具吸引力。</p>
<span id="more"></span>
<h2 id="基金会为何成立？">基金会为何成立？</h2>
<p>自 Ruby on Rails 首次发布以来已经超过 18 年了，从那时起，围绕它出现了一个令人难以置信的生态系统。多年来，成千上万快乐的开发人员使用 Rails 构建了数百万个应用程序。公司使用 Rails 从 HELLO WORLD 一路走到 IPO，一路创造了数十亿美元的价值。这是一次光荣的奔跑，我们仍在继续！</p>
<p>在技术方面，我们也从未像 Rails 7 那样强大。Rails 核心团队与成千上万的贡献者一起，通过一个又一个版本的修复、增强和改进引导我们前进。我们都依赖的代码状况良好且受到精心维护。</p>
<p>但经过这么多年，建立强大的生态系统不仅仅取决于优秀的代码，这一点也变得很明显。对于新的 web 开发人员来说，从来没有比今天更多的选择，如果我们想在未来二十年继续庆祝 Rails 的成功，我们需要尽可能最好地说明为什么有人应该加入我们。</p>
<p>现在，那种情况并没有尽其所能。</p>
<p>其原因主要是文档、教育、营销和事件的问题。对于有兴趣学习 Rails 的开发人员来说，要在几十年经常过时的书籍、博客文章和截屏视频中找到自己的办法，与同时学习的其他人联系，向同事或老板证明 Rails 是正确的，这还不够容易选择，或在专门针对 Rails 的活动中与同行会面。</p>
<p>Rails 基金会的成立就是为了解决所有这些问题以及更多问题。</p>
<h1>谁是基金会的一部分？</h1>
<p>按字母顺序排列，Rails 基金会的八个创始核心成员是：Cookpad、Doximity、Fleetio、GitHub、Intercom、Procore、Shopify 和 37signals。这些公司成员共同慷慨地向基金会提供了 1,000,000 美元的种子资金，以在上述所有改进领域发挥真正的作用。<br>
创始核心成员均在基金会董事会中有代表，董事会由 Ruby on Rails 的创建者 David Heinemeier Hansson 担任主席。<br>
董事会的首要任务是聘请一名全职执行董事，负责这个新的非营利性 501©6 基金会的日常运营，并与自由职业者和贡献者一起完成基金会的使命。</p>
<p>Rails 基金会已获得所有 Ruby on Rails 商标的长期独家许可，并将负责维护和发展 <a href="http://xn--rubyonrails-yd3fa.org">ruby​​onrails.org</a> 网站、社交媒体渠道和所有其他可能有助于推进其使命的渠道.</p>
<p>Rails 核心团队将继续全面负责框架的技术发展、管理代码贡献和管理新版本。</p>
<p>Rails 基金会和 Rails 核心团队将共同努力，确保我们的生态系统保持健康，持续改进，并在未来对新来者更具吸引力。</p>
<h2 id="基金会的下一步是什么？">基金会的下一步是什么？</h2>
<p>从基金会的角度来看，关于如何做到这一点有一百万个想法，现在有一百万美元来实现它。但我们也不会止步于此。Rails 基金会也立即向新的有贡献的公司成员开放，他们可以通过写信给 <a href="mailto:foundation@rubyonrails.org">foundation@rubyonrails.org</a> 申请成为会员，了解更多详情。如果您的公司多年来一直受益于 Rails，但不确定它如何回馈生态系统，那么现在有一个明确而明显的选择。</p>
<p>我们很高兴开始 Ruby on Rails 生态系统的新时代！</p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://rubyonrails.org/2022/11/14/the-rails-foundation">Ruby on Rails — The Rails Foundation kicks off with one million dollars - https://rubyonrails.org/2022/11/14/the-rails-foundation</a></p>
]]></content>
      <categories>
        <category>Programming Language</category>
        <category>Ruby</category>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>RoR</tag>
        <tag>Ruby on Rails</tag>
        <tag>Ruby on Rails (RoR)</tag>
        <tag>Programming Language</tag>
        <tag>Ruby</tag>
        <tag>Rails</tag>
        <tag>Rails Foundation</tag>
      </tags>
  </entry>
  <entry>
    <title>[Rails] 使用 OSV-Scanner 寻找 Rails 应用程序依赖中存在的漏洞</title>
    <url>/2022/12/17/Programming-Language/Ruby/Rails/Using-OSV-Scanner-to-find-existing-vulnerabilities-affecting-your-Rails-application-dependencies/</url>
    <content><![CDATA[<h1>使用 OSV-Scanner 寻找 Rails 应用程序依赖中存在的漏洞</h1>
<p>近日，谷歌发布了开源漏洞扫描器 OSV-Scanner。OSV-Scanner 是为开源的 OSV 数据库提供官方支持的前端工具，用 Go 编写，旨在扫描开源应用程序以评估任何合并依赖项的安全性。</p>
<p>可以使用 OSV-Scanner 寻找 Rails 应用程序依赖中存在的漏洞，包括 Gemfile.lock, package-lock.json, yarn.lock 等文件，.git 目录的最新提交记录，以及基于 Debian 的镜像。</p>
<span id="more"></span>
<h2 id="安装">安装</h2>
<p>有以下几种方式安装 OSV-Scanner</p>
<h3 id="Release">Release</h3>
<p>可以从 <a href="https://github.com/google/osv-scanner/releases">Releases · google/osv-scanner - https://github.com/google/osv-scanner/releases</a> 下载最新发布的二进制版本。</p>
<h3 id="包管理器">包管理器</h3>
<p>或通过包管理器 Windows Scoop，Homwbrew 来安装.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Homwbrew (brew)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew install osv-scanner</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Windows Scoop</span></span><br><span class="line">scoop install osv-scanner</span><br></pre></td></tr></table></figure>
<p>关于 Scoop 的更多信息，请查阅 <a href="https://scoop.sh/">Scoop - https://scoop.sh/</a>。</p>
<p>关于 Homebrew 的更多信息，请查阅 <a href="https://brew.sh/">The Missing Package Manager for macOS (or Linux) — Homebrew - https://brew.sh/</a>。</p>
<h3 id="源代码">源代码</h3>
<p>或者，您可以通过运行从源代码安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go install github.com/google/osv-scanner/cmd/osv-scanner@v1</span></span><br></pre></td></tr></table></figure>
<p>这需要安装 Go 1.18+。</p>
<h2 id="使用">使用</h2>
<p>OSV-Scanner 会收集项目中使用的依赖项和版本列表，然后通过 <a href="https://osv.dev/#use-the-api">OSV.dev API</a> 将此列表与 OSV 数据库进行匹配。您可以将 OSV-Scanner 扫描您的应用目录，输入一个版本依赖锁定文件，扫描基于 Debian 的 Docker 镜像（预览功能），或者扫描 SBOM 软件物料清单文件。</p>
<h3 id="扫描目录">扫描目录</h3>
<p>遍历目录列表以查找：</p>
<ul>
<li>版本依赖锁定文件（如 Gemfile.lock, package-lock.json, yarn.lock 等文件）</li>
<li>SBOM 软件物料清单</li>
<li>.git 目录的最新提交记录</li>
</ul>
<p>可以配置为使用 --recursive / -r 标志递归遍历子目录。</p>
<p>例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">osv-scanner -r .</span></span><br></pre></td></tr></table></figure>
<h3 id="输入一个版本依赖锁定文件">输入一个版本依赖锁定文件</h3>
<p>使用这个 lockfile 包支持范围广泛的 lockfiles。 这是当前支持的锁定文件列表：</p>
<p>例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">osv-scanner --lockfile=Gemfile.lock</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 Gemfile.lock, package-lock.json, yarn.json 等文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">osv-scanner --lockfile=Gemfile.lock -L package-lock.json -L yarn.json</span></span><br></pre></td></tr></table></figure>
<h3 id="扫描基于-Debian-的-docker-镜像（预览功能）">扫描基于 Debian 的 docker 镜像（预览功能）</h3>
<p>该工具将抓取 Debian 映像中已安装软件包的列表并查询它们的漏洞。</p>
<p>目前仅支持基于 Debian 的 Docker 镜像扫描。</p>
<p>需要安装 Docker 并且该工具具有调用它的权限。</p>
<p>目前不扫描 Docker 容器的文件系统，并且有各种其他限制。 请关注<a href="https://github.com/google/osv-scanner/issues/64">此问题 - https://github.com/google/osv-scanner/issues/64</a>以获取有关容器扫描的更新！</p>
<p>例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">osv-scanner --docker image_name:latest</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 <code>image_name</code> 为您基于 Debian 的 Rails 应用镜像。</p>
</blockquote>
<h3 id="输入-SBOM">输入 SBOM</h3>
<p>支持使用包 URL 的 <a href="https://spdx.dev/">SPDX - https://spdx.dev/</a> 和 <a href="https://cyclonedx.org/">CycloneDX SBOM - https://cyclonedx.org/</a>。 格式是根据输入文件内容自动检测的。</p>
<p>例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">osv-scanner --sbom=sbom.json</span></span><br></pre></td></tr></table></figure>
<h2 id="配置">配置</h2>
<p>要配置扫描，请将 <code>osv-scanner.toml</code> 文件放在扫描文件的目录中。 要覆盖此文件，请传递 <code>--config=/path/to/config.toml</code> 参数。</p>
<p>目前，只有 1 个配置选项：</p>
<h3 id="IgnoredVulns">IgnoredVulns</h3>
<p>要忽略漏洞，请在 IgnoreVulns 键下输入 ID。 （可选）添加到期日期或原因。</p>
<p>例子</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[[IgnoredVulns]]</span></span><br><span class="line"><span class="attr">id</span> = <span class="string">&quot;GO-2022-0968&quot;</span></span><br><span class="line"><span class="comment"># ignoreUntil = 2022-11-09 # Optional exception expiry date</span></span><br><span class="line"><span class="attr">reason</span> = <span class="string">&quot;No ssh servers are connected to or hosted in Go lang&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">id</span> = <span class="string">&quot;GO-2022-1059&quot;</span></span><br><span class="line"><span class="comment"># ignoreUntil = 2022-11-09 # Optional exception expiry date</span></span><br><span class="line"><span class="attr">reason</span> = <span class="string">&quot;No external http servers are written in Go lang.&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="JSON-输出">JSON 输出</h2>
<p>默认情况下，osv-scanner 输出一个人类可读的表格。 要让 osv-scanner 输出 JSON，请在调用 osv-scanner 时传递 <code>--json</code> 标志。</p>
<p>当使用 <code>--json</code> 标志时，只有 JSON 输出将被打印到 stdout，所有其他输出都被定向到 stderr。 因此，要仅将 json 输出保存到文件，您可以使用 <code>osv-scanner --json ... &gt; /path/to/file.json</code> 重定向输出。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://github.com/google/osv-scanner">google/osv-scanner: Vulnerability scanner written in Go which uses the data provided by https://osv.dev - https://github.com/google/osv-scanner</a></p>
<p>[2] <a href="https://osv.dev/">OSV - https://osv.dev/</a></p>
<p>[3] <a href="https://bundler.io/guides/using_bundler_in_applications.html#gemfilelock">Bundler: How to manage application dependencies with Bundler - https://bundler.io/guides/using_bundler_in_applications.html#gemfilelock</a></p>
<p>[4] <a href="https://rubyonrails.org/">Ruby on Rails — A web-app framework that includes everything needed to create database-backed web applications according to the Model-View-Controller (MVC) pattern. - https://rubyonrails.org/</a></p>
<p>[5] <a href="https://www.docker.com/">Docker: Accelerated, Containerized Application Development - https://www.docker.com/</a></p>
<p>[6] <a href="https://brew.sh/">The Missing Package Manager for macOS (or Linux) — Homebrew - https://brew.sh/</a></p>
<p>[7] <a href="https://scoop.sh/">Scoop - https://scoop.sh/</a></p>
]]></content>
      <categories>
        <category>Programming Language</category>
        <category>Ruby</category>
        <category>Rails</category>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Google</tag>
        <tag>RoR</tag>
        <tag>Ruby on Rails</tag>
        <tag>Ruby on Rails (RoR)</tag>
        <tag>Programming Language</tag>
        <tag>Ruby</tag>
        <tag>Rails</tag>
        <tag>OSV</tag>
        <tag>osv.dev</tag>
        <tag>OSV-Scanner</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>[Rails] 使用 asdf 将 Rails 升级到最新的 Ruby 3.2.0</title>
    <url>/2023/01/14/Programming-Language/Ruby/Rails/using-asdf-to-upgrade-rails-for-latest-ruby-3-2-0/</url>
    <content><![CDATA[<h1>使用 asdf 将 Rails 升级到最新的 Ruby 3.2.0</h1>
<p>Ruby 3.0.2 已经在2022年12月25日正式发布。主要的改进有生产就绪的 YJIT 和开始对基于 WASI 的 WebAssembly (Wasm) 支持。</p>
<p>其中 YJIT 据说比 3.1 更快，内存开销大约是 3.1 的 1/3，Shopify Ruby 团队已经在生产工作负载上对 YJIT 进行了一年多的测试，证明非常稳定，非常值得在 Rails 项目中使用。</p>
<blockquote>
<p>Ruby 3.0.2 发布说明参见：<br>
英文版：<a href="https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/">Ruby 3.2.0 Released - https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/</a><br>
中文版：<a href="https://mp.weixin.qq.com/s/FhoSsyMz7-iZD7Z1dqLLnw">Ruby 3.2.0 发布 - https://mp.weixin.qq.com/s/FhoSsyMz7-iZD7Z1dqLLnw</a>或<a href="https://cloudolife.cn/2022/12/31/Programming-Language/Ruby/Ruby-3-2-0-Released/">[Ruby] Ruby 3.2.0 发布 | CloudoLife - https://cloudolife.cn/2022/12/31/Programming-Language/Ruby/Ruby-3-2-0-Released/</a></p>
</blockquote>
<p>本文介绍如何将现有的 Rails 项目的 Ruby 版本升级到最新 3.2.0 版本。</p>
<span id="more"></span>
<h2 id="项目背景">项目背景</h2>
<p>现有项目基于 Ruby 3.0.2 和 Rails 6.1。其中 Ruby 版本由 asdf 来安装和管理。首先确认软件版本情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">asdf version</span></span><br><span class="line">v0.11.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ruby -v</span></span><br><span class="line">ruby 3.0.2p107 (2021-07-07 revision 0db68f0233) [x86_64-darwin20]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rails -v</span></span><br><span class="line">Rails 6.1.3.1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong><br>
asdf 是一个编程语言、框架和软件工具（如 Dart, Elixir, Flutter, Golang (Go), Java, Node.js, Python, Ruby 等）统一的版本管理器。<br>
关于 asdf 更多信息，请参考<a href="https://asdf-vm.com/guide/getting-started.html">Getting Started | asdf - https://asdf-vm.com/guide/getting-started.html</a><br>
关于 asdf Ruby 插件，请参考<a href="https://github.com/asdf-vm/asdf-ruby">GitHub - asdf-vm/asdf-ruby: Ruby plugin for asdf version manager - https://github.com/asdf-vm/asdf-ruby</a></p>
</blockquote>
<h2 id="前提条件">前提条件</h2>
<p>在升级之前建议先做好以下准备工作：</p>
<ul>
<li>
<p><strong>评估新版本兼容性</strong>，仔细阅读关于新版本兼容性相关问题，认真评估新版本升级可能对项目代码和数据的影响。</p>
</li>
<li>
<p><strong>准备测试套件</strong>，提前准备好回归测试代码套件和自动化测试环境，用于版本升级后执行自动化测试。</p>
</li>
<li>
<p><strong>备份代码和数据</strong>，为避免升级影响到项目代码和数据，需要升级之前备份好项目代码和数据。万一升级失败，可以回滚代码和数据。</p>
</li>
</ul>
<h2 id="安装-Ruby-3-2-0-版本">安装 Ruby 3.2.0 版本</h2>
<h3 id="使用-asdf-安装-Ruby-3-2-0-版本">使用 asdf 安装 Ruby 3.2.0 版本</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新 asdf 的 Ruby 插件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">asdf plugin update ruby</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 Ruby 3.2.0 版本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">asdf install ruby 3.2.0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查 asdf 安装 Ruby 版本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">asdf list ruby | grep 3.2.0</span></span><br><span class="line">3.2.0</span><br></pre></td></tr></table></figure>
<h3 id="配置-asdf-使用-Ruby-3-2-0-版本">配置 asdf 使用 Ruby 3.2.0 版本</h3>
<p>创建或修改 <code>.tool-versions</code> 文件</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># ~/.tool-versions</span><br><span class="line"></span><br><span class="line"><span class="deletion">- ruby 3.0.2</span></span><br><span class="line"><span class="addition">+ ruby 3.2.0</span></span><br></pre></td></tr></table></figure>
<h3 id="检查-Ruby-版本">检查 Ruby 版本</h3>
<p>现在最新 Ruby 3.2.0 版本已经生效。但没有默认开启 YJIT 特性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ruby -v</span></span><br><span class="line">ruby 3.2.0 (2022-12-25 revision a528908271) [x86_64-darwin22]</span><br></pre></td></tr></table></figure>
<p>通过传递参数 <code>--yjit</code> 启用 YJIT 特性。注意输出版本已经带有 <code>+YJIT</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ruby -v --yjit</span></span><br><span class="line">ruby 3.2.0 (2022-12-25 revision a528908271) +YJIT [x86_64-darwin22]</span><br></pre></td></tr></table></figure>
<p>（推荐）通过环境变量 <code>RUBY_YJIT_ENABLE=1</code> 启用 YJIT 特性，适合启用 Rails 等 Ruby 应用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">RUBY_YJIT_ENABLE=1 ruby -v</span></span><br><span class="line">ruby 3.2.0 (2022-12-25 revision a528908271) +YJIT [x86_64-darwin22]</span><br></pre></td></tr></table></figure>
<h2 id="Rails-项目使用-Ruby-3-2-0-版本">Rails 项目使用 Ruby 3.2.0 版本</h2>
<p>首先修改 <code>Gemfile</code> 文件以使用 Ruby 3.2.0 版本</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># Gemfile</span><br><span class="line"></span><br><span class="line"><span class="deletion">- ruby &#x27;3.0.2&#x27;</span></span><br><span class="line"><span class="addition">+ ruby &#x27;3.2.0&#x27;</span></span><br></pre></td></tr></table></figure>
<p>运行 <code>bundle update</code> 更新 <code>Gemfile.lock</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bundle update</span><br></pre></td></tr></table></figure>
<h2 id="回归测试">回归测试</h2>
<p>记得运行回归测试验证项目功能是否工作正常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rails <span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启 YJIT 的回归测试</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">RUBY_YJIT_ENABLE=1 rails <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<h2 id="运行">运行</h2>
<p>回归测试通过后，启动 Rails 应用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rails s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启 YJIT 的启用</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">RUBY_YJIT_ENABLE=1 rails s</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或通过 puma 启动</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">RUBY_YJIT_ENABLE=1 puma -C config/puma.rb</span></span><br></pre></td></tr></table></figure>
<h2 id="常见问题">常见问题</h2>
<p>升级过程中遇到的主要问题是，因为历史原因 <code>Gemfile</code> 文件未锁定依赖 <code>gem</code> 的版本。执行 <code>bundle update</code> 过程中触发某些 <code>gem</code> 升级到最新版本，与项目原有代码不兼容导致报错。</p>
<blockquote>
<p><strong>最佳实践</strong><br>
强烈建议后续根据 <code>Gemfile</code> 最佳实践锁定各 <code>gem</code> 的具体版本。如 <code>gem 'sidekiq', '6.2.1'</code></p>
</blockquote>
<h3 id="cannot-load-such-file-–-sidekiq-util-LoadError">cannot load such file – sidekiq/util (LoadError</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rails s</span></span><br><span class="line">~/.asdf/installs/ruby/3.2.0/lib/ruby/gems/3.2.0/gems/bootsnap-1.15.0/lib/bootsnap/load_path_cache/core_ext/kernel_require.rb:17:in `require&#x27;: cannot load such file -- sidekiq/util (LoadError</span><br></pre></td></tr></table></figure>
<p>因为 <code>Gemfile</code> 中 <code>sidekiq</code> 未锁定版本，<code>bundle update</code> 导致 <code>sidekiq</code> 意外升级导致的问题。</p>
<p>解决办法：在 <code>Gemfile</code> 中 <code>sidekiq</code> 和 <code>sidekiq-cron</code> 锁定版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gem &#x27;sidekiq&#x27;, &#x27;6.2.1&#x27;</span><br><span class="line"></span><br><span class="line">gem &#x27;sidekiq-cron&#x27;, &#x27;1.2.0&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="Cannot-load-database-configuration-Alias-parsing-was-not-enabled-To-enable-it-pass-aliases-true-to-Psych-load-or-Psych-safe-load-Psych-AliasesNotEnabled">Cannot load database configuration: Alias parsing was not enabled. To enable it, pass <code>aliases: true</code> to <code>Psych::load</code> or <code>Psych::safe_load</code>. (Psych::AliasesNotEnabled)</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rails s</span></span><br><span class="line">~/.asdf/installs/ruby/3.2.0/lib/ruby/3.2.0/psych/visitors/to_ruby.rb:432:in `visit_Psych_Nodes_Alias&#x27;: Cannot load database configuration: Alias parsing was not enabled. To enable it, pass `aliases: true` to `Psych::load` or `Psych::safe_load`. (Psych::AliasesNotEnabled)</span><br></pre></td></tr></table></figure>
<p>因为 <code>Gemfile</code> 中 <code>psych</code> 未锁定版本，<code>bundle update</code> 导致 <code>psych</code> 意外升级导致的问题。</p>
<p>解决办法：在 <code>Gemfile</code> 中 <code>psych</code> 锁定版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gem &#x27;psych&#x27;, &#x27;~&gt; 3.3.4&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提醒</strong><br>
请参考 <a href="https://msp-greg.github.io/puma/#quick-start">File: README — Puma master - https://msp-greg.github.io/puma/#quick-start</a> 了解更多关于 Puma 用法。</p>
</blockquote>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/">Ruby 3.2.0 Released - https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/</a></p>
<p>[2] <a href="https://mp.weixin.qq.com/s/FhoSsyMz7-iZD7Z1dqLLnw">Ruby 3.2.0 发布 - https://mp.weixin.qq.com/s/FhoSsyMz7-iZD7Z1dqLLnw</a></p>
<p>[3] <a href="https://cloudolife.cn/2022/12/31/Programming-Language/Ruby/Ruby-3-2-0-Released/">[Ruby] Ruby 3.2.0 发布 | CloudoLife - https://cloudolife.cn/2022/12/31/Programming-Language/Ruby/Ruby-3-2-0-Released/</a></p>
<p>[4] <a href="https://bundler.io/guides/gemfile.html">Bundler: The best way to manage a Ruby application’s gems - https://bundler.io/guides/gemfile.html</a></p>
<p>[5] <a href="https://asdf-vm.com/">Home | asdf - https://asdf-vm.com/</a></p>
<p>[6] <a href="https://github.com/asdf-vm/asdf-ruby">GitHub - asdf-vm/asdf-ruby: Ruby plugin for asdf version manager - https://github.com/asdf-vm/asdf-ruby</a></p>
<p>[7] <a href="https://shopify.engineering/ruby-yjit-is-production-ready">Ruby 3.2’s YJIT is Production-Ready (2023) - https://shopify.engineering/ruby-yjit-is-production-ready</a></p>
<p>[8] <a href="https://puma.io/">A Fast, Concurrent Web Server for Ruby &amp; Rack - Puma - https://puma.io/</a></p>
]]></content>
      <categories>
        <category>Programming Language</category>
        <category>Ruby</category>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>asdf</tag>
        <tag>RoR</tag>
        <tag>Ruby on Rails</tag>
        <tag>Ruby on Rails (RoR)</tag>
        <tag>Programming Language</tag>
        <tag>Ruby</tag>
        <tag>Shopify Engineering</tag>
        <tag>Shopify</tag>
        <tag>YJIT</tag>
        <tag>Yet Another Ruby JIT</tag>
        <tag>Yet Another Ruby JIT (YJIT)</tag>
        <tag>WASI</tag>
        <tag>Wasm</tag>
        <tag>WebAssembly</tag>
        <tag>WebAssembly (Wasm)</tag>
        <tag>Ruby 3.2.0</tag>
        <tag>Rails</tag>
      </tags>
  </entry>
  <entry>
    <title>[Hexo 插件] hexo-generator-searchdb 插件和 NexT 主题启用 Hexo 本地搜索</title>
    <url>/2022/04/02/Site/Hexo/Plugins/hexo-generator-searchdb-and-NexT-enable-local-search-on-Hexo/</url>
    <content><![CDATA[<h1>hexo-generator-searchdb 插件和 NexT 主题启用 Hexo 本地搜索</h1>
<p>本文章介绍如何使用 Hexo 插件 <code>hexo-generator-searchdb</code> 和 NexT 主题，为 Hexo 生成的网站启用本地搜索功能。</p>
<span id="more"></span>
<h2 id="效果图">效果图</h2>
<p>本地搜索效果图</p>
<p><img src="/images/Site/Hexo/Plugins/hexo-generator-searchdb-Next.png" alt="hexo-generator-searchdb-Next"></p>
<h2 id="前提条件">前提条件</h2>
<ul>
<li>
<p>Hexo 生成的网站</p>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<p>请访问<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo - https://hexo.io/zh-cn/docs/</a>了解更多信息。</p>
</li>
<li>
<p><code>hexo-generator-searchdb</code> 是 Hexo 的本地搜索数据生成器插件。</p>
<p><code>hexo-generator-searchdb</code> 插件用于生成搜索索引文件，其中包含您的文章的所有必要数据，您可以使用这些数据为您的博客编写本地搜索引擎。 支持 XML 和 JSON 格式输出。</p>
<p>请访问<a href="https://theme-next.js.org/docs/third-party-services/search-services.html#Local-Search">Local Search | Search Services | NexT - https://theme-next.js.org/docs/third-party-services/search-services.html#Local-Search</a>了解更多信息。</p>
</li>
<li>
<p>NexT 主题</p>
<p>NexT 是 Hexo 的高品质优雅主题。 它是用爱从头开始制作的主题。同时它内置本地搜索引擎。</p>
<p>请访问<a href="https://theme-next.js.org/docs/getting-started/">Getting Started | NexT - https://theme-next.js.org/docs/getting-started/</a>了解更多信息。</p>
</li>
</ul>
<h2 id="安装">安装</h2>
<p>通过在 Hexo 生成的站点根目录中执行以下命令来安装 <code>hexo-generator-searchdb</code> ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-generator-searchdb</span></span><br></pre></td></tr></table></figure>
<h2 id="配置">配置</h2>
<h3 id="Hexo-配置">Hexo 配置</h3>
<p>您可以在根 <code>_config.yml</code> 中配置此插件。 所有参数都是可选的。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>path</code> - 文件路径。 默认情况下是 <code>search.xml</code>。 如果文件扩展名为 <code>.json</code>，则输出格式为 JSON。 否则将导出 XML 格式文件。</p>
</li>
<li>
<p><code>field</code> - 你要搜索的搜索范围，你可以选择：</p>
<ul>
<li>
<p><code>post</code>（默认）- 将仅涵盖您博客的所有帖子。</p>
</li>
<li>
<p><code>page</code> - 只会覆盖您博客的所有页面。</p>
</li>
<li>
<p><code>al</code>l - 将涵盖您博客的所有帖子和页面。</p>
</li>
</ul>
</li>
<li>
<p><code>content</code> - 是否包含每篇文章的全部内容。 如果为 <code>false</code>，则生成的结果仅包含标题和其他元信息，不包括内容。 默认为 <code>true</code>。</p>
</li>
<li>
<p><code>format</code> - 页面内容的形式，选项有：</p>
<ul>
<li>
<p><code>html</code> (默认) - 被缩小的原始 html 字符串。</p>
</li>
<li>
<p><code>striptags</code> - 原始 <code>html</code> 字符串被删减，并删除所有标签。</p>
</li>
<li>
<p><code>raw</code> - 每个帖子或页面的 <code>Markdown</code> 文本。</p>
</li>
</ul>
</li>
</ul>
<h3 id="NexT-配置">NexT 配置</h3>
<p>编辑 NexT 配置文件以启用本地搜索。</p>
<p>其中 <code>enable</code> 选项为必须，其他选项均为可选。可根据您的需要自定义调整。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 如果是 auto，则输入触发搜索。</span></span><br><span class="line">  <span class="comment"># 如果是 manual，按回车键或搜索按钮触发搜索。</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># 显示每篇文章的前 n 个结果，通过设置为 -1 显示所有结果</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 将 html 字符串转义为可读字符串。</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 在页面加载时预加载搜索数据。</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="部署">部署</h2>
<p>重新生成或运行您的 Hexo 网站。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo clean</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo generate</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Or Start the server.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$ hexo server</span></span><br></pre></td></tr></table></figure>
<p>最后用浏览器访问您的网站，查看本地搜索效果。</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://github.com/next-theme/hexo-generator-searchdb">GitHub - next-theme/hexo-generator-searchdb: 🔍 Seach data generator plugin for Hexo. - https://github.com/next-theme/hexo-generator-searchdb</a></p>
<p>[2] <a href="https://theme-next.js.org/">NexT - Theme for Hexo - https://theme-next.js.org/</a></p>
<p>[3] <a href="https://theme-next.js.org/docs/third-party-services/search-services.html#Local-Search">Local Search | Search Services | NexT - https://theme-next.js.org/docs/third-party-services/search-services.html#Local-Search</a></p>
<p>[4] <a href="https://hexo.io/zh-cn/">Hexo - https://hexo.io/zh-cn/</a></p>
]]></content>
      <categories>
        <category>Site</category>
        <category>Hexo</category>
        <category>Plugins</category>
      </categories>
      <tags>
        <tag>hexo-generator-searchdb</tag>
        <tag>NexT</tag>
        <tag>Markdown</tag>
        <tag>Site</tag>
        <tag>Hexo</tag>
        <tag>Plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 常见问题解答</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/FAQ/</url>
    <content><![CDATA[<h1>常见问题解答</h1>
<p>常见问题解答</p>
<span id="more"></span>
<h2 id="我可以用-minikube-运行较旧的-Kubernetes-版本吗？我必须降级我的-minikube-版本吗？">我可以用 minikube 运行较旧的 Kubernetes 版本吗？我必须降级我的 minikube 版本吗？</h2>
<p>您无需下载旧的 minikube 即可运行较旧的 Kubernetes 版本。您可以使用您想要的任何版本 <code>--kubernetes-version</code> 标志创建一个 Kubernetes 群集。</p>
<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --kubernetes-version=v1.15.0</span><br></pre></td></tr></table></figure>
<h2 id="如何使用-minikube-创建多个集群？">如何使用 minikube 创建多个集群？</h2>
<p>默认情况下，<code>minikube  start</code> 创建了一个名为 <code>minikube</code> 的集群。如果您想创建一个不同的群集或更改其名称，则可以使用 <code>-profile</code>（或者 <code>-P</code>）标志，该​​标志将创建带有指定名称的群集。请注意，同一台计算机上可以有多个群集。</p>
<p>要查看当前群集的列表，请运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube profile list</span><br></pre></td></tr></table></figure>
<p>minikube 配置文件应与自己的设置和驱动程序相互隔离。如果要创建具有多个节点的单个群集，请尝试使用<a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">多节点功能 - https://minikube.sigs.k8s.io/docs/tutorials/multi_node/</a>。</p>
<h2 id="我可以将-minikube-替代-Docker-桌面吗？">我可以将 minikube 替代 Docker 桌面吗？</h2>
<p>是的！遵循我们的教程，<a href="https://minikube.sigs.k8s.io/docs/tutorials/docker_desktop_replacement/">使用 Minikube 替代 Docker 桌面 - https://minikube.sigs.k8s.io/docs/tutorials/docker_desktop_replacement/</a>。</p>
<h2 id="我可以在不运行-Kubernetes-的情况下启动-minikube-吗？">我可以在不运行 Kubernetes 的情况下启动 minikube 吗？</h2>
<p>是的！如果您只想在不启动 Kubernetes 本身的情况下使用 minikube 替代 Docker 桌面，请尝试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --container-runtime=docker --no-kubernetes</span><br></pre></td></tr></table></figure>
<p>另外，如果您想暂时关闭 Kubernetes，则可以暂停，然后再解开 Kubernetes。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube pause</span><br></pre></td></tr></table></figure>
<p>minikube 还具有一个附加组件，会在一定程度的不活动中自动暂停 Kubernetes：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube addons enable auto-pause </span><br></pre></td></tr></table></figure>
<h2 id="Docker-驱动程序：如何设置-minikube-的-cgroup-manager？">Docker 驱动程序：如何设置 minikube 的 cgroup manager？</h2>
<p>默认情况下，minikube 使用 Kubernetes 群集使用 <code>cgroupfs </code> cgroup manager。如果您正在使用 <code>systemd </code> cgroup manager 的系统，这可能会导致冲突。要使用 <code>systemd </code> cgroup manager，请运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --force-systemd=true</span><br></pre></td></tr></table></figure>
<h2 id="如果我有一个带有VM驱动程序的现有群集，我该如何与Docker驱动程序一起运行-minikube？">如果我有一个带有VM驱动程序的现有群集，我该如何与Docker驱动程序一起运行 minikube？</h2>
<p>首先，请确保您的Docker服务正在运行。然后，您都需要：</p>
<p>（a）删除现有群集并创建一个新群集</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube delete</span><br><span class="line">minikube start --driver=docker</span><br></pre></td></tr></table></figure>
<p>或者，（b）创建一个带有不同配置文件名称的第二个集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start -p p1 --driver=docker </span><br></pre></td></tr></table></figure>
<h2 id="minikube支持IPv6吗？">minikube支持IPv6吗？</h2>
<p>Minikube目前不支持IPv6。但是，它在路线图上。您也可以参考开放问题。</p>
<h2 id="如何防止Linux上的密码提示？">如何防止Linux上的密码提示？</h2>
<p>最简单的方法是使用Docker驱动程序，因为后端服务始终以 <code>root</code> 运行。</p>
<p>没有用户可能想尝试 <code>change_minikube_none_user = true</code>，在没有 <code>sudo</code> 的情况下，kubectl等将有效。有关更多详细信息，请参见<a href="https://minikube.sigs.k8s.io/docs/handbook/config/#environment-variables">环境变量 - https://minikube.sigs.k8s.io/docs/handbook/config/#environment-variables</a>。</p>
<p>另外，您可以将 <code>sudo</code> 配置为切勿提示 minikube 发出的命令。</p>
<h2 id="我如何忽略系统验证？">我如何忽略系统验证？</h2>
<p>minikube 的引导程序 kubeadm 在安装Kubernetes之前验证了主机系统上的功能列表。如果您遇到了错误，并且尽管您的系统限制仍然想尝试 minikube，则可以通过使用此额外选项启动 minikube 来跳过验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --extra-config kubeadm.ignore-preflight-errors=SystemVerification</span><br></pre></td></tr></table></figure>
<h2 id="使用-minikube-进行-Knative-设置所需的最低资源分配是什么？">使用 minikube 进行 Knative 设置所需的最低资源分配是什么？</h2>
<p>请使用 minikube 分配足够的资源用于 Knative 设置，尤其是在本地机器上运行 minikube 群集时。我们建议至少分配6个CPU和8G内存：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --cpus 6 --memory 8000</span><br></pre></td></tr></table></figure>
<h2 id="我需要在本地安装kubectl吗？">我需要在本地安装kubectl吗？</h2>
<p>不，minikube 带有内置的kubectl安装。请参阅 <a href="https://minikube.sigs.k8s.io/docs/handbook/kubectl/">minikube 的Kubectl文档 - https://minikube.sigs.k8s.io/docs/handbook/kubectl/</a>。</p>
<h2 id="如何选择进入Beta发布通知？">如何选择进入Beta发布通知？</h2>
<p>只需运行以下命令即可注册到Beta通知：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube config set WantBetaUpdateNotification true</span><br></pre></td></tr></table></figure>
<h2 id="我可以摆脱-minikube-输出中的表情符号吗？">我可以摆脱 minikube 输出中的表情符号吗？</h2>
<p>是的！如果您希望在 minikube 输出😔中没有表情符号，只需将 <code>MINIKUBE_IN_STYLE</code> 环境变量设置为 <code>0</code> 或<code>false</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MINIKUBE_IN_STYLE=0 minikube start</span><br></pre></td></tr></table></figure>
<h2 id="如何从远程网络访问-minikube-群集？">如何从远程网络访问 minikube 群集？</h2>
<p>minikube 的主要目标是快速建立本地的 Kubernetes 群集，因此我们强烈不鼓励使用 minikube 在生产或监听远程流量。根据设计，minikube 的目的是仅在本地网络上监听。</p>
<p>但是，可以配置 minikube 在远程网络上监听。这将使您的网络向外界打开，不建议您使用。如果您不完全了解安全含义，请避免使用此安全性。</p>
<p>对于Docker和Podman驱动程序，请使用 <code>--listen-address</code> 标志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --listen-address=0.0.0.0</span><br></pre></td></tr></table></figure>
<h2 id="如何将最大资源分配给-minikube？">如何将最大资源分配给 minikube？</h2>
<p>在开始命令上设置内存和 CPU 标志将使用最大可用资源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --memory=max --cpus=max</span><br></pre></td></tr></table></figure>
<h2 id="如何在其他硬盘驱动器上运行-minikube？">如何在其他硬盘驱动器上运行 minikube？</h2>
<p>将 <code>MINIKUBE_HOME </code> env设置为要运行 minikube 的驱动器上的路径，然后运行 <code>minikube start</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unix</span></span><br><span class="line">export MINIKUBE_HOME=/otherdrive/.minikube</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Windows</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">env</span>:MINIKUBE_HOME = <span class="string">&quot;D:\.minikube&quot;</span></span></span><br><span class="line"></span><br><span class="line">minikube start</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/faq/">FAQ | minikube - https://minikube.sigs.k8s.io/docs/faq/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>Frequently Asked Questions (FAQs)</tag>
        <tag>FAQs</tag>
        <tag>Frequently Asked Questions</tag>
        <tag>minikube</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 开始 minikube</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Get-Started/</url>
    <content><![CDATA[<h2 id="开始-minikube">开始 minikube</h2>
<p>minikube 是本地 Kubernetes，专注于让 Kubernetes 易于学习和开发。</p>
<p>您只需要 Docker（或类似兼容的）容器或虚拟机环境，只需一个命令 <code>minikube start</code> 即可使用 Kubernetes。</p>
<span id="more"></span>
<h2 id="你需要什么">你需要什么</h2>
<ul>
<li>
<p>2 个 CPU或更多</p>
</li>
<li>
<p>2GB 可用内存</p>
</li>
<li>
<p>20GB 可用磁盘空间</p>
</li>
<li>
<p>连接互联网</p>
</li>
<li>
<p>容器或虚拟机管理器，例如：Docker、Hyperkit、Hyper-V、KVM、Parallels、Podman、VirtualBox 或 VMware Fusion/Workstation。访问<a href="https://minikube.sigs.k8s.io/docs/drivers/">驱动程序 - https://minikube.sigs.k8s.io/docs/drivers/</a>了解更多信息。</p>
</li>
</ul>
<h2 id="1-安装">1 安装</h2>
<h3 id="Linux">Linux</h3>
<p>下载二进制文件在 x86-64 Linux 上安装最新的 minikube 稳定版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64</span><br><span class="line">sudo install minikube-linux-amd64 /usr/local/bin/minikube</span><br></pre></td></tr></table></figure>
<p>或者使用 Debian 包安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb</span><br><span class="line">sudo dpkg -i minikube_latest_amd64.deb</span><br></pre></td></tr></table></figure>
<p>或者使用 RPM 包安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.x86_64.rpm</span><br><span class="line">sudo rpm -Uvh minikube-latest.x86_64.rpm</span><br></pre></td></tr></table></figure>
<h3 id="macOS">macOS</h3>
<p>下载二进制在 x86-64 macOS 上安装最新的 minikube 稳定版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64</span><br><span class="line">sudo install minikube-darwin-amd64 /usr/local/bin/minikube</span><br></pre></td></tr></table></figure>
<p>或者使用 Homebrew 安装</p>
<p>如果安装了 <a href="https://brew.sh/">Homebrew 包管理器 - https://brew.sh/</a>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install minikube</span><br></pre></td></tr></table></figure>
<p>如果通过 brew 安装后运行 <code>which minikube</code> 失败，您可能必须删除旧的 minikube 链接并链接新安装的二进制文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew unlink minikube</span><br><span class="line">brew link minikube</span><br></pre></td></tr></table></figure>
<h3 id="Windows">Windows</h3>
<p>下载 .exe 文件在 x86-64 Windows 上安装最新的 minikube 稳定版本：</p>
<ul>
<li>
<ol>
<li>下载<a href="https://storage.googleapis.com/minikube/releases/latest/minikube-installer.exe">最新版本 - https://storage.googleapis.com/minikube/releases/latest/minikube-installer.exe</a>。<br>
或者，如果使用 PowerShell，请使用以下命令：</li>
</ol>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">New-Item -Path &#x27;c:\&#x27; -Name &#x27;minikube&#x27; -ItemType Directory -Force</span><br><span class="line">Invoke-WebRequest -OutFile &#x27;c:\minikube\minikube.exe&#x27; -Uri &#x27;https://github.com/kubernetes/minikube/releases/latest/download/minikube-windows-amd64.exe&#x27; -UseBasicParsing</span><br></pre></td></tr></table></figure>
<ul>
<li>
<ol start="2">
<li>将二进制文件添加到您的 <code>PATH</code> 中。<br>
确保以管理员身份运行 PowerShell。</li>
</ol>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">oldPath = [Environment]::GetEnvironmentVariable(<span class="string">&#x27;Path&#x27;</span>, [EnvironmentVariableTarget]::Machine)</span></span><br><span class="line">if ($oldPath.Split(&#x27;;&#x27;) -inotcontains &#x27;C:\minikube&#x27;)&#123; `</span><br><span class="line">  [Environment]::SetEnvironmentVariable(&#x27;Path&#x27;, $(&#x27;&#123;0&#125;;C:\minikube&#x27; -f $oldPath), [EnvironmentVariableTarget]::Machine) `</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您使用 CLI 执行安装，则需要先关闭该 CLI 并打开一个新的 CLI，然后再继续。</p>
<p>或者使用 Windows 包管理器：</p>
<p>如果安装了 <a href="https://docs.microsoft.com/en-us/windows/package-manager/">Windows 包管理器 - https://docs.microsoft.com/en-us/windows/package-manager/</a>，请使用以下命令安装 minikube：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">winget install minikube</span><br></pre></td></tr></table></figure>
<p>或者使用 Chocolatey：</p>
<p>如果安装了 <a href="https://chocolatey.org/">Chocolatey 包管理器 - https://chocolatey.org/</a>，请使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">winget install minikube</span><br></pre></td></tr></table></figure>
<p>对于其他平台架构，请参阅<a href="https://github.com/kubernetes/minikube/releases/latest">发布页面 - https://github.com/kubernetes/minikube/releases/latest</a>以了解 minikube 安装方式。</p>
<h2 id="2-启动集群">2 启动集群</h2>
<p>从具有管理员访问权限的终端（但未以 root 身份登录），运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start</span><br></pre></td></tr></table></figure>
<p>如果 minikube 无法启动，请参阅<a href="https://minikube.sigs.k8s.io/docs/drivers/">驱动程序页面 - https://minikube.sigs.k8s.io/docs/drivers/</a>以获取设置兼容容器或虚拟机管理器的帮助。</p>
<h2 id="3-与您的集群交互">3 与您的集群交互</h2>
<p>如果您已经安装了 <code>kubectl</code>，您现在可以使用它来访问您闪亮的新集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get po -A</span><br></pre></td></tr></table></figure>
<p>或者，minikube 可以下载适当版本的 kubectl，您应该可以像这样使用它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube kubectl -- get po -A</span><br></pre></td></tr></table></figure>
<p>您还可以通过将以下内容添加到您的 shell 配置中来使您的生活更轻松：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias kubectl=&quot;minikube kubectl --&quot;</span><br></pre></td></tr></table></figure>
<p>最初，某些服务（例如 <code>storage-provisioner</code>）可能尚未处于运行状态。这是集群启动期间的正常情况，并且会立即自行解决。为了进一步了解您的集群状态，minikube 捆绑了 Kubernetes Dashboard，让您可以轻松适应新环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure>
<h2 id="4-部署应用程序">4 部署应用程序</h2>
<p>创建一个示例部署并在端口 <code>8080</code> 上公开它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create deployment hello-minikube --image=k8s.gcr.io/echoserver:1.4</span><br><span class="line">kubectl expose deployment hello-minikube --type=NodePort --port=8080</span><br></pre></td></tr></table></figure>
<p>这可能需要一点时间，但是当您运行时，您的部署将很快出现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get services hello-minikube</span><br></pre></td></tr></table></figure>
<p>访问此服务的最简单方法是让 minikube 为您启动 Web 浏览器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube service hello-minikube</span><br></pre></td></tr></table></figure>
<p>或者，使用 kubectl 转发端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl port-forward service/hello-minikube 7080:8080</span><br></pre></td></tr></table></figure>
<p>然后！您的应用程序现在在 <a href="http://localhost:7080/">http://localhost:7080/</a> 上可用。</p>
<p>您应该能够在应用程序输出中看到来自 <code>nginx</code> 的请求元数据，例如 <code>CLIENT VALUES</code>、<code>SERVER VALUES</code>、<code>HEADERS RECEIVED</code> 和 <code>BODY</code>。尝试更改请求的路径并观察 <code>CLIENT VALUES</code> 的变化。同样，您可以对其执行 POST 请求并观察输出的 <code>BODY</code> 部分中显示的正文。</p>
<h3 id="负载均衡器部署">负载均衡器部署</h3>
<p>要访问 LoadBalancer 部署，请使用 <code>minikube tunnel</code> 命令。这是一个示例部署：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create deployment balanced --image=k8s.gcr.io/echoserver:1.4  </span><br><span class="line">kubectl expose deployment balanced --type=LoadBalancer --port=8080</span><br></pre></td></tr></table></figure>
<p>在另一个窗口中，启动隧道以为“平衡”部署创建可路由 IP：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minikube tunnel</span><br></pre></td></tr></table></figure>
<p>要查找可路由 IP，请运行此命令并检查 <code>EXTERNAL-IP</code> 列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get services balanced</span><br></pre></td></tr></table></figure>
<p>您的部署现在在 <EXTERNAL-IP>:8080 可用</p>
<h2 id="5-管理您的集群">5 管理您的集群</h2>
<p>在不影响已部署应用程序的情况下暂停 Kubernetes：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube pause</span><br></pre></td></tr></table></figure>
<p>取消暂停暂停的实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube unpause</span><br></pre></td></tr></table></figure>
<p>停止集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube stop</span><br></pre></td></tr></table></figure>
<p>增加默认内存限制（需要重新启动）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube config set memory 16384</span><br></pre></td></tr></table></figure>
<p>浏览易于安装的 Kubernetes 服务目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube addons list</span><br></pre></td></tr></table></figure>
<p>创建第二个运行旧 Kubernetes 版本的集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start -p aged --kubernetes-version=v1.16.1</span><br></pre></td></tr></table></figure>
<p>删除所有 minikube 集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube delete --all</span><br></pre></td></tr></table></figure>
<h2 id="进行下一步">进行下一步</h2>
<ul>
<li>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/">minikube 手册 - https://minikube.sigs.k8s.io/docs/handbook/</a></p>
</li>
<li>
<p><a href="https://minikube.sigs.k8s.io/docs/tutorials/">社区贡献的教程 - https://minikube.sigs.k8s.io/docs/tutorials/</a></p>
</li>
<li>
<p><a href="https://minikube.sigs.k8s.io/docs/commands/">minikube 命令参考 - https://minikube.sigs.k8s.io/docs/commands/</a></p>
</li>
<li>
<p><a href="https://minikube.sigs.k8s.io/docs/contrib/">贡献者指南 - https://minikube.sigs.k8s.io/docs/contrib/</a></p>
</li>
<li>
<p>参加我们的<a href="https://forms.gle/Gg3hG5ZySw8c1C24A">快速 5 题调查 - https://forms.gle/Gg3hG5ZySw8c1C24A</a>，分享您的想法🙏</p>
</li>
</ul>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/start/">minikube start | minikube - https://minikube.sigs.k8s.io/docs/start/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>brew</tag>
        <tag>Homebrew</tag>
        <tag>Linux</tag>
        <tag>macOS</tag>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Get Started</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 访问应用程序</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Accessing-apps/</url>
    <content><![CDATA[<h1>手册 - 访问应用程序</h1>
<p>如何访问在 minikube 中运行的应用程序</p>
<p>Kubernetes 中有两大类服务：</p>
<ul>
<li>
<p>NodePort 节点端口</p>
</li>
<li>
<p>LoadBalancer 负载均衡器</p>
</li>
</ul>
<p>minikube 两者都支持。继续阅读！</p>
<span id="more"></span>
<h2 id="NodePort-节点端口访问">NodePort 节点端口访问</h2>
<p>NodePort 服务是将外部流量直接传输到您的服务的最基本方式。 NodePort，顾名思义，打开一个特定的端口，任何发送到这个端口的流量都会被转发给服务。</p>
<h3 id="使用-service-命令获取-NodePort">使用 service 命令获取 NodePort</h3>
<p>我们还有一个获取 minikube IP 和服务的 NodePort 的快捷方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube service --url &lt;service-name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用-kubectl-获取-NodePort">使用 kubectl 获取 NodePort</h3>
<p>minikube VM 通过主机专用 IP 地址暴露给主机系统，可以使用 <code>minikube ip</code> 命令获取。 NodePort 类型的任何服务都可以在 NodePort 上通过该 IP 地址访问。</p>
<p>要确定您的服务的 NodePort，您可以使用这样的 kubectl 命令（注意 nodePort 在 JSON 输出中以小写 n 开头）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get service &lt;service-name&gt; --output=&#x27;jsonpath=&quot;&#123;.spec.ports[0].nodePort&#125;&quot;&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="增加-NodePort-范围">增加 NodePort 范围</h4>
<p>默认情况下，minikube 只公开端口 30000-32767。如果这对您不起作用，您可以使用以下方法调整范围：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --extra-config=apiserver.service-node-port-range=1-65535</span><br></pre></td></tr></table></figure>
<p>此标志还接受以逗号,分隔的端口和端口范围列表。</p>
<h2 id="LoadBalancer-负载均衡器访问">LoadBalancer 负载均衡器访问</h2>
<p>LoadBalancer 服务是向 Internet 公开服务的标准方式。使用这种方法，每个服务都会获得自己的 IP 地址。</p>
<h2 id="使用-minikube-隧道">使用 minikube 隧道</h2>
<p>LoadBalancer 类型的服务可以通过 <code>minikube tunnel</code> 命令公开。它必须在单独的终端窗口中运行以保持 LoadBalancer 运行。终端中的 <code>Ctrl-C</code> 可用于终止清理网络路由的进程。</p>
<h3 id="例子">例子</h3>
<p>在单独的终端中运行 <code>minikube tunnel</code></p>
<p>它会要求输入密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube tunnel</span><br></pre></td></tr></table></figure>
<p><code>minikube tunnel</code> 作为一个进程运行，使用集群的 IP 地址作为网关，在主机上创建到集群的服务 CIDR 的网络路由。隧道命令将外部 IP 直接暴露给在主机操作系统上运行的任何程序。</p>
<p>隧道输出示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Password:</span><br><span class="line">Status:</span><br><span class="line">machine: minikube</span><br><span class="line">pid: 39087</span><br><span class="line">route: 10.96.0.0/12 -&gt; 192.168.64.194</span><br><span class="line">minikube: Running</span><br><span class="line">services: [hello-minikube]</span><br><span class="line">  errors:</span><br><span class="line">minikube: no errors</span><br><span class="line">router: no errors</span><br><span class="line">loadbalancer emulator: no errors</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="创建-Kubernetes-部署">创建 Kubernetes 部署</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create deployment hello-minikube1 --image=k8s.gcr.io/echoserver:1.4</span><br></pre></td></tr></table></figure>
<h3 id="创建一个-kubernetes-服务类型-LoadBalancer">创建一个 kubernetes 服务类型 LoadBalancer</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment hello-minikube1 --type=LoadBalancer --port=8080</span><br></pre></td></tr></table></figure>
<p>检查外部 IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get svc</span></span><br><span class="line">NAME              TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)          AGE</span><br><span class="line">hello-minikube1   LoadBalancer   10.96.184.178   10.96.184.178   8080:30791/TCP   40s</span><br></pre></td></tr></table></figure>
<p>请注意，如果没有 minikube 隧道，kubernetes 会将外部 IP 显示为“待处理”。</p>
<h3 id="在浏览器中尝试">在浏览器中尝试</h3>
<p>在浏览器中打开（确保没有设置代理）</p>
<p><code>http://REPLACE_WITH_EXTERNAL_IP:8080</code></p>
<p>每个服务都将获得自己的外部 ip。</p>
<h3 id="DNS-解析（实验性）">DNS 解析（实验性）</h3>
<p>如果您在 macOS 上，则隧道命令还允许从主机对 Kubernetes 服务进行 DNS 解析。</p>
<p>注意：docker 驱动不支持 DNS 解析</p>
<h3 id="清理孤立路由">清理孤立路由</h3>
<p>如果 <code>minikube tunnel</code> 突然关闭，它可能会在您的系统上留下孤立的网络路由。如果发生这种情况，<code>~/.minikube/tunnels.json</code> 文件将包含该隧道的条目。要删除孤立路由，请运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube tunnel --cleanup</span><br></pre></td></tr></table></figure>
<p>注意： <code>--cleanup</code> 标志的默认值为 <code>true</code>。</p>
<h3 id="避免密码提示">避免密码提示</h3>
<p>添加路由需要用户具有 root 权限，因此如何运行 <code>minikube tunnel</code> 会因操作系统而异。如果您想避免输入 root 密码，请考虑为“ip”和“route”命令设置 NOPASSWD：<br>
<a href="https://superuser.com/questions/1328452/sudoers-nopasswd-for-single-executable-but-allowing-others">linux - Sudoers NOPASSWD for single executable but allowing others - Super User - https://superuser.com/questions/1328452/sudoers-nopasswd-for-single-executable-but-allowing-others</a></p>
<h3 id="在-Windows-上访问-1024-端口需要-root-权限">在 Windows 上访问 &lt;1024 端口需要 root 权限</h3>
<p>如果您在 Windows 上使用 Docker 驱动程序，则您有可能拥有旧版本的 SSH 客户端，您可能会收到类似的错误 - 特权端口只能由 root 转发。或者如果访问端口小于 1024，即使在 minikube 隧道之后，您也可能无法访问该服务，但对于大于 1024 的端口可以正常工作。</p>
<p>为了解决这个问题，请确保您运行的是最新版本的 SSH 客户端。您可以通过在具有管理员权限的命令提示符中运行以下命令在 Windows 上安装最新版本的 SSH 客户端（需要巧克力包管理器）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">choco install openssh</span><br></pre></td></tr></table></figure>
<p>默认情况下在 Windows 10 上可用的最新版本（OpenSSH_for_Windows_7.7p1，LibreSSL 2.6.5）不起作用。您可以在此处跟踪此问题 - <a href="https://github.com/PowerShell/Win32-OpenSSH/issues/1693">https://github.com/PowerShell/Win32-OpenSSH/issues/1693 - https://github.com/PowerShell/Win32-OpenSSH/issues/1693</a></p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/accessing/">Accessing apps | minikube - https://minikube.sigs.k8s.io/docs/handbook/accessing/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>App</tag>
        <tag>Deployment</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 附加组件</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Addons/</url>
    <content><![CDATA[<h1>手册 - 附加组件</h1>
<p>有关维护的 minikube 附加组件的详细信息</p>
<p>附加组件是 minikube 的维护扩展，用于为 Kubernetes 添加功能。</p>
<span id="more"></span>
<p><a href="">使用 Kong Ingress 控制器附加组件</a></p>
<p><a href="">入口 DNS</a></p>
<p><a href="">自动 Google Cloud Platform 身份验证</a></p>
<p><a href="">将附加组件配置为使用自定义 Registry 和镜像</a></p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/addons/">Addons | minikube https://minikube.sigs.k8s.io/docs/handbook/addons/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Deployment</tag>
        <tag>Service</tag>
        <tag>Addons</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 基本控制</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Baisc-Controls/</url>
    <content><![CDATA[<h1>手册 - 基本控制</h1>
<p>查看 minikube 实战！</p>
<p>运行以下命令启动集群：（如无特别说明，集群默认为 minikube）</p>
<span id="more"></span>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start</span><br></pre></td></tr></table></figure>
<p>访问在 minikube 集群中运行的 Kubernetes 仪表板：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure>
<p>启动后，您可以使用 <code>kubectl</code> 与您的集群进行交互，就像任何其他 Kubernetes 集群一样。 例如，启动服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create deployment hello-minikube --image=k8s.gcr.io/echoserver:1.4</span><br></pre></td></tr></table></figure>
<p>将服务公开为 NodePort</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment hello-minikube --type=NodePort --port=8080</span><br></pre></td></tr></table></figure>
<p>minikube 可以很容易地在浏览器中打开这个暴露的端点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube service hello-minikube</span><br></pre></td></tr></table></figure>
<p>升级您的集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --kubernetes-version=latest</span><br></pre></td></tr></table></figure>
<p>启动第二个本地集群（注意：如果 minikube 使用裸机/无驱动程序，这命令将不起作用）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start -p cluster2</span><br></pre></td></tr></table></figure>
<p>停止本地集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止第二个本地集群</span></span><br><span class="line">minikube stop -p cluster2</span><br></pre></td></tr></table></figure>
<p>删除本地集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube delete</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除第二个本地集群</span></span><br><span class="line">minikube delete -p cluster2</span><br></pre></td></tr></table></figure>
<p>删除所有本地集群和配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube delete --all</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/controls/">Basic controls | minikube https://minikube.sigs.k8s.io/docs/handbook/controls/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Deployment</tag>
        <tag>Service</tag>
        <tag>Basic controls</tag>
        <tag>Profile</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 证书</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Certificate/</url>
    <content><![CDATA[<h2 id="手册-证书">手册 - 证书</h2>
<p>关于 TLS 证书</p>
<span id="more"></span>
<h2 id="不受信任的根证书">不受信任的根证书</h2>
<p>许多组织在公司网络中部署自己的根证书和 CA 服务。 出于安全和隐私方面的考虑，内部网站、镜像存储库和其他资源可能会安装由该 CA 服务颁发的 SSL 服务器证书。<br>
您可以将根证书安装到 minikube 集群中，以访问集群内的这些企业资源。</p>
<h2 id="教程">教程</h2>
<p>您将需要 PEM 格式的公司 X.509 根证书。 如果是 DER 格式，请转换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform der -in my_company.cer -out my_company.pem</span><br></pre></td></tr></table></figure>
<p>将证书复制到 certs 目录中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.minikube/certs</span><br><span class="line">cp my_company.pem $HOME/.minikube/certs/my_company.pem</span><br></pre></td></tr></table></figure>
<p>然后使用 <code>--embed-certs</code> 标志重新启动 minikube 以同步证书：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --embed-certs</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/untrusted_certs/">Certificates | minikube - https://minikube.sigs.k8s.io/docs/handbook/untrusted_certs/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Deployment</tag>
        <tag>Service</tag>
        <tag>Certificate</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 配置</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Config/</url>
    <content><![CDATA[<h1>手册 - 配置</h1>
<p>配置集群</p>
<span id="more"></span>
<h2 id="基本配置">基本配置</h2>
<p>大多数 minikube 配置是通过标志接口完成的。要查看 <code>start</code> 命令可以使用哪些标志，请运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --help</span><br></pre></td></tr></table></figure>
<h2 id="持久配置">持久配置</h2>
<p>minikube 允许用户使用 <code>minikube config</code> 命令持久存储要使用的新默认值在所有配置文件中。这是通过提供属性名称和属性值来完成的。</p>
<p>例如，要持久配置 minikube 以使用 hyperkit：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube config set driver hyperkit</span><br></pre></td></tr></table></figure>
<p>您可以使用以下方法获取可配置字段的完整列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube config --help</span><br></pre></td></tr></table></figure>
<p>要获取当前设置的配置属性的列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube config view</span><br></pre></td></tr></table></figure>
<h2 id="Kubernetes-配置">Kubernetes 配置</h2>
<p>minikube 允许用户使用任意值配置 Kubernetes 组件。要使用此功能，您可以在 <code>minikube start</code> 命令上使用 <code>--extra-config</code> 标志。</p>
<p>这个标志是可重复的，所以你可以用几个不同的值多次传递它来设置多个选项。</p>
<h3 id="选择-Kubernetes-版本">选择 Kubernetes 版本</h3>
<p>默认情况下，minikube 安装在 minikube 发布时可用的最新稳定版本的 Kubernetes。您可以使用 <code>--kubernetes-version</code> 标志选择不同的 Kubernetes 版本，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --kubernetes-version=v1.11.10</span><br></pre></td></tr></table></figure>
<p>minikube 遵循 <a href="https://kubernetes.io/docs/setup/version-skew-policy/">Kubernetes 版本和版本倾斜支持政策 - https://kubernetes.io/docs/setup/version-skew-policy/</a>，因此我们保证支持最近 3 个 Kubernetes 次要版本的最新版本。在实际可行的情况下，minikube 还旨在支持旧版本，以便用户可以模拟旧环境。<br>
有关受支持版本的最新信息，请参阅 <a href="https://github.com/kubernetes/minikube/blob/master/pkg/minikube/constants/constants.go">constants.go - https://github.com/kubernetes/minikube/blob/master/pkg/minikube/constants/constants.go</a> 中的 <code>OldestKubernetesVersion</code> 和 <code>NewestKubernetesVersion</code>。</p>
<h3 id="启用功能开关">启用功能开关</h3>
<p>Kubernetes alpha/experimental features 可以通过 <code>minikube start</code> 命令上的 <code>--feature-gates</code> 标志启用或禁用。它采用 <code>key=value</code> 形式的字符串，其中 <code>key</code> 是组件名称，<code>value</code> 是它的状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --feature-gates=EphemeralContainers=true</span><br></pre></td></tr></table></figure>
<h3 id="修改-Kubernetes-默认值">修改 Kubernetes 默认值</h3>
<p>kubeadm 引导程序可以通过 <code>minikube start</code> 命令上的 <code>--extra-config</code> 标志进行配置。它采用 <code>component.key=value</code> 形式的字符串，其中 <code>component</code> 是字符串之一</p>
<ul>
<li>
<p>kubeadm</p>
</li>
<li>
<p>kubelet</p>
</li>
<li>
<p>apiserver</p>
</li>
<li>
<p>controller-manager</p>
</li>
<li>
<p>scheduler</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --extra-config=apiserver.v=10 --extra-config=kubelet.max-pods=100</span><br></pre></td></tr></table></figure>
<p>例如，要允许 Kubernetes 在不受支持的 Docker 版本上启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --extra-config=kubeadm.ignore-preflight-errors=SystemVerification</span><br></pre></td></tr></table></figure>
<h2 id="运行时配置">运行时配置</h2>
<p>minikube 中的默认容器运行时各不相同。您可以使用以下命令显式选择一个：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --container-runtime=docker</span><br></pre></td></tr></table></figure>
<p>其他可用选项包括：</p>
<ul>
<li>
<p><a href="https://github.com/containerd/containerd">containerd - https://github.com/containerd/containerd</a></p>
</li>
<li>
<p><a href="https://github.com/cri-o/cri-o">cri-o - https://github.com/cri-o/cri-o</a></p>
</li>
</ul>
<p>查看 <a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/">Container Runtimes | Kubernetes - https://kubernetes.io/docs/setup/production-environment/container-runtimes/</a></p>
<h2 id="环境变量">环境变量</h2>
<p>minikube 支持为 minikube 配置中列出的每个值传递环境变量，而不是使用标志。这是通过传递带有前缀 <code>MINIKUBE_</code> 的环境变量来完成的。</p>
<p>例如 <code>minikube start --iso-url=&quot;$ISO_URL&quot; </code> 标志也可以通过设置 <code>MINIKUBE_ISO_URL=&quot;$ISO_URL&quot;</code> 环境变量来设置。</p>
<h3 id="独有的环境变量调优">独有的环境变量调优</h3>
<p>有些功能只能通过 minikube 特定的环境变量访问，这里是这些功能的列表：</p>
<ul>
<li>
<p>MINIKUBE_HOMEMINIKUBE_HOME - （字符串）设置 minikube 用于状态/配置的 <code>.minikube</code> 目录的路径。请注意：这仅由 minikube 使用，不会影响与 kubectl 等 Kubernetes 工具相关的任何内容。</p>
</li>
<li>
<p>MINIKUBE_IN_STYLE - (bool) 手动设置表情符号和颜色是否应该出现在 minikube 中。设置为 <code>false</code> 或 <code>0</code> 以禁用此功能，设置为 <code>true</code> 或 <code>1</code> 以强制将其打开。<br>
CHANGE_MINIKUBE_NONE_USER - (bool) 自动将 ~/.minikube 的所有权更改为 <code>$SUDO_USER</code> 的值</p>
</li>
<li>
<p>MINIKUBE_ENABLE_PROFILING - (int, 1 启用它) 启用为 minikube 生成跟踪分析</p>
</li>
<li>
<p>MINIKUBE_SUPPRESS_DOCKER_PERFORMANCE - (bool) 在 Docker 运行缓慢时抑制 Docker 性能警告</p>
</li>
</ul>
<p>示例：禁用表情符号</p>
<h3 id="Linux">Linux</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export MINIKUBE_IN_STYLE=false</span><br><span class="line"></span><br><span class="line">minikube start</span><br></pre></td></tr></table></figure>
<h3 id="macOS">macOS</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export MINIKUBE_IN_STYLE=false</span><br><span class="line"></span><br><span class="line">minikube start</span><br></pre></td></tr></table></figure>
<h3 id="Windows">Windows</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">env</span>:MINIKUBE_IN_STYLE=<span class="literal">false</span></span></span><br><span class="line"></span><br><span class="line">minikube start</span><br></pre></td></tr></table></figure>
<h3 id="持久化环境变量值">持久化环境变量值</h3>
<p>要使环境变量在重新启动后保持不变：</p>
<ul>
<li>
<p>Linux 和 macOS：将这些声明添加到 <code>~/.bashrc</code> 或存储 shell 环境变量的任何位置。</p>
</li>
<li>
<p>Windows：将这些声明添加到您的 <code>~\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</code> 或在 PowerShell 终端中运行以下命令：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Environment]::SetEnvironmentVariable(&quot;key&quot;, &quot;value&quot;, [EnvironmentVariableTarget]::User)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/config/">Configuration | minikube - https://minikube.sigs.k8s.io/docs/handbook/config/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Deployment</tag>
        <tag>Service</tag>
        <tag>Config</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 部署应用程序</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Deploying-apps/</url>
    <content><![CDATA[<h1>手册 - 部署应用程序</h1>
<p>如何将应用程序部署到 minikube</p>
<span id="more"></span>
<h2 id="kubectl">kubectl</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create deployment hello-minikube1 --image=k8s.gcr.io/echoserver:1.4</span><br><span class="line">kubectl expose deployment hello-minikube1 --type=LoadBalancer --port=8080</span><br></pre></td></tr></table></figure>
<h2 id="附加组件">附加组件</h2>
<p>minikube 有一个内置的应用程序和服务列表，可以轻松部署，例如 Istio 或 Ingress。 要列出适用于您的 minikube 版本的可用插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube addons list</span><br></pre></td></tr></table></figure>
<p>要启用附加组件，请参阅：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube addons enable &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p>要在启动时启用插件，可以多次指定 <code>–-addons</code> 选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --addons &lt;name1&gt; --addons &lt;name2&gt;</span><br></pre></td></tr></table></figure>
<p>对于暴露浏览器访问端点的附加组件，您可以使用以下命令快速打开它们：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube addons open &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p>要禁用附加组件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube addons disable &lt;name&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/deploying/">Deploying apps | minikube - https://minikube.sigs.k8s.io/docs/handbook/deploying/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>App</tag>
        <tag>Deployment</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 文件同步</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-FileSync/</url>
    <content><![CDATA[<h1>手册 - 文件同步</h1>
<p>如何将文件同步到 minikube</p>
<span id="more"></span>
<h2 id="内置同步">内置同步</h2>
<p>minikube 有一个内置的文件同步机制，但它只在 <code>minikube start</code> 运行时同步，尽管在 Kubernetes 启动之前。 这可能有用的示例是系统或 Kubernetes 配置文件的自定义版本，例如：</p>
<ul>
<li>DNS 配置</li>
<li>SSL 证书</li>
<li>Kubernetes 服务元数据</li>
</ul>
<h3 id="添加文件">添加文件</h3>
<p>将要同步的文件放在 <code>$MINIKUBE_HOME/files</code></p>
<p>例如，运行以下命令将导致部署自定义 <code>/etc/resolv.conf</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.minikube/files/etc</span><br><span class="line">echo nameserver 8.8.8.8 &gt; ~/.minikube/files/etc/resolv.conf</span><br><span class="line">minikube start</span><br></pre></td></tr></table></figure>
<h2 id="其他方法">其他方法</h2>
<p>通过一些工作，可以在主机和 VM 之间设置 Syncthing，以实现持久的文件同步。</p>
<p>如果您正在寻找适合迭代应用程序开发的解决方案，请考虑使用已知可与 minikube 配合使用的 Kubernetes 工具：</p>
<ul>
<li>
<p><a href="https://draft.sh/">Draft - https://draft.sh/</a>：查看具体的 <a href="https://github.com/Azure/draft/blob/master/docs/install-minikube.md">minikube 说明 - https://github.com/Azure/draft/blob/master/docs/install-minikube.md</a></p>
</li>
<li>
<p><a href="https://github.com/okteto/okteto">Okteto - https://github.com/okteto/okteto</a></p>
</li>
<li>
<p><a href="https://github.com/GoogleContainerTools/skaffold">Skaffold - https://github.com/GoogleContainerTools/skaffold</a></p>
</li>
</ul>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/filesync/">File Sync | minikube - https://minikube.sigs.k8s.io/docs/handbook/filesync/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Deployment</tag>
        <tag>Service</tag>
        <tag>File Sync</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 主机访问</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Host-Access/</url>
    <content><![CDATA[<h1>手册 - 主机访问</h1>
<p>如何从 Pod 访问主机资源</p>
<span id="more"></span>
<h2 id="先决条件">先决条件</h2>
<p>在您的主机上运行的服务必须绑定到所有 IP (0.0.0.0) 和接口，或者绑定到您的 VM 桥接的 IP 和接口。如果服务仅绑定到 localhost (127.0.0.1)，这将不起作用。</p>
<h2 id="host-minikube-internal">host.minikube.internal</h2>
<p>为了更容易访问您的主机，minikube v1.10 将主机名条目 <code>host.minikube.internal</code> 添加到 <code>/etc/hosts</code>。 <code>host.minikube.internal</code> 解析到的 IP 因驱动程序而异，并且可能因集群而异。</p>
<h2 id="验证连接性">验证连接性</h2>
<p>您可以使用 <code>minikube ssh</code> 来确认连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube ssh</span></span><br><span class="line">                          _             _</span><br><span class="line">            _         _ ( )           ( )</span><br><span class="line">  ___ ___  (_)  ___  (_)| |/&#x27;)  _   _ | |_      __  </span><br><span class="line">/&#x27; _ ` _ `\| |/&#x27; _ `\| || , &lt;  ( ) ( )| &#x27;_`\  /&#x27;__`\</span><br><span class="line">| ( ) ( ) || || ( ) || || |\`\ | (_) || |_) )(  ___/</span><br><span class="line">(_) (_) (_)(_)(_) (_)(_)(_) (_)`\___/&#x27;(_,__/&#x27;`\____)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping host.minikube.internal</span></span><br><span class="line">PING host.minikube.internal (192.168.64.1): 56 data bytes</span><br><span class="line">64 bytes from 192.168.64.1: seq=0 ttl=64 time=0.225 ms</span><br></pre></td></tr></table></figure>
<p>要测试与在您的主机上侦听的特定 TCP 服务的连接，请使用 <code>nc -vz host.minikube.internal &lt;port&gt;</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc -vz host.minikube.internal 8000</span></span><br><span class="line">Connection to host.minikube.internal 8000 port [tcp/*] succeeded!</span><br></pre></td></tr></table></figure>
<p>以下是解释不同消息的方法：</p>
<ul>
<li>
<p><code>Connection succeeded</code>：您已连接！</p>
</li>
<li>
<p><code>Connection refused </code>：服务没有监听端口，至少没有跨所有接口</p>
</li>
</ul>
<blockquote>
<p>笔记<br>
当使用旧版本的 minikube 时，您可能需要在 minikube 映像中手动安装 ping 和 netcat 等工具：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install iputils-ping netcat-openbsd</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/host-access/">Host access | minikube - https://minikube.sigs.k8s.io/docs/handbook/host-access/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Host</tag>
        <tag>VM</tag>
        <tag>Virtual Machine</tag>
        <tag>Virtual Machine (VM)</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - Kubectl</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Kubectl/</url>
    <content><![CDATA[<h1>手册 - Kubectl</h1>
<p>在 minikube 中使用 <code>kubectl</code></p>
<p>默认情况下，在执行 minikube start 命令后，<code>kubectl</code> 被配置为访问 minikube 内的 kubernetes 集群控制平面。<br>
但是，如果 kubectl 没有在本地安装，minikube 已经包含 kubectl，可以这样使用：</p>
<span id="more"></span>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube kubectl -- &lt;kubectl commands&gt;</span><br></pre></td></tr></table></figure>
<h2 id="别名">别名</h2>
<p>您还可以为 kubectl 起别名以便于使用。</p>
<h3 id="Linux-和-macOS">Linux 和 macOS</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias kubectl=&quot;minikube kubectl --&quot;</span><br></pre></td></tr></table></figure>
<p>或者，您可以创建一个指向 minikube 二进制文件“kubectl”的符号链接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s $(which minikube) /usr/local/bin/kubectl</span><br></pre></td></tr></table></figure>
<h3 id="Windows">Windows</h3>
<p>PowerShell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function kubectl &#123; minikube kubectl -- $args &#125;</span><br></pre></td></tr></table></figure>
<p>命令提示符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">doskey kubectl=minikube kubectl $*</span><br></pre></td></tr></table></figure>
<h2 id="使用">使用</h2>
<p>获取 pods</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube kubectl -- get pods</span><br></pre></td></tr></table></figure>
<p>在 Kubernetes 集群中创建部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube kubectl -- create deployment hello-minikube --image=k8s.gcr.io/echoserver:1.4</span><br></pre></td></tr></table></figure>
<p>使用 NodePort 服务公开部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube kubectl -- expose deployment hello-minikube --type=NodePort --port=8080</span><br></pre></td></tr></table></figure>
<p>如需更多帮助</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube kubectl -- --help</span><br></pre></td></tr></table></figure>
<h2 id="Shell-自动补全">Shell 自动补全</h2>
<p>创建别名或符号链接后，您可以按照 <a href="https://kubernetes.io/docs/tasks/tools/included/optional-kubectl-configs-bash-linux/">bash auto-completion on Linux | Kubernetes - https://kubernetes.io/docs/tasks/tools/included/optional-kubectl-configs-bash-linux/</a> 启用 shell-autocompletion。</p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/kubectl/">Kubectl | minikube - https://minikube.sigs.k8s.io/docs/handbook/kubectl/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Deployment</tag>
        <tag>Service</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 挂载文件系统</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Mount/</url>
    <content><![CDATA[<h1>挂载文件系统</h1>
<p>如何将主机目录挂载到虚拟机中</p>
<span id="more"></span>
<h2 id="9P-挂载">9P 挂载</h2>
<p>9P 挂载灵活且适用于所有虚拟机管理程序，但在与大型文件夹（&gt;600 个文件）一起使用时会遇到性能和可靠性问题。 请参阅驱动器安装作为替代方案。<br>
使用 mount 子命令将主机中的目录挂载到 VM 中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube mount &lt;source directory&gt;:&lt;target directory&gt;</span><br></pre></td></tr></table></figure>
<p>例如，这会将您的主目录挂载为在 minikube VM 中显示为 <code>/host</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube mount $HOME:/host</span><br></pre></td></tr></table></figure>
<p>然后可以从 Kubernetes 清单中引用该目录，例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pod&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;spec&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;containers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu:18.04&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;bash&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stdin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stdinOnce&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tty&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;workingDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/host&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;volumeMounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;mountPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/host&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-mount&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;volumes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-mount&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;hostPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/host&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="驱动器挂载">驱动器挂载</h2>
<p>一些管理程序具有内置的主机文件夹共享。 驱动程序挂载可靠且性能良好，但路径无法跨操作系统或管理程序预测：</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>操作系统</th>
<th>主机目录</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>VirtualBox</td>
<td>Linux</td>
<td>/home</td>
<td>/hosthome</td>
</tr>
<tr>
<td>VirtualBox</td>
<td>macOS</td>
<td>/Users</td>
<td>/Users</td>
</tr>
<tr>
<td>VirtualBox</td>
<td>Windows</td>
<td>C://Users</td>
<td>/c/Users</td>
</tr>
<tr>
<td>VMware Fusion</td>
<td>macOS</td>
<td>/Users</td>
<td>/mnt/hgfs/Users</td>
</tr>
<tr>
<td>KVM</td>
<td>Linux</td>
<td>Unsupported</td>
<td>Unsupported</td>
</tr>
<tr>
<td>HyperKit</td>
<td>macOS</td>
<td>Supported</td>
<td>Supported</td>
</tr>
</tbody>
</table>
<p>可以通过将 <code>--disable-driver-mounts</code> 传递给 <code>minikube start</code> 来禁用这些挂载。</p>
<p>HyperKit 挂载可以使用以下标志： <code>--nfs-share=[]</code>：通过 NFS 挂载与访客共享的本地文件夹 <code>--nfs-shares-root='/nfsshares'</code>：NFS 共享的根目录，默认为 <code>/nfsshares</code>。</p>
<h2 id="文件同步">文件同步</h2>
<p>请参阅<a href="https://minikube.sigs.k8s.io/docs/handbook/filesync/">文件同步 - https://minikube.sigs.k8s.io/docs/handbook/filesync/</a></p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/mount/">Mounting filesystems | minikube - https://minikube.sigs.k8s.io/docs/handbook/mount/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Deployment</tag>
        <tag>Service</tag>
        <tag>Mount</tag>
        <tag>File System</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 网络策略</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Network-Policy/</url>
    <content><![CDATA[<h1>网络策略</h1>
<p>控制流经集群的流量</p>
<p>minikube 允许用户在本地 Kubernetes 集群中创建和测试网络策略。这很有用，因为它允许在应用程序开发期间考虑、构建和评估网络策略，将其作为流程的一个组成部分，而不是在开发结束时“固定”。</p>
<span id="more"></span>
<p><a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">Kubernetes NetworkPolicies - https://kubernetes.io/docs/concepts/services-networking/network-policies/</a>允许在 IP 地址或端口级别（OSI 第 3 层或第 4 层）控制通过集群的 Pod 网络流量。链接页面提供了有关功能和实现的更多信息。</p>
<p>但是，<a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/#prerequisites">先决条件 - https://kubernetes.io/docs/concepts/services-networking/network-policies/#prerequisites</a>说明网络策略是由容器网络接口 (CNI) 网络插件实现的。因此，要在任何 Kubernetes 集群中使用或测试网络策略，您必须使用支持 NetworkPolicy 的网络解决方案。在没有实现它的控制器的情况下创建 NetworkPolicy 资源将无效。</p>
<p>普通 minikube 安装（<code>minikube start</code>）不支持任何 <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">NetworkPolicies - https://kubernetes.io/docs/concepts/services-networking/network-policies/</a>，因为默认 CNI <a href="https://github.com/aojea/kindnet">Kindnet - https://github.com/aojea/kindnet</a> 在设计上不支持网络策略<a href="https://github.com/kubernetes-sigs/kind/issues/842#issuecomment-528824670">Network Policy | minikube - https://github.com/kubernetes-sigs/kind/issues/842#issuecomment-528824670</a>。</p>
<p>但是，如果安装了受支持的 CNI（例如 Calico），minikube 可以支持 <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">NetworkPolicies - https://kubernetes.io/docs/concepts/services-networking/network-policies/</a>。此外，在这种情况下，<a href="https://projectcalico.docs.tigera.io/security/kubernetes-network-policy">Kubernetes 网络策略 - https://projectcalico.docs.tigera.io/security/kubernetes-network-policy</a>和 ​​<a href="https://projectcalico.docs.tigera.io/security/calico-network-policy">Calico 网络策略 - https://projectcalico.docs.tigera.io/security/calico-network-policy</a>都受支持。</p>
<p>Calico 网络策略提供了比 Kubernetes 网络策略更丰富的策略功能，包括：</p>
<ul>
<li>
<p>政策排序/优先级</p>
</li>
<li>
<p>拒绝规则</p>
</li>
<li>
<p>更灵活的匹配规则</p>
</li>
</ul>
<h2 id="在-minikube-集群上启用-Calico">在 minikube 集群上启用 Calico</h2>
<p>可以在正在运行的 minikube 集群上替换 CNI，但是按照<a href="https://minikube.sigs.k8s.io/docs/start/">入门 - https://minikube.sigs.k8s.io/docs/start/</a>指南中的说明，只需将 <code>--cni calico</code> 标志附加到 <code>minikube start</code> 命令就容易得多！从一开始就安装了 Calico 的页面来构建 minikube 集群。</p>
<h2 id="Kubernetes-网络策略示例">Kubernetes 网络策略示例</h2>
<p>关于声明网络策略的 Kubernetes 文档是开始了解可能性的好地方。此外，下面的进一步阅读中的教程提供了更多指导。<br>
下面来自 Kubernetes NetworkPolicies 文档的 YAML 显示了一个非常简单的默认入口隔离策略或命名空间，方法是创建一个选择所有 Pod 但不允许任何入口流量到这些 Pod 的 NetworkPolicy。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default-deny-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br></pre></td></tr></table></figure>
<h2 id="Calico-网络策略示例">Calico 网络策略示例</h2>
<p>Calico 网络策略文档是了解 Calico 网络策略的扩展特性集以及它如何与 Kubernetes 网络策略共存的最佳场所。<br>
下面来自 Calico 策略教程的 YAML 显示了一个非常简单的默认拒绝全局 Calico 网络策略（不适用于 vanilla Kubernetes 网络策略），它通常用作有效的零信任网络模型的起点。请注意，全局 Calico 网络策略没有命名空间，并且会影响与策略选择器匹配的所有 pod。相比之下，Kubernetes 网络策略是命名空间的，因此您需要为每个命名空间创建一个默认拒绝策略以实现相同的效果。在此示例中，kube-system 命名空间中的 pod 被排除在外，以保持 Kubernetes 自身平稳运行。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">projectcalico.org/v3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">GlobalNetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default-deny</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="string">projectcalico.org/namespace</span> <span class="type">!=</span> <span class="string">&quot;kube-system&quot;</span></span><br><span class="line">  <span class="attr">types:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br></pre></td></tr></table></figure>
<h2 id="进一步阅读">进一步阅读</h2>
<p>本<a href="https://projectcalico.docs.tigera.io/security/tutorials/kubernetes-policy-advanced">高级 Kubernetes 策略教程 - https://projectcalico.docs.tigera.io/security/tutorials/kubernetes-policy-advanced</a>提供了一个示例，说明使用 Kubernetes 网络策略可以实现什么。它逐步介绍了使用 Kubernetes NetworkPolicy 来定义更复杂的网络策略。</p>
<p>本 <a href="https://projectcalico.docs.tigera.io/security/tutorials/calico-policy">Calico 策略教程 - https://projectcalico.docs.tigera.io/security/tutorials/calico-policy</a>演示了 Calico 网络策略提供的超越普通 Kubernetes 网络策略的扩展功能。为了演示这一点，本教程采用与上述教程类似的方法，但使用 Calico 网络策略并突出显示两种策略类型之间的差异，利用 Kubernetes 网络策略中不可用的功能。</p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/network_policy/">Network Policy | minikube - https://minikube.sigs.k8s.io/docs/handbook/network_policy/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Shell</tag>
        <tag>Network Polocy</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 离线使用</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Offline/</url>
    <content><![CDATA[<h1>手册 - 离线使用</h1>
<p>缓存控制 minikube 所有的一切。</p>
<span id="more"></span>
<p>minikube 内置支持将下载的资源缓存到 <code>$MINIKUBE_HOME/cache</code> 中。以下是重要的文件位置：</p>
<ul>
<li>
<p><code>~/.minikube/cache</code> - 顶级文件夹</p>
</li>
<li>
<p><code>~/.minikube/cache/iso</code> - 虚拟机 ISO 映像。通常每个主要 minikube 版本更新一次。</p>
</li>
<li>
<p><code>~/.minikube/cache/images</code> - Kubernetes 使用的 Docker 镜像。</p>
</li>
<li>
<p><code>~/.minikube/cache/&lt;version&gt;</code> - Kubernetes 二进制文件，例如 kubeadm 和 kubelet</p>
</li>
</ul>
<h2 id="Kubernetes-镜像缓存">Kubernetes 镜像缓存</h2>
<p>注意：none 驱动程序将镜像直接缓存到 Docker 中，而不是单独的磁盘缓存中。<br>
<code>minikube start</code> 默认缓存所有需要的 Kubernetes 镜像。这个默认值可以通过设置 <code>--cache-images=false</code> 来改变。 minikube 缓存命令不会显示这些镜像。</p>
<h2 id="共享-minikube-缓存">共享 minikube 缓存</h2>
<p>为了在其他主机上离线使用，可以复制 <code>~/.minikube/cache</code> 的内容。截至 v1.0 版本，此目录包含 685MB 数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cache/iso/minikube-v1.0.0.iso</span><br><span class="line">cache/images/gcr.io/k8s-minikube/storage-provisioner_v1.8.1</span><br><span class="line">cache/images/k8s.gcr.io/k8s-dns-sidecar-amd64_1.14.13</span><br><span class="line">cache/images/k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64_1.14.13</span><br><span class="line">cache/images/k8s.gcr.io/kubernetes-dashboard-amd64_v1.10.1</span><br><span class="line">cache/images/k8s.gcr.io/kube-scheduler_v1.14.0</span><br><span class="line">cache/images/k8s.gcr.io/coredns_1.3.1</span><br><span class="line">cache/images/k8s.gcr.io/kube-controller-manager_v1.14.0</span><br><span class="line">cache/images/k8s.gcr.io/kube-apiserver_v1.14.0</span><br><span class="line">cache/images/k8s.gcr.io/pause_3.1</span><br><span class="line">cache/images/k8s.gcr.io/etcd_3.3.10</span><br><span class="line">cache/images/k8s.gcr.io/kube-addon-manager_v9.0</span><br><span class="line">cache/images/k8s.gcr.io/k8s-dns-kube-dns-amd64_1.14.13</span><br><span class="line">cache/images/k8s.gcr.io/kube-proxy_v1.14.0</span><br><span class="line">cache/v1.14.0/kubeadm</span><br><span class="line">cache/v1.14.0/kubelet</span><br></pre></td></tr></table></figure>
<p>如果存在这些文件中的任何一个，minikube 将使用直接将它们复制到 VM 中，而不是从 Internet 中提取它们。</p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/offline/">Offline usage | minikube - https://minikube.sigs.k8s.io/docs/handbook/offline/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Shell</tag>
        <tag>Offline</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 离线使用</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Persistent-Volumes/</url>
    <content><![CDATA[<h1>手册 - 持久卷</h1>
<p>关于持久卷 (hostPath)</p>
<p>minikube 开箱即用地支持 <code>hostPath</code> 类型的 <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">PersistentVolume - https://kubernetes.io/docs/concepts/storage/persistent-volumes/</a>。这些 PersistentVolume 映射到正在运行的 minikube 实例（通常是 VM，除非您使用 <code>--driver=none</code>、<code>--driver=docker</code> 或 <code>--driver=podman</code>）内的目录。有关其工作原理的更多信息，请阅读下面的动态配置部分。</p>
<span id="more"></span>
<h2 id="关于挂载、持久性和-minikube-主机的说明">关于挂载、持久性和 minikube 主机的说明</h2>
<p>minikube 配置为持久保存存储在以下目录下的文件，这些目录是在 Minikube VM 中创建的（如果在裸机上运行，​​则在您的本地主机上）。重新启动时，您可能会丢失其他目录中的数据。</p>
<ul>
<li><code>/data*</code></li>
<li><code>/var/lib/minikube</code></li>
<li><code>/var/lib/docker</code></li>
<li><code>/var/lib/containerd</code></li>
<li><code>/var/lib/buildkit</code></li>
<li><code>/var/lib/containers</code></li>
<li><code>/tmp/hostpath_pv*</code></li>
<li><code>/tmp/hostpath-provisioner*</code></li>
</ul>
<ul>
<li>另一个目录的挂载点，存储在 <code>/var</code> 下或单独的数据磁盘</li>
</ul>
<p>这是一个示例 PersistentVolume 配置，用于将数据保存在 <code>/data</code> 目录中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv0001</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/pv0001/</span></span><br></pre></td></tr></table></figure>
<p>您还可以通过在已安装的主机文件夹中创建 PV 来实现持久性。</p>
<h2 id="动态配置和-CSI">动态配置和 CSI</h2>
<p>此外，minikube 实现了一个非常简单、规范的动态存储控制器实现，它与它的部署一起运行。这管理 hostPath 卷的配置（而不是通过以前的 in-tree hostPath 提供程序）。</p>
<p>默认的 <a href="https://github.com/kubernetes/minikube/blob/master/pkg/storage/storage_provisioner.go">Storage Provisioner 控制器 - https://github.com/kubernetes/minikube/blob/master/pkg/storage/storage_provisioner.go</a>在 minikube 代码库中进行内部管理，展示了将自定义存储控制器作为系统的存储组件插入 kubernetes 是多么容易，并动态地为 pod 提供，以测试你的 pod 在持久存储时的行为映射到它。</p>
<p>请注意，这不是基于 CSI 的存储提供程序，而是当控制器发现有未完成的存储请求时，它只是动态声明类型为 hostpath 的 PersistentVolume 对象。</p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/persistent_volumes/">Persistent Volumes | minikube - https://minikube.sigs.k8s.io/docs/handbook/persistent_volumes/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Shell</tag>
        <tag>Persistent Volume</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 代理和 VPN</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Proxy-and-VPN/</url>
    <content><![CDATA[<h1>手册 - 代理和 VPN</h1>
<p>如何通过 VPN 或 HTTP/HTTPS 代理使用 minikube</p>
<p>minikube 需要通过 HTTP、HTTPS 和 DNS 协议访问互联网。</p>
<h2 id="代理">代理</h2>
<p>如果需要 HTTP 代理来访问互联网，您可能需要使用环境变量将代理连接信息传递给 minikube 和 Docker：</p>
<ul>
<li>
<p><code>HTTP_PROXY</code> - HTTP 代理的 URL</p>
</li>
<li>
<p><code>HTTPS_PROXY</code> - HTTPS 代理的 URL</p>
</li>
<li>
<p><code>NO_PROXY</code> - 不应通过代理的主机的逗号分隔列表。</p>
</li>
</ul>
<p>这里的 <code>NO_PROXY</code> 变​​量很重要：如果不设置它，minikube 可能无法访问 VM 内的资源。 minikube 使用两个 IP 范围，它们不应该</p>
<p>通过代理：</p>
<ul>
<li>
<p>192.168.59.0/24：由 minikube VM 使用。可通过 <code>--host-only-cidr</code> 为某些虚拟机管理程序配置</p>
</li>
<li>
<p><code>192.168.39.0/24</code>：由 minikube kvm2 驱动程序使用。</p>
</li>
<li>
<p><code>192.168.49.0/24</code>：由 minikube docker driver 的第一个集群使用。</p>
</li>
<li>
<p><code>10.96.0.0/12</code>：由服务集群 IP 使用。可通过 --service-cluster-ip-range 配置</p>
</li>
</ul>
<p>一个重要提示：如果非 Kubernetes 应用程序（例如 Firefox 或 Chrome）需要 <code>NO_PROXY</code>，您可能需要专门将 minikube IP 添加到逗号分隔列表中，因为它们可能不理解 IP 范围（#3827）。</p>
<h2 id="示例用法">示例用法</h2>
<h3 id="macOS-和-Linux">macOS 和 Linux</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HTTP_PROXY=http://&lt;proxy hostname:port&gt;</span><br><span class="line">export HTTPS_PROXY=https://&lt;proxy hostname:port&gt;</span><br><span class="line">export NO_PROXY=localhost,127.0.0.1,10.96.0.0/12,192.168.59.0/24,192.168.39.0/24</span><br><span class="line"></span><br><span class="line">minikube start</span><br></pre></td></tr></table></figure>
<p>要使环境变量持久化，请考虑将声明添加到 <code>~/.bashrc</code> 或存储用户设置的环境变量的任何位置。</p>
<h3 id="Windows">Windows</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set HTTP_PROXY=http://&lt;proxy hostname:port&gt;</span><br><span class="line">set HTTPS_PROXY=https://&lt;proxy hostname:port&gt;</span><br><span class="line">set NO_PROXY=localhost,127.0.0.1,10.96.0.0/12,192.168.59.0/24,192.168.39.0/24</span><br><span class="line"></span><br><span class="line">minikube start</span><br></pre></td></tr></table></figure>
<p>要持久化设置这些环境变量，请考虑将它们添加到您的系统设置或使用 <code>setx</code>。</p>
<h3 id="故障排除">故障排除</h3>
<h4 id="unable-to-cache-ISO…-connection-refused">unable to cache ISO… connection refused</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Unable to start VM: unable to cache ISO: https://storage.googleapis.com/minikube/iso/minikube.iso:</span><br><span class="line">failed to download: failed to download to temp file: download failed: 5 error(s) occurred:</span><br><span class="line"></span><br><span class="line">* Temporary download error: Get https://storage.googleapis.com/minikube/iso/minikube.iso:</span><br><span class="line">proxyconnect tcp: dial tcp &lt;host&gt;:&lt;port&gt;: connect: connection refused</span><br></pre></td></tr></table></figure>
<p>此错误表示 <code>HTTPS_PROXY</code> 或 <code>HTTP_PROXY</code> 定义的 <code>host:port</code> 组合不正确，或者代理不可用。</p>
<h4 id="Unable-to-pull-images…Client-Timeout-exceeded-while-awaiting-headers">Unable to pull images…Client.Timeout exceeded while awaiting headers</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Unable to pull images, which may be OK:</span><br><span class="line"></span><br><span class="line">failed to pull image &quot;k8s.gcr.io/kube-apiserver:v1.13.3&quot;: output: Error response from daemon:</span><br><span class="line">Get https://k8s.gcr.io/v2/: net/http: request canceled while waiting for connection</span><br><span class="line">(Client.Timeout exceeded while awaiting headers)</span><br></pre></td></tr></table></figure>
<p>此错误表示在 VM 中运行的容器运行时无法访问 Internet。验证您是否将适当的值传递给 <code>--docker-env HTTPS_PROXY</code>。</p>
<h4 id="x509-certificate-signed-by-unknown-authority">x509: certificate signed by unknown authority</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-apiserver:v1.13.3:</span><br><span class="line">output: Error response from daemon:</span><br><span class="line">Get https://k8s.gcr.io/v2/: x509: certificate signed by unknown authority</span><br></pre></td></tr></table></figure>
<p>这是因为 minikube VM 被隐藏在一个代理后面，该代理重写 HTTPS 响应以包含它自己的 TLS 证书。解决方案是将代理证书安装到启动时复制到 VM 的位置，以便对其进行验证。</p>
<p>向您的 IT 部门索取适当的 PEM 文件，并将其添加到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/.minikube/files/etc/ssl/certs</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/.minikube/certs</span><br></pre></td></tr></table></figure>
<p>然后运行 ​​<code>minikube delete</code> 和 <code>minikube start</code>。</p>
<h4 id="downloading-binaries-proxyconnect-tcp-tls-oversized-record-received-with-length-20527">downloading binaries: proxyconnect tcp: tls: oversized record received with length 20527</h4>
<p><code>HTTPS_PROXY</code> 提供的值可能不正确。验证该值是否指向 HTTP 代理而不是 HTTPS 代理。</p>
<h2 id="VPN">VPN</h2>
<p>minikube 需要从主机访问以下 IP 范围：</p>
<ul>
<li>
<p><code>192.168.59.0/24</code>：由 minikube VM 使用。可通过 <code>--host-only-cidr</code> 为某些虚拟机管理程序配置</p>
</li>
<li>
<p><code>192.168.39.0/24</code>：由 minikube kvm2 驱动程序使用。</p>
</li>
<li>
<p><code>10.96.0.0/12</code>：由服务集群 IP 使用。可通过 <code>--service-cluster-ip-range</code> 配置</p>
</li>
</ul>
<p>不幸的是，许多 VPN 配置通过加密隧道将数据包路由到这些目的地，而不是允许数据包进入 minikube 虚拟机。</p>
<h3 id="可能的解决方法">可能的解决方法</h3>
<ul>
<li>
<ol>
<li>如果您有访问权限，请在您的 VPN 软件中将上述 IP 范围列入白名单。</li>
</ol>
</li>
<li>
<ol start="2">
<li>在您的 VPN 软件中，选择类似于“使用 VPN 时允许本地 (LAN) 访问”（Cisco VPN 示例）的选项。</li>
</ol>
</li>
<li>
<ol start="3">
<li>您可能会幸运地为 <code>--host-only-cidr</code> 和 <code>--service-cluster-ip-range</code> 标志选择替代值。</li>
</ol>
</li>
<li>
<ol start="4">
<li>关闭 VPN</li>
</ol>
</li>
</ul>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/vpn_and_proxy/">Proxies and VPNs | minikube - https://minikube.sigs.k8s.io/docs/handbook/vpn_and_proxy/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Deployment</tag>
        <tag>Service</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 推送镜像</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Pushing-Images/</url>
    <content><![CDATA[<h1>手册 - 推送镜像</h1>
<p>比较将镜像 Push 推送到 minikube 集群的 8 种方法。</p>
<span id="more"></span>
<p>词汇表：</p>
<p>Pull 拉取 意味着直接从远程注册表下载容器镜像。</p>
<p>Push 推送 意味着将容器映像直接上传到远程注册表。</p>
<p>Load 加载 获取可用作存档的图像，并使其在集群中可用。</p>
<p>Save 保存 将镜像保存到存档中。</p>
<p>Build 构建 需要一个“构建上下文”（目录）并从中在集群中创建一个新镜像。</p>
<p>Tag 标签 意味着分配名称和标记。</p>
<h2 id="不同方法的比较表">不同方法的比较表</h2>
<p>将镜像推送到 minikube 的最佳方法取决于您构建集群时使用的容器运行时（默认为 docker）。以下是帮助您选择的比较表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>支持的运行时</th>
<th>性能</th>
<th>加载</th>
<th>构建</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker-env command</td>
<td>仅 docker</td>
<td>好</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>cache command</td>
<td>所有</td>
<td>可以</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>podman-env command</td>
<td>仅 cri-o</td>
<td>好</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>registry addon</td>
<td>所有</td>
<td>可以</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>minikube ssh</td>
<td>所有</td>
<td>最佳</td>
<td>支持*</td>
<td>支持*</td>
</tr>
<tr>
<td>ctr/buildctl command</td>
<td>仅 containerd</td>
<td>好</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>image load command</td>
<td>所有</td>
<td>可以</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>image build command</td>
<td>所有</td>
<td>可以</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意 1：minikube 上的默认容器运行时是“docker”。</p>
</blockquote>
<blockquote>
<p>注意2：“无”驱动程序（裸机）不需要将映像推送到集群，因为您系统上的任何映像都已可供 kubernetes 使用。</p>
</blockquote>
<blockquote>
<p>注意 3：使用 ssh 运行命令时，要加载或构建的文件必须已经在节点上可用（不仅在客户端主机上）。</p>
</blockquote>
<h2 id="1-直接推送到集群内的-Docker-守护进程（docker-env）">1. 直接推送到集群内的 Docker 守护进程（docker-env）</h2>
<p>这类似于 podman-env，但仅适用于 Docker 运行时。使用容器或 VM 驱动程序（除无驱动程序外的所有驱动程序）时，您可以在 minikube 集群内重用 Docker 守护程序。这意味着您不必在主机上构建并将映像推送到 docker 注册表中。您可以在与 minikube 相同的 docker 守护进程中构建，从而加快本地实验。</p>
<p>要让您的终端使用 minikube 中的 docker 守护进程，请运行以下命令：</p>
<h3 id="Linux">Linux</h3>
<ul>
<li>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eval $(minikube docker-env)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="macOS">macOS</h3>
<ul>
<li>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eval $(minikube docker-env)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Windows">Windows</h3>
<h2 id="PowerShell">PowerShell</h2>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&amp; minikube -p minikube docker-env --shell powershell | Invoke-Expression</span><br></pre></td></tr></table></figure>
<h2 id="cmd">cmd</h2>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@FOR /f &quot;tokens=*&quot; %i IN (&#x27;minikube -p minikube docker-env --shell cmd&#x27;) DO @%i</span><br></pre></td></tr></table></figure>
<p>现在，您在当前终端中运行的任何 <code>docker</code> 命令都将针对 minikube 集群内的 docker 运行时。<br>
因此，如果您执行以下命令，它将显示 minikube 内、minikube 的 VM 或 Container 内的容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>现在，您可以在 minikube 内对 docker 进行“构建”，Kubernetes 集群可以立即访问该 docker。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t my_image .</span><br></pre></td></tr></table></figure>
<p>要验证您的终端是否使用 minikube 的 <code>docker-env</code>，您可以检查环境变量 <code>MINIKUBE_ACTIVE_DOCKERD</code> 的值以反映集群名称。</p>
<blockquote>
<p>提示 1：记得在 yaml 文件中关闭 imagePullPolicy:Always（使用 imagePullPolicy:IfNotPresent 或 imagePullPolicy:Never）。否则 Kubernetes 不会使用你本地构建的镜像，它会从网络中拉取。</p>
</blockquote>
<blockquote>
<p>提示 2：评估 docker-env 仅对当前终端有效。通过关闭终端，您将回到使用自己系统的 docker 守护进程。</p>
</blockquote>
<blockquote>
<p>提示 3：在 Docker 或 Podman 等基于容器的驱动程序中，每次重启 minikube 集群时都需要重新执行 docker-env。</p>
</blockquote>
<p>有关 <a href="https://minikube.sigs.k8s.io/docs/commands/docker-env/">docker-env - https://minikube.sigs.k8s.io/docs/commands/docker-env/</a> 的更多信息</p>
<h2 id="2-使用-cache-命令推送镜像">2. 使用 <code>cache</code> 命令推送镜像</h2>
<p>从您的主机可以将 Docker 映像直接推送到 minikube。此镜像将被缓存并自动拉入机器上创建的所有未来 minikube 集群中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube cache add alpine:latest</span><br></pre></td></tr></table></figure>
<p>add 命令会将请求的镜像存储到 <code>$MINIKUBE_HOME/cache/images</code> 中，并自动将其加载到 minikube 集群的容器运行环境中。</p>
<blockquote>
<p>提示 1：如果您的镜像在缓存后发生变化，您需要进行“缓存重新加载”。</p>
</blockquote>
<p>minikube 在每次启动时刷新缓存图像。但是，要按需重新加载所有缓存的图像，请运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube cache reload</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示 2：如果您有多个集群，缓存命令将为所有集群加载图像。</p>
</blockquote>
<p>要显示您已添加到缓存中的图像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube cache list</span><br></pre></td></tr></table></figure>
<p>此列表不包括 minikube 的内置系统映像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube cache delete &lt;image name&gt;</span><br></pre></td></tr></table></figure>
<p>有关更多信息，请参阅：</p>
<p><a href="https://minikube.sigs.k8s.io/docs/commands/cache/">参考：缓存命令 - https://minikube.sigs.k8s.io/docs/commands/cache/</a></p>
<h2 id="3-直接推送到集群内CRI-O。-podman-env">3.直接推送到集群内CRI-O。 (podman-env)</h2>
<h3 id="Linux-2">Linux</h3>
<p>这类似于 docker-env 但仅适用于 CRI-O 运行时。要直接推送到 CRI-O，请使用 shell 中的 podman-env 命令在主机上配置 Podman 客户端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eval $(minikube podman-env)</span><br></pre></td></tr></table></figure>
<p>您现在应该能够在主机上的命令行上使用 Podman 客户端与 minikube VM 内的 Podman 服务进行通信：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">podman-remote help</span><br></pre></td></tr></table></figure>
<p>现在，您可以针对 minikube 内部的存储“构建”，Kubernetes 集群可以立即访问该存储。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">podman-remote build -t my_image</span><br></pre></td></tr></table></figure>
<p>注意：在 macOS 上，远程客户端称为<code>podman-remote</code>，因为没有可用的本地<code>podman</code>程序。</p>
<h3 id="macOS-2">macOS</h3>
<p>这类似于 docker-env 但仅适用于 CRI-O 运行时。要直接推送到 CRI-O，请使用 shell 中的 podman-env 命令在主机上配置 Podman 客户端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eval $(minikube podman-env)</span><br></pre></td></tr></table></figure>
<p>您现在应该能够在主机上的命令行上使用 Podman 客户端与 minikube VM 内的 Podman 服务进行通信：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">podman help</span><br></pre></td></tr></table></figure>
<p>现在，您可以针对 minikube 内部的存储“构建”，Kubernetes 集群可以立即访问该存储。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">podman build -t my_image</span><br></pre></td></tr></table></figure>
<p>注意：在 macOS 上，远程客户端称为<code>podman</code>，因为没有可用的本地<code>podman</code>程序。</p>
<h3 id="Windows-2">Windows</h3>
<p>这类似于 docker-env 但仅适用于 CRI-O 运行时。 要直接推送到 CRI-O，请使用 shell 中的 podman-env 命令在主机上配置 Podman 客户端：</p>
<p>PowerShell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&amp; minikube -p minikube podman-env --shell powershell | Invoke-Expression</span><br></pre></td></tr></table></figure>
<p>cmd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@FOR /f &quot;tokens=*&quot; %i IN (&#x27;minikube -p minikube podman-env --shell cmd&#x27;) DO @%i</span><br></pre></td></tr></table></figure>
<p>您现在应该能够在主机上的命令行上使用 Podman 客户端与 minikube VM 内的 Podman 服务进行通信：<br>
现在，您可以针对 minikube 内部的存储“构建”，Kubernetes 集群可以立即访问该存储。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">podman help</span><br><span class="line"></span><br><span class="line">podman build -t my_image .</span><br></pre></td></tr></table></figure>
<p>注意：在 Windows 上，远程客户端称为<code>podman</code>，因为没有可用的本地<code>podman</code>程序。<br>
记得关闭 <code>imagePullPolicy:Always</code>（使用 <code>imagePullPolicy:IfNotPresent</code> 或 <code>imagePullPolicy:Never</code>），否则 Kubernetes 不会使用你在本地构建的镜像。</p>
<h2 id="4-使用注册表附加组件推送到集群内">4. 使用注册表附加组件推送到集群内</h2>
<p>为了便于说明，我们假设 minikube VM 具有来自 <code>192.168.39.0/24</code> 子网的 IP 之一。 如果您没有按照<a href="https://minikube.sigs.k8s.io/reference/networking/">网络指南 - https://minikube.sigs.k8s.io/reference/networking/</a>覆盖这些子网，您可以在<a href="https://github.com/kubernetes/minikube/blob/dfd9b6b83d0ca2eeab55588a16032688bc26c348/pkg/minikube/cluster/cluster.go#L408">此处 - https://github.com/kubernetes/minikube/blob/dfd9b6b83d0ca2eeab55588a16032688bc26c348/pkg/minikube/cluster/cluster.go#L408</a>找到 minikube 用于特定操作系统和驱动程序组合的默认子网，这可能会发生变化。 在适用的情况下，将 <code>192.168.39.0/24</code> 替换为适合您环境的值。</p>
<p>确保将 docker 配置为使用 <code>192.168.39.0/24</code> 作为不安全的注册表。 有关说明，请参阅<a href="https://docs.docker.com/registry/insecure/">此处 - https://docs.docker.com/registry/insecure/</a>。</p>
<p>确保 <code>192.168.39.0/24</code> 在 minikube 中启用为不安全的注册表。 有关说明，请参阅<a href="https://minikube.sigs.k8s.io/docs/handbook/registry/#enabling-insecure-registries/">此处 - https://minikube.sigs.k8s.io/docs/handbook/registry/#enabling-insecure-registries/</a>…</p>
<p>启用 minikube 注册表插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube addons enable registry</span><br></pre></td></tr></table></figure>
<p>构建 docker 镜像并适当地标记它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build --tag $(minikube ip):5000/test-img .</span><br></pre></td></tr></table></figure>
<p>将 docker 镜像推送到 minikube 注册表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push $(minikube ip):5000/test-img</span><br></pre></td></tr></table></figure>
<h2 id="5-使用-SSH-在-minikube-内构建镜像">5. 使用 SSH 在 minikube 内构建镜像</h2>
<p>使用 <code>minikube ssh</code> 在 minikube 节点内运行命令，并直接在那里运行构建命令。 您在那里运行的任何命令都将针对 kubernetes 集群正在使用的同一个守护进程/存储运行。</p>
<p>对于 Docker，使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build</span><br></pre></td></tr></table></figure>
<h2 id="有关-docker-build-命令的更多信息，请阅读-Docker-文档-https-docs-docker-com-engine-reference-commandline-build-docker-com-。对于-CRI-O，请使用：">有关 docker build 命令的更多信息，请阅读 <a href="https://docs.docker.com/engine/reference/commandline/build/">Docker 文档 - https://docs.docker.com/engine/reference/commandline/build/</a> (<a href="http://docker.com">docker.com</a>)。<br>
对于 CRI-O，请使用：</h2>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo podman build</span><br></pre></td></tr></table></figure>
<p>有关 podman build 命令的更多信息，请阅读 <a href="https://github.com/containers/podman/blob/master/docs/source/markdown/podman-build.1.md">Podman 文档 - https://github.com/containers/podman/blob/master/docs/source/markdown/podman-build.1.md</a> (<a href="http://podman.io">podman.io</a>)。</p>
<p>对于 Containerd，请使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ctr images import</span><br><span class="line"></span><br><span class="line">sudo buildctl build</span><br></pre></td></tr></table></figure>
<p>有关 <code>ctr images</code> 命令的更多信息，请阅读 <a href="https://containerd.io/docs/getting-started/">containerd 文档 - https://containerd.io/docs/getting-started/</a> (<a href="http://containerd.io">containerd.io</a>)</p>
<p>有关 <code>buildctl build</code> 命令的更多信息，请阅读 <a href="https://github.com/moby/buildkit#quick-start">Buildkit 文档 - https://github.com/moby/buildkit#quick-start</a>(<a href="http://mobyproject.org">mobyproject.org</a>)。<br>
要退出 <code>minikube ssh</code> 并返回您的终端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<h2 id="6-直接推送到集群内containerd（buildkitd）">6.直接推送到集群内containerd（buildkitd）</h2>
<p>这类似于 <code>docker-env</code> 和 <code>podman-env</code> 但仅适用于 Containerd 运行时。<br>
目前它需要启动守护进程并手动设置隧道。</p>
<h3 id="ctr-指令">ctr 指令</h3>
<p>要访问 containerd，您需要以 root 身份登录。 这需要将 ssh 密钥添加到 /root/authorized_keys…</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker@minikube:~$ sudo mkdir /root/.ssh</span><br><span class="line">docker@minikube:~$ sudo chmod 700 /root/.ssh</span><br><span class="line">docker@minikube:~$ sudo cp .ssh/authorized_keys /root/.ssh/authorized_keys</span><br><span class="line">docker@minikube:~$ sudo chmod 600 /root/.ssh</span><br></pre></td></tr></table></figure>
<p>请注意 ssh 命令所需的标志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube --alsologtostderr ssh --native-ssh=false</span><br></pre></td></tr></table></figure>
<p>从主机将 containerd 套接字通过隧道连接到主机。 （使用上面的 <code>ssh</code> 标志（最明显的是 <code>-p</code> 端口和 <code>root@host</code>））</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -nNT -L ./containerd.sock:/run/containerd/containerd.sock ... &amp;</span><br></pre></td></tr></table></figure>
<p>现在您可以通过 ssh 对这个 unix 套接字运行命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr --address ./containerd.sock help</span><br></pre></td></tr></table></figure>
<p>Kubernetes 集群可以访问 <code>k8s.io</code>命名空间中的镜像。</p>
<h3 id="buildctl-指令">buildctl 指令</h3>
<p>使用 containerd 后端启动 BuildKit 守护进程。</p>
<p>请注意 ssh 命令所需的标志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube --alsologtostderr ssh --native-ssh=false</span><br></pre></td></tr></table></figure>
<p>从机器将 containerd 套接字隧道连接到主机。 （使用上面的 <code>ssh</code> 标志（最明显的是 <code>-p</code> 端口和 <code>root@host</code>））</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -nNT -L ./containerd.sock:/run/containerd/containerd.sock ... &amp;</span><br></pre></td></tr></table></figure>
<p>之后，现在应该可以使用 buildctl：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">buildctl --addr unix://buildkitd.sock build \</span><br><span class="line">    --frontend=dockerfile.v0 \</span><br><span class="line">    --local context=. \</span><br><span class="line">    --local dockerfile=. \</span><br><span class="line">    --output type=image,name=k8s.gcr.io/username/imagename:latest</span><br></pre></td></tr></table></figure>
<p>现在您可以针对 minikube 内部的存储“构建”。 Kubernetes 集群可以立即访问它。</p>
<h2 id="7-直接加载到集群内容器运行时">7.直接加载到集群内容器运行时</h2>
<p>minikube 客户端将直接与集群中的容器运行时交互，并在那里运行加载命令——针对同一个存储。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube image load my_image</span><br></pre></td></tr></table></figure>
<p>有关更多信息，请参阅：</p>
<p><a href="https://minikube.sigs.k8s.io/docs/commands/image/#minikube-image-load">参考：图片加载命令 - https://minikube.sigs.k8s.io/docs/commands/image/#minikube-image-load</a></p>
<h2 id="8-将镜像构建到集群内容器运行时">8. 将镜像构建到集群内容器运行时</h2>
<p>minikube 客户端将直接与集群中的容器运行时对话，并在那里运行构建命令——针对同一个存储。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube image build -t my_image .</span><br></pre></td></tr></table></figure>
<p>有关更多信息，请参阅：</p>
<p><a href="https://minikube.sigs.k8s.io/docs/commands/image/#minikube-image-build">参考：镜像构建命令 - https://minikube.sigs.k8s.io/docs/commands/image/#minikube-image-build</a></p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/pushing/">Pushing images | minikube - https://minikube.sigs.k8s.io/docs/handbook/pushing/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Image</tag>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Deployment</tag>
        <tag>Service</tag>
        <tag>Registry</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 注册表</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Registries/</url>
    <content><![CDATA[<h1>手册 - 注册表</h1>
<p>注册表</p>
<p>如何与注册表交互</p>
<span id="more"></span>
<h2 id="使用私有注册表">使用私有注册表</h2>
<p>GCR/ECR/ACR/Docker：minikube 有一个附加组件，registry-creds，它将凭证映射到 minikube 以支持从 Google Container Registry (GCR)、Amazon 的 EC2 Container Registry (ECR)、Azure Container Registry (ACR) 和 Private Docker 注册表中拉取镜像。您需要运行 <code>minikube addons configure registry-creds</code> 和 <code>minikube addons enable registry-creds</code> 才能启动和运行。下面是一个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube addons configure registry-creds</span></span><br><span class="line">Do you want to enable AWS Elastic Container Registry? [y/n]: n</span><br><span class="line"></span><br><span class="line">Do you want to enable Google Container Registry? [y/n]: y</span><br><span class="line">-- Enter path to credentials (e.g. /home/user/.config/gcloud/application_default_credentials.json):/home/user/.config/gcloud/application_default_credentials.json</span><br><span class="line"></span><br><span class="line">Do you want to enable Docker Registry? [y/n]: n</span><br><span class="line"></span><br><span class="line">Do you want to enable Azure Container Registry? [y/n]: n</span><br><span class="line">registry-creds was successfully configured</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube addons <span class="built_in">enable</span> registry-creds</span></span><br></pre></td></tr></table></figure>
<p>Google Artifact Registry：minikube 有一个插件 <code>gcp-auth</code>，它将凭据映射到 minikube 以支持从 Google Artifact Registry 中提取镜像。运行 <code>minikube addons enable gcp-auth</code> 来配置身份验证。您可以在此处参考完整的文档<a href="https://minikube.sigs.k8s.io/docs/handbook/addons/gcp-auth/">Automated Google Cloud Platform Authentication | minikube - https://minikube.sigs.k8s.io/docs/handbook/addons/gcp-auth/</a>。</p>
<p>有关私有容器注册表的更多信息，请参阅此页面<a href="https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/">Pull an Image from a Private Registry | Kubernetes - https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/</a>。</p>
<p>我们建议您使用 <code>ImagePullSecrets</code>，但如果您想在 minikube VM 上配置访问权限，您可以将 <code>.dockercfg</code> 放在 <code>/home/docker</code> 目录中或将 <code>config.json</code> 放在 <code>/var/lib/kubelet</code> 目录中。确保使用 <code> sudo systemctl restart kubelet</code> 重新启动您的 kubelet（对于 kubeadm）进程。</p>
<h2 id="启用不安全的注册表">启用不安全的注册表</h2>
<p>minikube 允许用户配置 docker 引擎的 <code>--insecure-registry</code> 标志。<br>
您可以在 minikube start 命令上使用 <code>--insecure-registry</code> 标志来启用 docker 引擎和监听来自 CIDR 范围的请求的注册表之间的不安全通信。</p>
<p>一个绝妙的技巧是允许在 minikube 中运行的 kubelet 与部署在集群中的 pod 内的注册表通信，而无需使用 TLS 证书支持它们。因为默认服务集群 IP 已知在 <code>10.0.0.1</code> 可用，所以用户可以通过使用 <code>minikube start --insecure-registry &quot;10.0.0.0/24&quot;</code> 创建集群来从集群内部署的注册表中提取镜像。在使用 <code>--insecure-registry</code> 标志开始之前，确保使用 <code>minikube delete</code> 删除集群。</p>
<h3 id="macOS-上的-Docker">macOS 上的 Docker</h3>
<p>在 macOS 上配置 minikube 和 docker 的快速指南，使 docker 能够将镜像推送到 minikube 的注册表。</p>
<p>第一步是启用注册表附加组件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube addons enable registry</span><br></pre></td></tr></table></figure>
<p>注意：Minikube 将生成一个端口，并在启用注册表时请求您使用该端口。该说明与本指南无关。<br>
启用后，注册表插件会在 minikube 的虚拟机上公开其端口 5000。<br>
为了让 docker 接受将镜像推送到这个 registry，我们必须将 docker 虚拟机上的 5000 端口重定向到 minikube 机器上的 5000 端口。我们可以（ab）使用 docker 的网络配置在 docker 的主机上实例化一个容器，并在那里运行 socat：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -it --network=host alpine ash -c &quot;apk add socat &amp;&amp; socat TCP-LISTEN:5000,reuseaddr,fork TCP:$(minikube ip):5000&quot;</span><br></pre></td></tr></table></figure>
<p>一旦 socat 运行，就可以将镜像推送到 minikube 注册表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag my/image localhost:5000/myimage</span><br><span class="line">docker push localhost:5000/myimage</span><br></pre></td></tr></table></figure>
<p>在推送镜像后，请在 kubectl specs 中通过 <code>localhost:5000/&#123;name&#125;</code> 引用它。</p>
<h3 id="Windows-上的-Docker">Windows 上的 Docker</h3>
<p>在 Windows 上配置 minikube 和 docker 的快速指南，使 docker 能够将镜像推送到 minikube 的注册表。</p>
<p>第一步是启用注册表附加组件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube addons enable registry</span><br></pre></td></tr></table></figure>
<p>启用后，注册表插件会在 minikube 的虚拟机上公开其端口 80。您可以通过以下方式确认：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get service --namespace kube-system</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                  AGE</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">kube-dns   ClusterIP   10.96.0.10     &lt;none&gt;        53/UDP,53/TCP,9153/TCP   54m</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">registry   ClusterIP   10.98.34.133   &lt;none&gt;        80/TCP,443/TCP           37m</span></span><br></pre></td></tr></table></figure>
<p>为了让 docker 接受将镜像推送到这个注册表，我们必须将 docker 虚拟机上的端口 5000 重定向到 minikube 注册表服务上的端口 80。不幸的是，docker vm 无法直接看到 minikube vm 的 IP 地址。要解决此问题，您必须再添加一级重定向。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl port-forward --namespace kube-system service/registry 5000:80</span><br></pre></td></tr></table></figure>
<p>在您的本地计算机上，您现在应该能够使用 <code>curl http://localhost:5000/v2/_catalog</code> 访问 minikube 注册表。<br>
从这一点开始，我们可以（ab）使用 docker 的网络配置在 docker 的主机上实例化一个容器，并在那里运行 socat 将流向 docker vm 的端口 5000 的流量重定向到主机工作站上的端口 5000。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -it --network=host alpine ash -c &quot;apk add socat &amp;&amp; socat TCP-LISTEN:5000,reuseaddr,fork TCP:host.docker.internal:5000&quot;</span><br></pre></td></tr></table></figure>
<p>一旦 socat 运行，就可以将镜像从本地工作站推送到 minikube 注册表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag my/image localhost:5000/myimage</span><br><span class="line">docker push localhost:5000/myimage</span><br></pre></td></tr></table></figure>
<p>在推送镜像后，请在 kubectl specs 中通过 <code>localhost:5000/&#123;name&#125;</code> 引用它。</p>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/registry/">Registries | minikube - https://minikube.sigs.k8s.io/docs/handbook/registry/</a></p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/registry/">Registries | minikube - https://minikube.sigs.k8s.io/docs/handbook/registry/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Image</tag>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Handbook</tag>
        <tag>Deployment</tag>
        <tag>Service</tag>
        <tag>Registry</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 手册 - 故障排除</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Handbook-Troubleshooting/</url>
    <content><![CDATA[<h1>手册 - 故障排除</h1>
<p>如何解决 minikube 问题</p>
<span id="more"></span>
<h2 id="启用调试日志">启用调试日志</h2>
<p>将 <code>--alsologtostderr</code> 传递给 minikube 命令以查看详细的日志输出。要增加日志详细程度，您可以使用：</p>
<ul>
<li>
<p><code>-v=1</code>：详细消息</p>
</li>
<li>
<p><code>-v=2</code>：非常冗长的消息</p>
</li>
<li>
<p><code>-v=8</code>：超出你可能处理的更多的日志消息。</p>
</li>
</ul>
<p>例子：</p>
<p><code>minikube start --alsologtostderr --v=2</code> 将启动 minikube 并将所有重要的调试日志输出到 stderr。</p>
<h2 id="事后-minikube-调试日志">事后 minikube 调试日志</h2>
<p>minikube 将事后日志存储在系统的临时目录中。每个子命令创建一个日志文件，并且具有相同参数的子命令的任何后续调用都将附加到同一文件中。如果日志文件的大小超过 1MB，则会创建一个新的日志文件。在 macOS 或 Linux 上，很容易获得最近的日志列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find $TMPDIR -mtime -1 -type f -name &quot;*minikube*&quot; -ls  2&gt;/dev/null</span><br></pre></td></tr></table></figure>
<p>例如运行 <code>minikube start</code> 后，上面的命令将显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 user grp 718 Aug 18 12:40 /var/folders/n1/qxvd9kc/T//minikube_start_dc950831e1a232e0318a6d6ca82aaf4f4a8a048b_0.log</span><br></pre></td></tr></table></figure>
<p>这些是纯文本日志文件：您可以将它们重命名为“.log”，然后将它们拖放到 GitHub 问题中，供 minikube 团队进一步分析。您可以通过以下方式快速检查任何这些日志的最后一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -n 10 &lt;文件名&gt;</span><br></pre></td></tr></table></figure>
<p>例如，显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">I0818 12:40:17.027317   63501 out.go:197] Setting ErrFile to fd 2...</span><br><span class="line">I0818 12:40:17.027321   63501 out.go:231] isatty.IsTerminal(2) = true</span><br><span class="line">I0818 12:40:17.027423   63501 root.go:272] Updating PATH: /Users/tstromberg/.minikube/bin</span><br><span class="line">I0818 12:40:17.027715   63501 mustload.go:64] Loading cluster: minikube</span><br></pre></td></tr></table></figure>
<h2 id="收集虚拟机日志">收集虚拟机日志</h2>
<p>要调试 Kubernetes 部署失败的问题，收集 Kubernetes pod 和内核日志非常有用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube logs</span><br></pre></td></tr></table></figure>
<h2 id="查看-Pod-状态">查看 Pod 状态</h2>
<p>要查看所有 Kubernetes pod 的部署状态，请使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get po -A</span><br></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAMESPACE     NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-5c98db65d4-299md    1/1     Running   0          11m</span><br><span class="line">kube-system   coredns-5c98db65d4-qlpkd    1/1     Running   0          11m</span><br><span class="line">kube-system   etcd-minikube               1/1     Running   0          10m</span><br><span class="line">kube-system   gvisor                      1/1     Running   0          11m</span><br><span class="line">...</span><br><span class="line">kube-system   storage-provisioner         1/1     Running   0          11m</span><br></pre></td></tr></table></figure>
<p>要查看有关 pod 的更多详细信息，请使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl describe pod &lt;name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<h2 id="调试挂起的启动">调试挂起的启动</h2>
<p>minikube 将等待大约 8 分钟，然后放弃 Kubernetes 部署。如果您想立即看到启动失败，请考虑使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube logs --problems</span><br></pre></td></tr></table></figure>
<p>这将尝试显示已知错误，例如无效的配置标志。如果没有出现任何有趣的东西，请尝试使用 <code>minikube logs</code>。</p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/troubleshooting/">Troubleshooting | minikube - https://minikube.sigs.k8s.io/docs/handbook/troubleshooting/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译]</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Index/</url>
    <content><![CDATA[<h1>minikube 文档中文翻译</h1>
<p><img src="/images/minikube/kubernetes-minikube.png" alt="kubernetes-minikube.png"></p>
<ul>
<li>
<p><a href="../Welcome">欢迎! - …/Welcome</a></p>
</li>
<li>
<p><a href="../Get-Started">开始 minikube - …/Get-Started</a></p>
</li>
</ul>
<span id="more"></span>
<ul>
<li>
<p>手册</p>
<ul>
<li>
<p><a href="../Handbook-Baisc-Controls">基本控制 - …/Handbook-Baisc-Controls</a></p>
</li>
<li>
<p><a href="../Handbook-Deploying-apps">部署应用程序 - …/Handbook-Deploying-apps</a></p>
</li>
<li>
<p><a href="../Handbook-Kubectl">Kubectl - …/Handbook-Kubectl</a></p>
</li>
<li>
<p><a href="../Handbook-Accessing-apps">访问应用程序 - …/Handbook-Accessing-apps</a></p>
</li>
<li>
<p><a href="../Handbook-Addons">附加组件 - …/Handbook-Addons</a></p>
</li>
<li>
<p><a href="../Handbook-Config">配置 - …/Handbook-Config</a></p>
</li>
<li>
<p><a href="../Handbook-Pushing-Images">推送镜像 - …/Handbook-Pushing-Images</a></p>
</li>
<li>
<p><a href="../Handbook-Proxy-and-VPN">代理和VPN - …/Handbook-Proxy-and-VPN</a></p>
</li>
<li>
<p><a href="../Handbook-Registries">注册表 - …/Handbook-Registries</a></p>
</li>
<li>
<p><a href="../Handbook-Certificate">证书 - …/Handbook-Certificate</a></p>
</li>
<li>
<p><a href="../Handbook-Offline">离线使用 - …/Handbook-Offline</a></p>
</li>
<li>
<p><a href="../Handbook-Host-Access">主机访问 - …/Handbook-Host-Access</a></p>
</li>
<li>
<p><a href="../Handbook-Network-Policy">网络策略 - …/Handbook-Network-Policy</a></p>
</li>
<li>
<p><a href="../Handbook-Persistent-Volumes">持久卷 - …/Handbook-Persistent-Volumes</a></p>
</li>
<li>
<p><a href="../Handbook-Mount">挂载文件系统 - …/Handbook-Mount</a></p>
</li>
<li>
<p><a href="../Handbook-FileSync">文件同步 - …/Handbook-FileSync</a></p>
</li>
<li>
<p><a href="../Handbook-Troubleshooting">故障排除 - …/Handbook-Troubleshooting</a></p>
</li>
</ul>
</li>
<li>
<p><a href="../FAQ">常见问题解答 - …/FAQ</a></p>
</li>
</ul>
<p>上次修改时间：2022 年 2 月 24 日：更新 <code>releases.json</code> 和 <code>releases-v2.json</code> 以包含 <code>v1.25.2</code> (<code>e62251000</code>)</p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https..//minikube.sigs.k8s.i../doc../">Welcome! | minikube - https…//minikube.sigs.k8s.i…/doc…/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
      </tags>
  </entry>
  <entry>
    <title>[minikube 文档中文翻译] 欢迎！</title>
    <url>/2022/04/16/Cloud-Native/Kubernetes-K8S/minikube/Docs/Welcome/</url>
    <content><![CDATA[<h1>欢迎！</h1>
<p>Minikube 可以快速在 macOS，Linux 和 Windows 上安装本地的Kubernetes集群。 我们自豪地专注于帮助应用程序开发人员和新的Kubernetes用户。</p>
<p><img src="/images/minikube/screenshot.png" alt="minikube-screenshot.png"></p>
<p>🎉最新版本：v1.25.2  -  2月24日，2022年（<a href="https://github.com/kubernetes/minikube/blob/master/CHANGELOG.md">更改日志 - https://github.com/kubernetes/minikube/blob/master/CHANGELOG.md</a>）</p>
<span id="more"></span>
<h2 id="亮点">亮点</h2>
<ul>
<li>
<p>支持最新的Kubernetes Release（+6以前的小版本）</p>
</li>
<li>
<p>跨平台（Linux，macOS，Windows）</p>
</li>
<li>
<p>部署在VM 虚拟机，容器或裸金属</p>
</li>
<li>
<p>多个容器运行时（CRI-O，containerd，Docker）</p>
</li>
<li>
<p>提供用于快速<a href="https://minikube.sigs.k8s.io/docs/handbook/pushing/">镜像加载和构建 - https://minikube.sigs.k8s.io/docs/handbook/pushing/</a>的直接API端点</p>
</li>
<li>
<p><a href="https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access">LoadBalancer负载均衡器 - https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access</a>，文件系统安装，功能开关和<a href="https://minikube.sigs.k8s.io/docs/handbook/network_policy/">网络策略 - https://minikube.sigs.k8s.io/docs/handbook/network_policy/</a>等高级功能</p>
</li>
<li>
<p>提供<a href="https://minikube.sigs.k8s.io/docs/handbook/deploying/#addons">附加组件 - https://minikube.sigs.k8s.io/docs/handbook/deploying/#addons</a>用于轻松安装Kubernetes应用程序</p>
</li>
<li>
<p>支持常见的<a href="https://github.com/minikube-ci/examples">CI环境 - https://github.com/minikube-ci/examples</a></p>
</li>
</ul>
<h2 id="问卷调查">问卷调查</h2>
<p>我们有一个快速的5个问题<a href="https://forms.gle/Gg3hG5ZySw8c1C24A">问卷调查 - https://forms.gle/Gg3hG5ZySw8c1C24A</a>，想了解您使用 Minikube 的方式以及我们应该要做的改进。 我们很想听到您的声音！ 🙏</p>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://minikube.sigs.k8s.io/docs/">Welcome! | minikube - https://minikube.sigs.k8s.io/docs/</a></p>
<p>[2] <a href="https://github.com/kubernetes/minikube/blob/master/CHANGELOG.md">minikube/CHANGELOG.md at master · kubernetes/minikube - https://github.com/kubernetes/minikube/blob/master/CHANGELOG.md</a></p>
<p>[3] <a href="https://minikube.sigs.k8s.io/docs/handbook/pushing/">Pushing images | minikube - https://minikube.sigs.k8s.io/docs/handbook/pushing/</a></p>
<p>[4] <a href="https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access">LoadBalancer access | Accessing apps | minikube - https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access</a></p>
<p>[5] <a href="https://minikube.sigs.k8s.io/docs/handbook/network_policy/">Network Policy | minikube - https://minikube.sigs.k8s.io/docs/handbook/network_policy/</a></p>
<p>[6] <a href="https://minikube.sigs.k8s.io/docs/handbook/deploying/#addons">Deploying apps | minikube - https://minikube.sigs.k8s.io/docs/handbook/deploying/#addons</a></p>
<p>[7] <a href="https://github.com/minikube-ci/examples">minikube-ci/examples: Repository providing samples and testing for running kubernetes/minikube on various CI services - https://github.com/minikube-ci/examples</a></p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/">Welcome! | minikube - https://minikube.sigs.k8s.io/docs/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Kubernetes (K8S)</category>
        <category>minikube</category>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>macOS</tag>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Windows</tag>
        <tag>Welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>[Knative] 使用 quickstart 安装 Knative</title>
    <url>/2022/04/02/Cloud-Native/Serverless/Knative/Docs/Tutorial/Install-Knative-using-quickstart/</url>
    <content><![CDATA[<h1>使用 quickstart 安装 Knative</h1>
<p>本主题介绍如何使用 Knative <code>quickstart</code> 插件在本地快速安装部署 Knative Serving 和 Knative Eventing 。</p>
<span id="more"></span>
<p>该插件在本地 Kubernetes 集群上快速安装预配置的 Knative 部署。</p>
<blockquote>
<p>警告</p>
</blockquote>
<pre><code>Knative `quickstart` 环境仅供实验使用。有关生产环境就绪安装，请参阅基于 YAML 的安装或 Knative Operator 安装。
</code></pre>
<h2 id="在你开始之前">在你开始之前</h2>
<p>在开始使用 Knative <code>quickstart</code> 部署之前，您必须安装：</p>
<ul>
<li>
<p>kind（Docker 中的 Kubernetes ）或 minikube，使您能够使用 Docker 容器节点运行本地 Kubernetes 集群。</p>
</li>
<li>
<p>Kubernetes CLI (<code>kubectl</code>) 对 Kubernetes 集群运行命令。您可以使用 kubectl 部署应用程序、检查和管理集群资源以及查看日志。</p>
</li>
<li>
<p>Knative CLI (<code>kn</code>) v0.25 或更高版本。有关说明，请参阅下一节。</p>
</li>
<li>
<p>您需要至少 3 个 CPU 和 3 GB 的 RAM 才能创建集群。</p>
</li>
</ul>
<h3 id="安装-Knative-CLI">安装 Knative CLI</h3>
<p>Knative CLI (<code>kn</code>) 为创建 Knative 资源（例如 Knative Service 服务和 Event Source事件源）提供了一个快速简单的操作界面，无需直接创建或修改 YAML 文件。</p>
<p><code>kn</code> CLI 还简化了其他复杂的完成过程，例如自动缩放和流量拆分。</p>
<h4 id="使用-Homebrew">使用 Homebrew</h4>
<p>执行以下操作之一：</p>
<p>要使用 Homebrew 安装 <code>kn</code>，请运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install kn</span><br></pre></td></tr></table></figure>
<p>要将现有的 <code>kn</code> 安装升级到最新版本，请运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew upgrade kn</span><br></pre></td></tr></table></figure>
<blockquote>
<p>疑问 使用 Homebrew 升级 kn 时遇到问题？</p>
</blockquote>
<p>如果您在使用 Homebrew 升级时遇到问题，可能是由于 CLI 仓库的更改导致 <code>master</code> 分支重命名为 <code>main</code>。 通过运行以下命令解决此问题：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew tap --repair</span><br><span class="line">brew update</span><br><span class="line">brew upgrade kn</span><br></pre></td></tr></table></figure>
<p>通过运行以下命令验证插件是否正常工作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kn version</span><br></pre></td></tr></table></figure>
<blockquote>
<p>期望输出</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Version:      v1.3.1</span><br><span class="line">Build Date:   2022-03-11 18:43:10</span><br><span class="line">Git Revision: a591c0c0</span><br><span class="line">Supported APIs:</span><br><span class="line">* Serving</span><br><span class="line">  serving.knative.dev/v1 (knative-serving v1.3.0)</span><br><span class="line">* Eventing</span><br><span class="line">  sources.knative.dev/v1 (knative-eventing v1.3.0)</span><br><span class="line">  eventing.knative.dev/v1 (knative-eventing v1.3.0)</span><br></pre></td></tr></table></figure>
<h4 id="使用二进制">使用二进制</h4>
<p>您可以通过下载系统适用的可执行二进制文件并将其放在系统路径 <code>PATH</code>  中来安装 <code>kn</code>。 请注意，您需要 <code>kn</code> <code>v0.25</code> 或更高版本。</p>
<ol>
<li>
<p>从 <code>kn</code> <a href="https://github.com/knative/client/releases">发布页面 https://github.com/knative/client/releases</a>下载适用于您系统的二进制文件。</p>
</li>
<li>
<p>通过运行以下命令将二进制文件重命名为 <code>kn</code> 并使其可执行：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv &lt;path-to-binary-file&gt; kn</span><br><span class="line">chmod +x kn</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;path-to-binary-file&gt;</code> 是您在上一步中下载的二进制文件的路径，例如 <code>kn-darwin-amd64</code> 或 <code>kn-linux-amd64</code>。</p>
<p>通过运行以下命令将可执行二进制文件移动到 <code>PATH</code> 上的目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv kn /usr/local/bin</span><br></pre></td></tr></table></figure>
<h4 id="使用-Go">使用 Go</h4>
<ol>
<li>检出 kn 客户端仓库：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/knative/client.git</span><br><span class="line"></span><br><span class="line">cd client/</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>构建可执行二进制文件：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hack/build.sh -f</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>将 kn 移动到您的系统路径 <code>PATH</code> 中，并验证 <code>kn</code> 命令是否正常工作。 例如：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv kn /usr/local/bin</span><br><span class="line"></span><br><span class="line">kn version</span><br></pre></td></tr></table></figure>
<h4 id="使用容器镜像">使用容器镜像</h4>
<p><a href="https://gcr.io/knative-releases/knative.dev/client/cmd/kn">最新发布容器镜像链接 https://gcr.io/knative-releases/knative.dev/client/cmd/kn</a></p>
<p>您可以从容器镜像运行 <code>kn</code>。 例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -v &quot;$HOME/.kube/config:/root/.kube/config&quot; gcr.io/knative-releases/knative.dev/client/cmd/kn:latest service list</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
</blockquote>
<pre><code>从容器镜像运行 `kn` 不会将二进制文件放在永久路径上。 每次要使用 `kn` 时都必须重复上一步命令。
</code></pre>
<h2 id="安装-Knative-quickstart-插件">安装 Knative quickstart 插件</h2>
<p>首先，安装 Knative <code>quickstart</code> 插件：</p>
<h3 id="使用-Homebrew-2">使用 Homebrew</h3>
<p>执行以下操作之一：</p>
<p>要使用 Homebrew 安装 <code>quickstart</code> 插件，请运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install knative-sandbox/kn-plugins/quickstart</span><br></pre></td></tr></table></figure>
<p>要将现有的 <code>quickstart</code> 升级到最新版本，请运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew upgrade knative-sandbox/kn-plugins/quickstart</span><br></pre></td></tr></table></figure>
<h3 id="使用二进制-2">使用二进制</h3>
<p>从 <code>kn-plugin-quickstart</code> 快速开始<a href="https://github.com/knative-sandbox/kn-plugin-quickstart/releases">发布页面 https://github.com/knative-sandbox/kn-plugin-quickstart/releases</a>下载适用于您系统的可执行二进制文件。<br>
将可执行二进制文件移动到 <code>PATH</code> 上的目录，例如 <code>/usr/local/bin</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv &lt;path-to-binary-file&gt; kn</span><br><span class="line">chmod +x kn</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;path-to-binary-file&gt;</code> 是您在上一步中下载的二进制文件的路径，例如 <code>kn-quickstart-darwin-amd64</code> 或 <code>kn-quickstart-linux-amd64</code>。</p>
<p>验证插件是否正常工作，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kn quickstart --help</span><br></pre></td></tr></table></figure>
<h3 id="使用-Go-2">使用 Go</h3>
<p>检出 <code>kn-plugin-quickstart</code> 仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/knative-sandbox/kn-plugin-quickstart.git</span><br><span class="line">cd kn-plugin-quickstart/</span><br></pre></td></tr></table></figure>
<p>构建可执行二进制文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hack/build.sh</span><br></pre></td></tr></table></figure>
<p>将生成的可执行二进制文件移动到 <code>PATH</code> 上的目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv kn-quickstart /usr/local/bin</span><br></pre></td></tr></table></figure>
<p>验证插件是否正常工作，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kn quickstart --help</span><br></pre></td></tr></table></figure>
<blockquote>
<p>期望输出</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Get up and running with a local Knative environment</span><br><span class="line">Usage:</span><br><span class="line">kn-quickstart [command]</span><br><span class="line">Available Commands:</span><br><span class="line">completion  Generate the autocompletion script for the specified shell</span><br><span class="line">help        Help about any command</span><br><span class="line">kind        Quickstart with Kind</span><br><span class="line">minikube    Quickstart with Minikube</span><br><span class="line">version     Prints the plugin version</span><br><span class="line">Flags:</span><br><span class="line">-h, --help   help for kn-quickstart</span><br><span class="line">Use &quot;kn-quickstart [command] --help&quot; for more information about a command.  </span><br></pre></td></tr></table></figure>
<h2 id="运行-Knative-快速开始插件">运行 Knative 快速开始插件</h2>
<p><code>quickstart</code> 插件完成以下功能：</p>
<ul>
<li>
<p>检查您是否已经安装了选定版本的 Kubernetes 实例</p>
</li>
<li>
<p>创建一个名为 <code>knative</code> 的集群</p>
</li>
<li>
<p>安装 Knative Serving，Kourier 作为默认网络层，<a href="http://sslip.io">sslip.io</a> 作为 DNS</p>
</li>
<li>
<p>安装 Knative Eventing 并创建在内存中的 Broker 和 Channel 实现</p>
</li>
</ul>
<p>要获得 Knative 的本地部署，请运行 <code>quickstart</code> 插件：</p>
<h3 id="使用-kind">使用 kind</h3>
<ol>
<li>通过运行以下命令在本地 Docker 守护程序上安装 Knative 和 Kubernetes：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kn quickstart kind</span><br></pre></td></tr></table></figure>
<blockquote>
<p>期望输出</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">☸ Creating Kind cluster...</span><br><span class="line">Creating cluster &quot;knative&quot; ...</span><br><span class="line">  ✓ Ensuring node image (kindest/node:v1.23.3) 🖼 </span><br><span class="line">  ✓ Preparing nodes 📦  </span><br><span class="line">  ✓ Writing configuration 📜 </span><br><span class="line">  ✓ Starting control-plane 🕹️ </span><br><span class="line">  ✓ Installing CNI 🔌 </span><br><span class="line">  ✓ Installing StorageClass 💾 </span><br><span class="line">  ✓ Waiting ≤ 2m0s for control-plane = Ready ⏳ </span><br><span class="line">  • Ready after 17s 💚</span><br><span class="line">Set kubectl context to &quot;kind-knative&quot;</span><br><span class="line">You can now use your cluster with:</span><br><span class="line"></span><br><span class="line">kubectl cluster-info --context kind-knative</span><br><span class="line"></span><br><span class="line">Not sure what to do next? 😅  Check out https://kind.sigs.k8s.io/docs/user/quick-start/</span><br><span class="line"></span><br><span class="line">🍿 Installing Knative Serving v1.3.0 ...</span><br><span class="line">    CRDs installed...</span><br><span class="line">    Core installed...</span><br><span class="line">    Finished installing Knative Serving</span><br><span class="line">🕸️ Installing Kourier networking layer v1.3.0 ...</span><br><span class="line">    Kourier installed...</span><br><span class="line">    Ingress patched...</span><br><span class="line">    Finished installing Kourier Networking layer</span><br><span class="line">🕸 Configuring Kourier for Kind...</span><br><span class="line">    Kourier service installed...</span><br><span class="line">    Domain DNS set up...</span><br><span class="line">    Finished configuring Kourier</span><br><span class="line">🔥 Installing Knative Eventing v1.3.0 ... </span><br><span class="line">    CRDs installed...</span><br><span class="line">    Core installed...</span><br><span class="line">    In-memory channel installed...</span><br><span class="line">    Mt-channel broker installed...</span><br><span class="line">    Example broker installed...</span><br><span class="line">    Finished installing Knative Eventing</span><br><span class="line">🚀 Knative install took: 6m57s </span><br><span class="line">🎉 Now have some fun with Serverless and Event Driven Apps!</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装插件完成后，验证您有一个名为 <code>knative</code> 的集群：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kind get clusters</span><br></pre></td></tr></table></figure>
<blockquote>
<p>期望输出</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">knative</span><br></pre></td></tr></table></figure>
<h3 id="使用-minikube">使用 minikube</h3>
<ol>
<li>通过运行以下命令在 <code>minikube</code> 实例中安装 Knative 和 Kubernetes ：</li>
</ol>
<blockquote>
<p>注释</p>
</blockquote>
<pre><code>minikube 集群将使用 6 GB 的 RAM 创建。 如果您没有足够的内存，您可以通过在此命令之前运行命令 `minikube config set memory 3078` 更改为不低于 3 GB 的其他值。
</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kn quickstart minikube</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>上一个命令的输出要求您运行 minikube 隧道。 运行以下命令以在单独的辅助终端窗口中启动隧道进程，然后返回主窗口并按 Enter 键继续：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube tunnel --profile knative</span><br></pre></td></tr></table></figure>
<p>当您使用 Knative quickstart环境时，<code>minikube tunnel</code> 进程必须继续在单独的终端窗口中运行。</p>
<p>运行隧道进程是必需的，因为它允许您的集群作为 LoadBalancer 从您的主机访问 Knative 入口服务。</p>
<blockquote>
<p>注意</p>
</blockquote>
<pre><code>要终止 `minikube tunnel` 进程并清理网络路由，请输入快捷键 `Ctrl-C`。 有关 `minikube tunnel` 命令的更多信息，请参阅 [minikube 文档 https://minikube.sigs.k8s.io/docs/handbook/accessing/#using-minikube-tunnel](https://minikube.sigs.k8s.io/docs/handbook/accessing/#using-minikube-tunnel)。
</code></pre>
<ol start="3">
<li>安装 quickstart 插件完成后，验证您有一个名为 knative 的集群：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube profile list</span><br></pre></td></tr></table></figure>
<h2 id="下一步">下一步</h2>
<ul>
<li>
<p>在 Knative 教程中了解如何部署您的第一个 Service 服务。</p>
</li>
<li>
<p>试用 Knative 代码示例。</p>
</li>
<li>
<p>请参阅 Knative Serving 和 Knative Eventing 指南。</p>
</li>
</ul>
<h2 id="参考链接">参考链接</h2>
<p>[1] <a href="https://knative.dev/docs/getting-started/quickstart-install/">Install Knative using quickstart - Knative - https://knative.dev/docs/getting-started/quickstart-install/</a></p>
<p>[2] <a href="https://knative.dev/docs/install/yaml-install/">About YAML-based installation - Knative - https://knative.dev/docs/install/yaml-install/</a></p>
<p>[3] <a href="https://knative.dev/docs/install/operator/knative-with-operators/">Installing using the Operator - Knative - https://knative.dev/docs/install/operator/knative-with-operators/</a></p>
<p>[4] <a href="https://kind.sigs.k8s.io/docs/user/quick-start">kind – Quick Start - https://kind.sigs.k8s.io/docs/user/quick-start</a></p>
<p>[5] <a href="https://minikube.sigs.k8s.io/docs/start/">minikube start | minikube - https://minikube.sigs.k8s.io/docs/start/</a></p>
<p>[6] <a href="https://kubernetes.io/docs/tasks/tools/">Install Tools | Kubernetes - https://kubernetes.io/docs/tasks/tools/</a></p>
<p>[7] <a href="https://brew.sh/">The Missing Package Manager for macOS (or Linux) — Homebrew - https://brew.sh/</a></p>
<p>[8] <a href="https://formulae.brew.sh/formula/kn">kn — Homebrew Formulae - https://formulae.brew.sh/formula/kn</a></p>
<p>[9] <a href="https://github.com/knative/client/releases">Releases · knative/client · GitHub - https://github.com/knative/client/releases</a></p>
<p>[10] <a href="https://github.com/knative/client">GitHub - knative/client: Knative developer experience, docs, reference Knative CLI implementation - https://github.com/knative/client</a></p>
<p>[11] <a href="https://console.cloud.google.com/gcr/images/knative-releases/GLOBAL/knative.dev/client/cmd/kn">Images – Container Registry – Google Cloud Platform - https://console.cloud.google.com/gcr/images/knative-releases/GLOBAL/knative.dev/client/cmd/kn</a></p>
<p>[12] <a href="https://github.com/knative-sandbox/homebrew-kn-plugins">GitHub - knative-sandbox/homebrew-kn-plugins: Homebrew tap for holding all kn plugins that are released together with Knative. - https://github.com/knative-sandbox/homebrew-kn-plugins</a></p>
<p>[13] <a href="https://minikube.sigs.k8s.io/docs/handbook/accessing/#using-minikube-tunnel">Accessing apps | minikube - https://minikube.sigs.k8s.io/docs/handbook/accessing/#using-minikube-tunnel</a></p>
<p>[14] <a href="https://knative.dev/docs/">Home - Knative - https://knative.dev/docs/</a></p>
<hr>
<h2 id="原文链接">原文链接</h2>
<p><a href="https://knative.dev/docs/install/quickstart-install/">Install Knative using quickstart Knative https://knative.dev/docs/install/quickstart-install/</a></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Serverless</category>
        <category>Knative</category>
        <category>Docs</category>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Homebrew</tag>
        <tag>Cloud Native</tag>
        <tag>Docs</tag>
        <tag>kubectl</tag>
        <tag>K8S</tag>
        <tag>Kubernetes</tag>
        <tag>Kubernetes (K8S)</tag>
        <tag>Infrastructure</tag>
        <tag>IaC</tag>
        <tag>Infrastructure as Code</tag>
        <tag>Infrastructure as Code (IaC)</tag>
        <tag>CNCF</tag>
        <tag>Cloud Native Computing Foundation</tag>
        <tag>Cloud Native Computing Foundation (CNCF)</tag>
        <tag>minikube</tag>
        <tag>Knative Serving</tag>
        <tag>Knative Eventing</tag>
        <tag>quickstart</tag>
        <tag>kind</tag>
        <tag>kn</tag>
        <tag>kn-quickstart</tag>
        <tag>Serverless</tag>
        <tag>Knative</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>404 找不到网页</title>
    <url>//404.html</url>
    <content><![CDATA[<h1>返回 <a href="/">首页</a></h1>
]]></content>
  </entry>
  <entry>
    <title>关于我们</title>
    <url>/about-us/index.html</url>
    <content><![CDATA[<h1>关于 CloudoLife 面向云生活</h1>
<p><img src="/images/CloudoLife/CloudoLife-logo-white-400x275.png" alt="CloudoLife-logo-white"></p>
<p>CloudoLife 面向云生活，全称 Cloud-oriented Life，简称 CoL。是一个专注于云工程 (Cloud Engineering) 的开源团体，致力于使用云技术改善生活：</p>
<ul>
<li>
<p>关注云计算 (Cloud Computing)，云原生 (Cloud Native)、大数据 (Big Data) 和人工智能 (Artificial Intelligence) 等领域技术。</p>
</li>
<li>
<p>洞察和引入创新的技术，培训和推广成熟稳定的技术，识别、管理和解决技术风险和难题。</p>
</li>
</ul>
<p>微信公众号 <code>CloudoLife 面向云生活</code>，会不定期发布云技术相关资讯。欢迎关注👍👍！</p>
<p><img src="/images/CloudoLife/CloudoLife-WeChat-Officai-Account-QRCode-200x260.png" alt="CloudoLife-WeChat-Officai-Account-QRCode"></p>
<h2 id="团队成员">团队成员</h2>
<h3 id="Blogbin">Blogbin</h3>
<p>Hi，我是 Blogbin，是一名丈夫和父亲、IT 知识创作工作者。同时：</p>
<ul>
<li>
<p>也是一个实战经验丰富的云工程师 (Cloud Engineer)，对云技术特别感兴趣，包括云计算 (Cloud Computing)，云原生 (Cloud Native)、大数据 (Big Data) 和人工智能 (Artificial Intelligence)等领域技术。</p>
</li>
<li>
<p>擅长使用 C / C++, C#, Golang, Java, JavaScript / TypeScript, Python, Ruby / Ruby on Rails, Rust 等多种编程语言开发、构建和发布软件系统和产品应用。</p>
</li>
<li>
<p>拥有超过 20 年的软件工程和项目团队管理经验，涉及业务咨询，项目管理，系统设计，架构设计，开发编码，软件测试，系统运营、系统维护以及安全审计等领域，为电信、电商、跨境、物流、留学、金融、医疗、健康、计费，教育等不同行业的复杂业务提供基于互联网的IT系统解决方案，并带领团队完成系统的实施交付。</p>
</li>
<li>
<p>喜欢投入精力在有意义的事情上，并能够从开放、开源和自由精神中找到创作灵感。</p>
</li>
</ul>
<p>这是我的微信账号 <code>blogbins</code>，欢迎加微信好友沟通交流🤝🤝！</p>
<p><img src="/images/CloudoLife/Blogbin/blogbins-WeChat-QRCode-158x209.jpg" alt="blogbins-WeChat-QRCode"></p>
]]></content>
  </entry>
  <entry>
    <title>归档</title>
    <url>/archives/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
